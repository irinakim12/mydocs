[
{
	"uri": "https://devbj.com/golangkorea/go-walkthrough/bytes-strings-packages/",
	"title": "Go 둘러보기 - bytes + strings 패키지",
	"tags": ["Golang", "Bytes", "Strings", "Package"],
	"description": "",
	"content": " Go Walkthrough 시리즈의 Go Walkthrough: bytes + strings packages를 번역한 글입니다.\n 우린 지난번 포스트에서 바이트 스트림을 다뤄봤는데 가끔은 제한적인 범위에서, 인메모리 바이트 슬라이스를 가지고 작업해야 할 수도 있다. 바이트의 리스트로 작업 하는 것은 충분히 간단해 보일 수 있지만, bytes 패키지를 유용하게 활용할 수 있는 많은 엣지 케이스와 일반적인 연산들이 있다. 우리는 또한 strings 패키지는 문자열 작업을 위한것임에도 불구하고 이 API와 거의 동일하기 때문에 이 포스트에서는 이 strings 패키지에 대해 파헤쳐 볼 것이다.\n이 포스트는 표준 라이브러리를 이해하는데 도움을 주기위한 Go 둘러보기 시리즈의 일부이다. 기존에 생성된 문서( 자동으로 생성된 Go 문서)는 많은 정보를 제공하지만, 이는 패키지를 실제 상황에서 이해하기에는 어려울 수 있다. 이 시리즈는 일상적으로 사용되는 애플리케이션에서 표준 패키지들이 어떻게 사용되는지에 대한 컨텍스트를 제공할 수 있도록 도와준다. 질문이나 코멘트가 있다면 트위터에서 @benbjohnson로 찾 아오면 된다.\n바이트와 스트링의 간단한 비교 Rob Pike는 strings, bytes, runes, and characters에 대한 훌륭한 포스트를 가지고 있지만 이 포스트에서는 애플리케이션 개발자의 관점에서 좀 더 간결한 정의를 제공하려고 한다.\n바이트 슬라이스는 변형 가능하고, 크기 조절이 가능한 연속적인 바이트 리스트를 나타낸다. 그럼 이제 이게 무슨 뜻인지를 알아보자.\n바이트 슬라이스가 하나 주어졌다:\nbuf := []byte{1,2,3,4} 이는 변형 가능하므로 원소 갱신이 가능하다:\nbuf[3] = 5 // []byte{1,2,3,5} 이는 크기 조절이 가능하므로 축소 또는 확장이 가능하다:\nbuf = buf[:2] // []byte{1,2} buf = append(buf, 100) // []byte{1,2,100} 그리고 이는 연속적이므로 메모리상에서 각 바이트는 다른 바이트의 바로 뒤에 위치한다:\n1|2|3|4 반면에, 문자열은 변형 불가능하고, 고정된 크기의 연속적인 바이트 리스트를 나타낸다. 이는 문자열은 갱신이 불가능함을 의미한다 - 새로운 문자열을 생성하는 수 밖에 없다. 이는 성능 관점에서 중요하다. 고성능 코드에서, 계속해서 새로운 문자열을 생성하면 가비지 컬렉터에 많은 부하가 추가된다.\n애플리케이션 개발 관점에서, 문자열은 UTF-8 데이터로 작업 할 때 사용하기 쉬우며 바이트 슬라이스를 사용할 수 없는 맵(map)의 키값으로도 쓰일 수 있다. 그리고 대다수의 API는 문자 데이터를 포함하는 인자에 문자열을 사용한다. 반면에, 바이트 슬라이스는 바이트 스트림을 처리하는 등의 로우(raw) 바이트를 다룰 때 사용하기 좋다. 이는 또한 새로 할당을 하지 않고 데이터를 재사용 해야할 경우에 유용하다.\n스트림을 위한 문자열\u0026amp;슬라이스 개조하기 바이트와 문자열 패키지의 가장 중요한 특징중 하나는 io.Reader와 io.Writer로 인메모리 바이트 슬라이스와 문자열을 인터페이싱할 수 있는 방법을 제공한다는 것이다.\n인메모리 Reader Go 표준 라이브러리에서 가장 많이 사용되는 툴 두 가지는 bytes.NewReader와 strings.NewReader 함수이다:\nfunc NewReader(b []byte) *Reader func NewREader(s string) *Reader  byte : byte, (byte)Reader : Reader, string : string, (string)Reader : Reader\n 이 함수들은 인메모리 바이트 슬라이스 또는 문자열을 래핑하는 io.Reader 구현체를 반환한다. 그러나 이들은 단순한 Reader가 아니다. 이들은 io의 io.ReaderAt, io.WriterTo, io.ByteReader, io.ByteScanner, io.RuneReader, io.RuneScanner, \u0026amp; io.Seeker를 포함하는 읽기와 관련된 모든 인터페이스를 구현하고 있다.\n나는 바이트 슬라이스 또는 문자열이 bytes.Buffer에 쓰여지고 이 버퍼가 Reader로써 사용되는 코드를 자주 본다:\nvar buf bytes.Buffer buf.WriteString(\u0026#34;foo\u0026#34;) http.Post(\u0026#34;http://example.com/\u0026#34;, \u0026#34;text/plain\u0026#34;, \u0026amp;buf) 그러나, 이 방법은 힙 메모리 할당을 발생시켜 느려지고 추가적인 메모리를 사용하게 된다. 더 좋은 방안은 strings.Reader을 사용하는 것이다:\nr := strings.NewReader(\u0026#34;foobar\u0026#34;) http.Post(\u0026#34;http://example.com\u0026#34;, \u0026#34;text/plain\u0026#34;, r) 이 방법은 io.MultiReader를 사용함으로써 여러개의 문자열 또는 바이트 슬라이스를 가지고 있을 때에도 잘 동작한다:\nr := io.MultiReader( strings.NewReader(\u0026#34;HEADER\u0026#34;), bytes.NewReader([]byte{0,1,2,3,4}), myFile, strings.NewReader(\u0026#34;FOOBAR\u0026#34;), ) 인메모리 Writer 바이트 패키지는 Buffer라고 부르는 io.Writer의 인메모리 구현체를 포함하고 있다. 이는 io.Closer와 io.Seeker를 제외한 io 인터페이스의 거의 모든 것을 구현하고 있다. 여기엔 버퍼의 끝에 문자열을 쓰기위한 WriteString()이라는 헬퍼 메서드도 있다.\n나는 유닛 테스트에서 서비스에서 나오는 로그들을 캡쳐하기위해 Buffer를 광범위하게 사용한다. 여러분은 이를 log.New()의 인자로써 전달할 수 있으며 나중에 출력값들을 검증할 수 있다:\nvar buf bytes.Buffer myService.Logger = log.New(\u0026amp;buf, \u0026#34;\u0026#34;, log.LstdFlags) myService.Run() if !strings.Contains(buf.String(), \u0026#34;service failed\u0026#34;) { t.Fatal(\u0026#34;expected log message\u0026#34;) }  Buffer : Buffer, LstdFlags : LstdFlags, Contains : Contains, String : String, Fatal : Fatal\n 그러나, 나는 프로덕션 코드에서는 Buffer를 거의 사용하지 않는다. 이름이 Buffer임에도 불구하고, 해당 목적에 좀 더 특화된 bufio 패키지가 있기 때문에 Buffer를 버퍼 읽기와 쓰기에 사용하지 않는다.\n패키지 구조 바이트와 문자열 패키지의 첫인상은 큰 패키지처럼 보이지만 이는 단지 그냥 간단한 헬퍼 함수들의 컬렉션이다. 우리는 이들을 몇 개의 카테고리로 그룹핑 할 수 있다.\n 비교 함수 (Comparison functions) 검사 함수 (Inspection functions) 접두/접미 함수 (Prefix/suffix functions) 교체 함수 (Replacement functions) 분할 \u0026amp; 결합 함수 (Splitting \u0026amp; joining functions)  함수들이 어떻게 함께 그룹핑 되는지를 이해한다면, 대형 API에 접근하기가 훨씬 쉬워질 것이다.\n비교 함수 두 개의 바이트 슬라이스 또는 문자열을 가지고 있을 때 다음 두 질문중 하나를 질문해야 할 수도 있다. 첫째, 두 객체가 동일한가? 둘째, 정렬시 어떤게 앞쪽에 위치하는가?\n동일성 Equal() 함수는 첫번째 질문에 대한 답을 준다:\nfunc Equal(a, b []byte) bool  byte : byte, bool : bool\n 이 함수는 바이트 패키지에만 존재하는데 문자열은 == 연산자로 비교가 가능하기 때문이다.\n동일함을 확인하는건 쉬워 보일 수 있지만, 한 가지 일반적으로 나타나는 실수는 대소문자에 무관하게 동일함을 확인하기 위해 strings.ToUpper()를 사용하는 것이다.\nif strings.ToUpper(a) == strings.ToUpper(b) { return True } 이는 새로운 문자열에 대한 2번의 할당이 필요하기 때문에 결점이 있다. 좀 더 나은 방법은 EqualFold()를 사용하는 것이다:\nfunc EqualFold(s, t []byte) bool func EqualFold(s, t string) bool  byte : byte, string : string, bool : bool\n \u0026ldquo;Fold\u0026quot;라는 용어는 Unicode case-folding을 말한다. 이는 A-Z에 대한 일반적인 대소문자 규칙뿐만 아니라 ϕ의 φ로의 변환과 같은 다른 언어에 대한 규칙까지 포함한다.\n비교 우리는 두 개의 바이트 슬라이스 또는 문자열의 정렬 순서를 결정하기 위해 Compare()를 사용할 것이다.\nfunc Compare(a, b []byte) int func Compare(a, b string) int  byte : byte, string : string, int : int\n 이 함수는 a 가 b 보다 작을 땐 -1, a 가 b 보다 클 땐 1, 그리고 a 와 b 가 같을 땐 0을 반환한다. 이 함수는 strings 패키지에도 존재하는데 이는 단지 바이트 패키지와의 대칭을 이루기 위해서이다. Russ Cox도 함수의 주석에 써있는 \u0026ldquo;기본적으로 아무도 strings.Compare를 사용해선 안된다\u0026ldquo;라는 말을 언급하며, 내장 연산자인 \u0026lt; 와 \u0026gt;를 대신 사용한다.\n\u0026ldquo;기본적으로 아무도 strings.Compare를 사용해선 안된다\u0026rdquo;, Russ Cox {: style=\u0026quot;text-align: center; font-size: 18px;\u0026quot;}\n일반적으로, 정렬을 하기 위해 바이트 슬라이스가 다른 바이트 슬라이스보다 작은지에 대한 여부를 알고 싶을 것이다. sort.Interface는 Less() 함수를 위해 이를 필요로한다. Less()는 Compare()의 세 가지 값을 갖는 반환값의 부울값으로의 변환을 필요로한다. 우리는 단순히 이 값이 -1과 같은지를 확인한다:\ntype ByteSlices [][]byte func (p ByteSlices) Less(i, j int) bool { return bytes.Compare(p[i], p[j]) == -1 } 검사(Inspection) 함수 바이트와 문자열 패키지는 바이트 슬라이스와 문자열내에서 데이터를 찾기 위한 몇 가지 방법들을 제공한다.\n카운팅 만약 여러분이 유저의 입력의 유효성을 검증하고 있다면, 특정 바이트가 존재하는지 (또는 존재하지 않는지)를 검증하는건 중요하다. 하나 이상의 부분 슬라이스 또는 부분 문자열의 존재를 확인하기 위해 Contains() 함수를 사용할 수 있다:\nfunc Contains(b, subslice []byte) bool func Contains(s, substr string) bool  byte : byte, string : string, bool : bool\n 예를 들면, 여러분이 부적절한 특정 단어들을 가진 입력을 허용하지 않을 수도 있다:\nif strings.Contains(input, \u0026#34;darn\u0026#34;) { return errors.New(\u0026#34;inappropriate input\u0026#34;) } 부분 슬라이스나 부분 문자열이 정확히 몇 번 사용되었는지를 알기 위해선, Count()를 사용할 수 있다:\nfunc Count(s, sep []byte) int func Count(s, sep string) int  byte : byte, string : string, int : int\n Count()의 또 다른 사용은 문자열에 있는 룬의 갯수를 반환하는 것이다. sep 인자에 빈 슬라이스나 빈 문자열을 전달하면 Count()는 룬의 갯수 + 1을 반환할 것이다. 이는 바이트 수를 반환하는 len()과는 다르다. 이 차이점은 멀티바이트 유니코드 문자들을 다룰 때 중요하다:\nstrings.Count(\u0026#34;I ❤ ☃\u0026#34;, \u0026#34;\u0026#34;) // 6 len(\u0026#34;I ❤ ☃\u0026#34;) // 9 첫번째 줄은 룬이 5개만 있기 때문에 이상하게 보일 수 있지만 Count()는 룬 갯수 + 1을 반환한다는 걸 기억하라.\n인덱싱 내용을 단언하는건 중요하지만 가끔은 부분 슬라이스나 부분 문자열의 정확한 위치를 찾아낼 필요가 있다. 인덱스 함수를 사용하면 가능하다:\nIndex(s, sep []byte) int IndexAny(s []byte, chars string) int IndexByte(s []byte, c byte) int IndexFunc(s []byte, f func(r rune) bool) int IndexRune(s []byte, r rune) int 각기 다른 상황을 위한 여러개의 인덱스 함수들이 있다. Index()는 멀티바이트 부분 슬라이스를 찾는다. IndexByte()는 슬라이스에서 단일 바이트를 찾는다. IndexRune()은 UTF-8로 해석된 바이트 슬라이스 내에서 유니코드 코드 포인트를 찾는다. IndexAny()는 IndexRune()처럼 동작하지만 한 번에 여러 개의 코드 포인트를 검색한다. 마지막으로, IndexFunc()는 바이트 슬라이스에서 매칭될 때까지 각각의 룬을 검사하는 커스텀 함수를 전달할 수 있도록 해준다.\n또한 바이트 슬라이스 또는 문자열의 끝의 첫번째 인스턴스를 검색하기 위한 함수의 매칭 세트도 있다.\nLastIndex(s, sep []byte) int LastIndexAny(s []byte, chars string) int LastIndexByte(s []byte, c byte) int LastIndexFunc(s []byte, f func(r rune) bool) int 나는 인덱스 함수를 많이 사용하지 않는다, 왜냐하면 나는 보통 파서와 같은 좀 더 복잡한 것을 만들어야 하기 때문이다.\n접두사, 접미사 \u0026amp; 트리밍(Trimming) 바이트 슬라이스 또는 문자열의 처음이나 끝부분의 내용을 가지고 작업하는 일은 검사의 특수한 경우지만 이는 한 섹션으로 다룰만큼 중요하다.\n접두사 \u0026amp; 접미사 확인하기 접두사는 프로그래밍에서 자주 등장한다. 예를 들면, HTTP 경로는 보통 공통 접두사를 갖는 기능별로 그룹핑된다. 또 다른 예는 유저를 멘션하기 위한 \u0026ldquo;@\u0026ldquo;와 같은 문자열 첫부분의 특수 문자들이다.\nHasPrefix()와 HasSuffix() 함수로 이러한 상황을 확인할 수 있다:\nfunc HasPrefix(s, prefix []byte) bool func HasPrefix(s, prefix string) bool func HasSuffix(s, prefix []byte) bool func HasSuffix(s, suffix string) bool  byte : byte, string : string, bool : bool\n 이 함수들은 너무 간단해 보일 수 있지만 내가 본 한가지 흔한 실수는 개발자들이 길이가 0인 값을 확인하는 것을 잊어버릴 때이다:\nif str[0] == \u0026#39;@\u0026#39; { return true } 이 코드는 간단해 보이지만 만약 str이 빈 문자열이라면 프로그램은 패닉을 발생 시킬 것이다. HasPrefix() 함수는 여러분을 위해 이 유효성 검증을 포함하고 있다:\nif strings.HasPrefix(str, \u0026quot;@\u0026quot;) { return true }  HasPrefix : HasPrefix()\n 트리밍(Trimming) bytes와 strings 패키지에서의 \u0026ldquo;trimming\u0026quot;이라는 용어는 바이트 슬라스나 문자열의 첫부분 그리고/또는 끝부분에 있는 바이트 또는 룬들을 제거한다는 의미이다. 이를 위한 가장 일반적인 함수는 Trim()이다:\nfunc Trim(s []byte, cutset string) []byte func Trim(s string, cutset string) string  byte : byte, string : string\n 이는 문자열의 첫부분과 끝부분에서 cutset의 모든 룬을 제거할 것이다. 여러분은 또한 TrimLeft()와 TrimRight()를 사용하면 각각 문자열의 첫부분에서만 또는 끝부분에서만 룬을 제거할 수도 있다:\n그러나 일반적인 트리밍은 정말 흔하지 않다. 대다수의 경우는 공백 문자를 없애는 일이며 이를 위해 TrimSpace()를 사용할 수 있다:\nfunc TrimSpace(s []byte) []byte func TrimSpace(s string) string  byte : byte, string : string\n \u0026ldquo;\\n\\t\u0026rdquo; cutset을 가지고 트리밍을 하는걸로도 충분하다고 생각할 수 있지만 TrimSpace()는 모든 유니코드로 정의된 공백을 트리밍 한다. 이는 스페이스, 개행, 그리고 탭 문자 뿐만 아니라 thin space 또는 hair space와 같은 특이한 공백도 포함한다,\nTrimSpace()는 그냥 트리밍을 위해 전행(leading)과 후행(trailing) 룬들을 평가하는 함수인 TrimFunc()의 씬 래퍼이다.\nfunc TrimSpace(s string) string { return TrimFunc(s, unicode.IsSpace) } 이는 여러분이 자체적으로 후행 문자만을 위한 공백 트리머를 생성하는걸 쉽게 만들어준다.\nTrimRightFunc(s, unicode.IsSpace)  TrimRightFunc : TrimRightFunc\n 마지막으로, 문자셋 대신 접두사나 접미사만을 트리밍 하고싶은 경우엔 TrimPrefix()와 TrimSuffix() 함수를 사용하면 된다:\nfunc TrimPrefix(s, prefix []byte) []byte func TrimPrefix(s, prefix string) string func TrimSuffix(s, suffix []byte) []byte func TrimSuffix(s, suffix string) string  byte : byte, string : string\n 이들은 만약 여러분이 접두사나 접미어를 교체하고 싶은 경우 HasPrefix()와 HasSuffix() 함수와 함께 사용할 수 있다. 예를 들면, 나는 나의 설정 파일 경로에 대한 배쉬 스타일의 홈 디렉토리 완성을 구현하기 위해 이를 사용한다.\n// 유저의 홈 디렉토리를 찾는다. u, err := user.Current() if err != nil { return err } else if u.HomeDir == \u0026#34;\u0026#34; { return errors.New(\u0026#34;hoem directory does not exist\u0026#34;) } // 물결표 대시 접두사를 홈 디렉토리로 교체. if strings.HasPrefix(path, \u0026#34;~/\u0026#34;) { path = filepath.Join(u.HomeDir, strings.TrimPrefix(path, \u0026#34;~/\u0026#34;)) } 교체 함수 기본 교체 부분 슬라이스나 부분 문자열을 교체하는건 때때로 필수적이다. 대부분의 단순한 경우엔, Replace() 함수면 다 된다:\nfunc Replace(s, old, new []byte, n int) []byte func Replace(s, old, new string, n int) string  byte : byte, string : string\n 이는 문자열에서 old 에 해당하는 모든 인스턴스를 new 로 바꿀 것이다. 교체의 횟수를 제한하려면 n 을 음이 아닌 정수로 지정하면 된다. 이 함수는 사용자 정의 템플릿에서 간단한 플레이스홀더를 가지고 있을 때 유용하다. 예를 들면, 유저가 \u0026ldquo;$NOW\u0026quot;를 지정하면 이를 현재 시각으로 교체하도록 할 수 있다;\nnow := time.Now().Format(time.Kitchen) println(strings.Replace(data, \u0026#34;$NOW\u0026#34;, now, -1))  Now : Now, Format : Format, Kitchen : Kitchen, Replace : Replace\n 만약 다중 매핑을 가지고 있다면 strings.Replacer를 사용해야 할 것이다. 이는 strings.NewReplacer()에 old/new 쌍을 지정하여 사용한다.\nr := strings.NewReplacer(\u0026#34;$NOW\u0026#34;, now, \u0026#34;$USER\u0026#34;, \u0026#34;mary\u0026#34;) println(r.Replace(\u0026#34;Hello $USER, it is $NOW\u0026#34;)) // 출력값: Hello mary, it is 3:04PM  NewReplacer : NewReplacer, Replace : Replace\n 대소문자 교체 여러분은 대소문자 케이싱(casing: 문자 케이스 캐스팅)이 간단하다고 생각할 수도 있다. 그러나 Go는 유니코드를 가지고 동작하며 유니코드는 결코 간단하지 않다. 문자 케이싱은 3가지 타입이 있다: 대문자(upper case), 소문자(lower case) 그리고 타이틀 케이스(title case).\n대문자와 소문자는 대다수의 언어에서 간단하며 여러분은 ToUpper()와 ToLower() 함수를 사용할 수 있다:\nfunc ToUpper(s []byte) []byte func ToUpper(s string) string func ToLower(s []byte) []byte func ToLower(s string) string  byte : byte, string : string\n 그러나 몇몇 언어에서는 케이싱의 룰이 다르다. 예를 들면, 터키어는 i의 대문자가 İ이다. 이러한 특수한 언어들을 위한 함수들의 특수한 버전이 존재한다.\nstrings.ToUpperSpecial(unicode.TurkishCase, \u0026#34;i\u0026#34;)  ToUpperSpecial : ToUpperSpecial\n 다음으로 타이틀 케이스는 ToTitle() 함수가 있다:\nfunc ToTitle(s []byte) []byte func ToTitle(s string) string  byte : byte, string : string\n 그러나, 여러분이 ToTitle()를 사용하게 되면 놀랄 것이다. 모든 문자열이 대문자가 되어버렸다:\nprintln(strings.ToTitle(\u0026#34;the count of monte cristo\u0026#34;)) // 출력값 : THE COUNT OF MONTE CRISTO  ToTitle : ToTitle\n 왜냐하면 유니코드에서, 타이틀 케이스는 케이싱의 특정한 유형이며 각 단어의 첫번째 문자를 대문자화 시키는 방법이 아니다. 대부분의 경우, 타이틀 케이스와 대문자화는 동일하지만 차이점을 갖는 몇 개의 코드 포인트들이 존재한다. 예를 들면, lj 코드 포인트 (맞다, 이는 하나의 코드 포인트이다)는 대문자화가 되면 LJ가 되지만 타이틀 케이스는 Lj이다.\n여러분이 아마 찾고 있는 것은 Title()이다:\nfunc Title(s []byte) []byte func Title(s string) string  byte : byte, string : string\n 이 함수의 출력값은 예상했던 결과값이다:\nprintln(strings.Title(\u0026#34;the count of monte cristo\u0026#34;)) // 출력값 : The Count Of Monte Cristo  Title : Title\n 룬 매핑하기 바이트 슬라이스 또는 문자열에서 데이터를 교체하기 위한 또 다른 함수는 Map()이다:\nfunc Map(mapping func(r rune) rune, s []byte) []byte func Map(mapping func(r rune) rune, s string) string  rune : rune, byte : byte, string : string\n 이 함수는 모든 룬을 평가하고 이를 교체하는 함수를 전달하도록 한다. 인정하건데, 나는 이 포스트를 쓰기 시작할때까지 이 함수의 존재조차 모르고 있었기에 그 어떤 개인적인 일화도 알려줄 수가 없다.\n분할(Splitting) \u0026amp; 결합(Joining) 함수 여러 번 우리는 서로 분할시킬 필요가 있는 문자열들을 구분하고있다. 예를 들면, 유닉스에서 경로들은 콜론으로 합쳐져 있으며 CSV 파일 포맷은 기본적으로 데이터 필드를 콤마로 구분하고 있다.\n부분 문자열 분할 간단한 부분 슬라이스와 부분 문자열 분할을 위해, 우리는 Split() 함수를 사용한다:\nfunc Split(s, sep []byte) [][]byte func SplitAfter(s, sep []byte) [][]byte func SplitAfterN(s, sep []byte, n int) [][]byte func SplitN(s, sep []byte, n int) [][]byte func Split(s, sep string) []string func SplitAfter(s, sep string) []string func SplitAfterN(s, sep string, n int) []string func SplitN(s, sep string, n int) []string  byte : byte, string : string\n 이렇게 구분자로 바이트 슬라이스와 문자열을 쪼개면 부분 슬라이스들과 문자열들이 반환된다. \u0026ldquo;After\u0026rdquo; 함수는 서브 문자열의 끝에 구분자를 포함한다. \u0026ldquo;N\u0026rdquo; 함수는 발생할 수 있는 분할 횟수를 제한한다:\nstrings.Split(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] strings.SplitAfter(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) // [\u0026#34;a:\u0026#34;, \u0026#34;b:\u0026#34;, \u0026#34;c\u0026#34;] strings.SplitN(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;, 2) // [\u0026#34;a\u0026#34;, \u0026#34;b:c\u0026#34;] 데이터를 분할하는 것은 매우 일반적인 작업이다. 하지만, 이는 보통 CSV와 같은 파일 포맷에서의 컨텍스트나 경로 분할의 컨텍스트에서 수행된다. 이 작업들을 위해, 나는 encoding/csv 또는 path 패키지를 대신 사용한다.\n카테고리성 분할 가끔 구분자로 룬의 열 대신 룬의 집합을 지정하고 싶을 때가 있다. 이 상황의 가장 좋은 예시는 가변적인 공백이 있는 상태에서 단어들을 쪼개는 것이다. 공백 구분 함수로 단순히 Split()을 사용하게되면 연속적인 다중 공백이 있을 경우 빈 부분 문자열도 반환할 것이다. 대신 Fields() 함수를 사용할 수 있다:\nfunc Fields(s []byte) [][]byte  byte : byte\n 이는 연속된 공백 문자들을 하나의 구분자로 여긴다:\nfunc FieldsFunc(s []byte, f func(rune) bool) [][]byte  byte : byte, rune : rune\n 문자열 결합 구분된 데이터를 쪼개는 대신, Join() 함수를 이용해 이를 하나로 합칠 수도 있다:\nfunc Join(s [][]byte, sep []byte) []byte func Join(a []string, sep string) string  byte : byte, string : string\n 개발자들이 join 함수를 직접 구현할 때 내가 봤던 한가지 일반적인 실수가 있는데 이는 다음과 같다:\nvar output string for i, s := range a { output += s if i \u0026lt; len(a) - 1 { output += \u0026#34;,\u0026#34; } } return output 이 코드의 결점은 많은 수의 할당을 생성하고 있다는 것이다. 문자열은 변형 불가능하기 때문에, 각 반복은 각 문자열 추가를 위해 새로운 문자열을 생성하고 있다. 반면에, strings.Join() 함수는 생성시에는 바이트 슬라이스 버퍼를 사용하며 이를 반환할 때 문자열로 변환한다. 이는 힙 메모리 할당을 최소화한다.\n이외 함수들 카테고리를 찾지 못한 두 개의 함수가 있는 이는 여기서 다룬다. 첫째, Repeat() 함수는 반복된 바이트 슬라이스 또는 문자열을 생성할 수 있도록 해준다. 솔직히, 나는 이를 터미널에서 내용을 구분하기 위해 라인을 만들때 사용했던것만 기억난다:\nprintln(strings.Repeat(\u0026#34;-\u0026#34;, 80)) 또 다른 함수는 UTF-8으로 해석된 바이트 슬라이스 또는 문자열에 있는 모든 룬들의 슬라이스를 반환하는 Runes()이다. 나는 이 함수의 필요성을 전혀 느낀적이 없는데 이는 새로운 할당 없이 string 위에서 for loop 를 돌려 같은 일을 할 수 있기 때문이다.\n결론 바이트 슬라이스와 문자열은 Go에서 가장 기본적인 요소이다. 이들은 바이트와 룬의 열을 위한 인메모리 표현이다. 바이트와 문자열 패키지는 io.Reader와 io.Writer 인터페이스의 개조형뿐만 아니라 수 많은 유용한 헬퍼 함수들을 제공한다.\nAPI의 사이즈가 크지 않기 때문에 이 패키지들의 많은 유용한 툴들을 살펴보는일은 쉽지만 나는 이 포스트가 여러분이 이 패키지가 제공해줄 수 있는 모든 것들을 이해하는데 도움이 되었으면 한다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part1/",
	"title": "Golang의 내부, 1부: 주요 컨셉트와 프로젝트 구조",
	"tags": ["Golang", "Internals", "Compiler", "Structure"],
	"description": "",
	"content": "이 블로그 시리즈는 기본적인 Go 언어특성에 이미 익숙하며 좀 더 심도있게 내부구조를 알고자 하는 독자들을 위해 쓰여졌다. 이 포스트는 Go언어의 소스코드의 구조와 Go 컴파일러의 내부를 어느 정도 상세히 살펴보겠다. 이 글을 읽고 난 후, 독자는 다음과 같은 질문에 답을 얻을 것이다.\n Go의 소스코드는 어떤 구조를 가지고 있는가? Go의 컴파일러는 어떻게 동작하는가? Go의 노드 트리(node treee)의 기본 구조는 무엇인가?  시작하며 새로운 프로그래밍 언어를 배우기 시작할 때, 보통은 \u0026ldquo;hello-world\u0026quot;와 같은 튜토리얼이나, 초보자 가이드, 그리고 언어의 주요한 컨셉트, 문법, 심지어 표준 라이브러리에 대한 상세한 정보들 많이 접하게 된다. 하지만, 언어가 런타임 도중에 할당하는 주요한 데이터 구조의 레이아웃이라던지, 내장 함수를 호출할 때 어떤 어셈블리 코드가 발생하는지와 같은 정보를 얻는 것은 쉽지 않다. 물론, 답은 소스코드내에 자리잡고 있지만, 저자의 경험에 비추어 보면, 이렇다 할 성과없이 수많은 시간을 허비하는 일도 가능하다.\n이런 주제에 대해 전문가인 척 하지도 않을 거고, 모든 가능한 측면을 설명하려는 시도 또한 하지 않겠다. 대신, 목표하는 바는 독자들 스스로 Go 소스코드를 어떻게 해독해 나갈 수 있는 지를 보여주는 것이다.\n시작하기 전에, 반드시 필요한 것은 각자의 Go 소스코드 복사본을 갖는 것이다. 소스코드를 다운 받는데 특별할 게 전혀 없다. 다음 명령을 실행해 보자.\n  git clone https://github.com/golang/go\n 메인 브랜치의 코드는 상시 변하는 점을 주목하자. 그래서 저자는 이 블로그에서 release-branch.go1.4 브랜치를 사용한다. # 프로젝트 구조 이해하기 Go 레포의 `/src` 폴더를 보게 되면, 많은 폴더를 발견하게 된다. 대부분은 Go의 표준 라이브러리 소스 파일을 갖고 있다. 여기에도 표준 이름짓기 관행이 항상 적용되는데, 각 패키지는 그 이름에 상응하는 이름의 폴더 아래 있다. 표준 라이브러리외에 다른 것들을 살펴보자. 저자의 견해로는, 아래 폴더들이 가장 중요하고 유용하다. \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt;\u0026lt;!-- .myTable { background-color:white;border-collapse:collapse; } .myTable th { background-color:#E0E0E0;color:black; } .myTable td, .myTable th { padding:5px;border:1px solid #989898; } --\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;table class=\u0026quot;myTable\u0026quot;\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\u0026lt;center\u0026gt;폴더\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;width: 530px;\u0026quot; width=\u0026quot;70%\u0026quot;\u0026gt;\u0026lt;center\u0026gt;설명\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;코멘드 라인 툴들을 보관한다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/go\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/go/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Go 툴의 소스 파일이 있는데, 이 툴들은 Go 소스코드를 다운받거나, 빌드하고, 설치하는데 사용된다. 툴이 실행되면서 전체 소스를 수집하고, Go 링커와 컴파일러 코멘드 라인 툴들을 호출한다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/dist\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/dist/ \u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;다른 코멘트 라인 툴과 표준 라이브러리의 모든 패키지를 빌드하는 툴을 보관한다. 모든 특정한 툴이나 패키지에서 어떤 라이브러리가 사용되었는지를 알아 보려면 이 소스를 분석하고 싶을 것이다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/gc\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/gc/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Go 컴파일러내 (프로세서) 아키텍쳐에 의존하지 않는 부분이다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/ld\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/ld/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Go 링커내 (프로세서) 아키텍쳐에 의존하지 않는 부분이다. 아키텍쳐에 의존적인 부분들은 \u0026quot;l\u0026quot;로 끝나는 이름의 폴더에 위치하며 컴파일러와 같은 이름짓기 관행을 따른다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/5a\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/cmd/5a/\u0026lt;/a\u0026gt;, 6a, 8a, and 9a\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;여러 아키텍쳐에 맞춘 Go 어셈블러 컴파일러들을 발견할 수 있다. Go 어셈블러는 일종의 어셈블리 언어로 하층 기계어와는 딱 맞아 떨어지는 것은 아니다. 대신 각 아키텍쳐마다 독특한 컴파일러들이 있어 Go의 어셈블러를 기계의 어셈블러도 번역한다. 더 자세한 내용은 다음 링크를 참조하라. \u0026lt;a href=\u0026quot;https://golang.org/doc/asm\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;여기\u0026lt;/a\u0026gt;.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/lib9\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/lib9/\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/libbio\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/libbio\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/liblink\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/liblink\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;컴파일러, 링커, 그리고 런타임 패키지에 사용된 각종 라이브러리들.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/tree/release-branch.go1.4/src/runtime\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;/src/runtime/\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;가장 중요한 Go 패키지로 모든 프로그램에 간접적으로 포함된다. 메모리 관리, 가비지 콜렉션, Go 루틴 생산등, 런타임 기능 전체를 포함하고 있다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; # 컴파일러 내부 위에서 언급한 것 처럼, 아키텍쳐에 무관한 Go 컴파일러는 `/src/cmd/gc` 폴더에 위치 한다. 시작 점은 `lex.c` 파일에 있다. 코멘드 라인 인수 파싱 같은 보편적인 기능들을 차치하고 들여다 보면, 컴파일러는 다음과 같은 일들을 한다. 1. 어떤 공통의 데이터 구조를 초기화 한다. 2. 주어진 모든 Go 파일을 차례로 읽어서 각 파일에 yyparse 메서드를 호출한다. 이때 실제로 파싱이 작동한다. Go 컴파일러는 `Bison`을 파서 발생기(parser generator)로 사용한다. 언어의 문법은 [go.y](https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y)에 완전히 서술되어 있다. (자세한 내용은 나중에 더 제공될 예정이다) 결과로, 이 단계는 완전한 파스트리(parse tree)를 생성하는데, 이때 트리의 각 노드는 컴파일된 프로그램의 요소들을 대표한다. 3. 생성된 트리를 재귀적으로(Recursively) 방문하면서 약간의 수정을 가한다, 예를 들어, 암시적으로 타입이 주어진 노드에 타입 정보를 정의하거나, 타입 케스팅과 같은 언어요소들을 런타임 패키지내 어떤 함수을 호출하는 식으로 다시 재구성하기도 한다 그외 다른 일들도 실행한다. 4. 파스트리(parse tree)가 완성되고 난 뒤 실제 컴파일을 실행한다. 노드들은 어셈블리 코드로 번역된다. 5. 생성된 어셈블리 코드에 심볼 테이블과 같은 부수적인 데이터 구조를 함께 오브젝트 파일 (object file)에 담아 만들고 디스크에 저장한다. # Go 문법 들여다 보기 이제 두번째 단계를 좀 더 가까이 살펴보자. [go.y](https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y) 파일은 언어 문법(grammar)을 가지고 있어 Go 컴파일러를 조사하고 언어의 구문론(syntax)을 이해하는 데 좋은 출발점이다. 파일의 주요한 부분은 선언문들로 구성되며, 다음과 유사하다. \u0026gt;``` xfndcl: LFUNC fndcl fnbody fndcl: sym '(' oarg_type_list_ocomma ')' fnres | '(' oarg_type_list_ocomma ')' sym '(' oarg_type_list_ocomma ')' fnres 이 선언에서는, xfndcl 와 fundcl 노드가 정의된다. fundcl 노드는 두가지 형식중에 하나이다. 첫번째는 다음의 언어 구성소(construct)에 상응하는 형식이다:\n  somefunction(x int, y int) int\n 그리고 두번째는 다음의 언어 구성소에 상응한다: \u0026gt;``` (t *SomeType) somefunction(x int, y int) int. xfndcl 노드는 상수인 LFUNC 에 저장된 키워드 func 를 뒤 따르는 fndcl 와 fnbodynodes 로 구성되어 있다.\nBison(혹은 Yacc) 문법의 중요한 기능중에 하나는 무작위의 C 코드를 각 노드 정의옆에 갖다 붙일 수 있다는 것이다. 소스 코드안에 이런 노드의 정의가 매치될 때 마다 C 코드는 실행된다. 여기서, (실행된)결과의 노드는 $$ 사용해 표시하고 $1, $2 등등으로 자식 노드를 나타낸다.\n예제를 통해 보면 다 쉽게 이해할 수 있다. 다음은 실제코드를 간소한 예다.\n  fndcl: sym \u0026lsquo;(\u0026rsquo; oarg_type_list_ocomma \u0026lsquo;)\u0026rsquo; fnres { t = nod(OTFUNC, N, N); t-\u0026gt;list = $3; t-\u0026gt;rlist = $5;\n $$ = nod(ODCLFUNC, N, N); $$-\u0026gt;nname = newname($1); $$-\u0026gt;nname-\u0026gt;ntype = t; declare($$-\u0026gt;nname, PFUNC); }  | \u0026lsquo;(\u0026rsquo; oarg_type_list_ocomma \u0026lsquo;)\u0026rsquo; sym \u0026lsquo;(\u0026rsquo; oarg_type_list_ocomma \u0026lsquo;)\u0026rsquo; fnres\n 우선, 새로운 노드가 만들어 지고 함수 선언을 위한 타입 정보를 갖는다. $3는 인수 리스트로 $5는 결과 리스트로 이 노드에서 레퍼런스된다. 그런 다음, $$ 결과 노드가 만들어 져서, 함수 이름과, 타입 노드를 저장한다. 보다시피 [go.y](https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y)내 정의된 것들과 노드 구조사이에 직접적인 연결이 있을 수 없다. # 노드 이해하기 이제 노드가 실제로 무엇인지 알아 볼 시간이다. 첫번째로, 노드는 struct이고, [여기](https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L245)에 정의되어 있다. 이 struct는 굉장히 많은 특성들을 갖고 있는데 그 이유는 다른 종류의 노드를 지원해야 하고 노드종류마다 다른 속성들을 가지고 있기 때문이다. \u0026lt;table class=\u0026quot;myTable\u0026quot;\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\u0026lt;center\u0026gt;노드 struct 필드\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;width: 530px;\u0026quot; width=\u0026quot;70%\u0026quot;\u0026gt;\u0026lt;center\u0026gt;설명\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L259\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;op\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;이 필드는 각 노드마다 존재하며 노드의 연산이 무엇이지를 나타낸다. 이 필드를 통해 노드의 종류를 분간할 수 있다. 이전 예제에서 본 \u0026lt;em\u0026gt;OTFUNC\u0026lt;/em\u0026gt; (연산 타입 함수) 과 \u0026lt;em\u0026gt;ODCLFUNC\u0026lt;/em\u0026gt; (연산 선언 함수)같은 것 들이다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L295\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;type\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;노드가 타입정보를 보유할 때 (때로 타입이 없는 노드도 있다. 예를 들면, \u0026lt;em\u0026gt;if\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;switch\u0026lt;/em\u0026gt;, 혹은 \u0026lt;em\u0026gt;for\u0026lt;/em\u0026gt;와 같은 제어 흐름문들), 이 필드는 타입정보를 가지고 있는 또 다른 struct를 가리키는 레퍼런스이다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L309\u0026quot; target=\u0026quot;golangsrc\u0026quot;\u0026gt;val\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;이 필드는 리터럴 노드의 실제 값을 갖는다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 독자는 이제 노드 트리의 기본적 구조를 이해했으므로, 그 지식을 실전에 투여할 수 있다. 다음 포스트에서는, Go 컴파일러가 과연 무엇을 생산하는지를 간단한 Go 애플리케이션을 통해 살펴보겠다. * 원문: [Golang Internals, Part 1: Main Concepts and Project Structure](http://blog.altoros.com/golang-part-1-main-concepts-and-project-structure.html) * 저자: Siarhei Matsiukevich * 번역자: Jhonghee Park "
},
{
	"uri": "https://devbj.com/golangkorea/go-start/getting-start/",
	"title": "Go언어 시작하기",
	"tags": ["beginning", "install"],
	"description": "",
	"content": "Go 언어에 대해서 구글이 2009년에 만든 비교적 새로운 프로그래밍 언어다. 2009년이면 거의 7년 이상된 구닥다리 언어잖아? 라고 생각 할 수 있겠으나, Ruby(1996년) 나 python(1991년) 과 비교해보면 느낌이 다를 것이다. V8 자바스크립트 엔진 개발에 참여했던 Robert Griesemer, UTF-8을 만든 Rob Pike, 초창기 유닉스 운영체제를 설계했으며 B언어(C언어의 전신)를 개발한 Ken Thompson등 쟁쟁한 개발자들이 만든 언어다. 구글이 개발 했다는 프리미엄과 함께 **도커(Docker)**의 개발 언어라는게 알려지면서 유명세를 타게 됐다.\nPython이나 Java와 같은 범용 프로그래밍 언어이며, 시스템 프로그래밍과 네트워크 프로그램의 개발을 목표로 만들어진 언어다. 비교적 최근에 만들어진 언어답게 C++, Java, Python 언어들의 장점을 상당 부분 수용했다. 이렇게 보면 최신 프로그래밍 언어들의 트랜드를 따를 것 같지만 코드는 C 언어와 매우 비슷한 느낌을 준다.\nC 언어 처럼 컴파일이 되며, 컴파일 시간에 타입을 체크하는 정적 타입 언어다. 그리고 C 언어처럼 단순하다. 약 25개 정도의 키워드만이 제공되는데, 실제 코드를 만들다 보면 10개 내외의 키워드 만으로 프로그래밍이 가능하다. 아래 go 언어가 제공하는 키워드들이다.\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 프로그래밍 언어에 대한 경험이 있다면 chan, defer, fallthrough 등을 제외한 키워드들의 이름과 용도를 미루어 짐작할 수 있을 것이다.\n키워드가 적은 만큼 복잡한 준비작업 없이 쉽게 시작 할 수 있으며, 몇 개의 키워드로 반복 사용 함으로써 프로그래밍 숙련도를 빠르게 높일 수 있다는 것도 큰 장점이다.\nGo 언어는 **동시성(concurrency)**를 잘 지원하는 것으로 유명하다. Go는 **고루틴(goroutine)**라는 경량스레드(lightweight thread)를 제공하는데, 고루틴간 메시지를 주고 받을 수 있는 채널(channel)을 이용하면, 아주 쉽게(정말 쉽다) 동시성 프로그램을 개발 할 수 있다. 고루틴은 얼랑(Erlang)의 경량 쓰레드와 매우 유사한데, 2k 정도로 그 크기가 매우 작다. 많은 수의 고루틴을 시스템 부담을 최소화 하면서 만들 수 있다.\nGo 언어를 사용하다보면, 웹 애플리케이션을 만들기가 매우 편하다는 느낌을 받게 된다. 특히 **MSA(Microservice Architecture)**와 REST(Representational State Transfer) 모델의 애플리케이션을 쉽게 만들 수 있다. 루비나 파이선 같은 언어의 경우 다양한 웹 프레임워크중에서 선택을 고민하게 마련인데, Go 언어는 기본으로 제공하는 net/http 패키지로 충분하다. 물론 Go 언어도 다양한 마이크로 프레임워크와 풀 프레임워크를 제공하긴 하지만 이런 프레임워크를 쓰면, \u0026ldquo;왜 프레임워크를 쓰세요 ? 그냥 기본(net/http) 패키지 쓰세요\u0026quot;라는 말을 들을 정도로 강력하다.\n대규모의 분산 시스템을 유지해야 하는 구글의 요구를 위해서 웹 개발 관련 패키지가 강력해진 것 같다.\nGo 시작하기 Go 설치 golang.org에서 운영체제별로 Go 언어를 다운로드 할 수 있다. 2016년 8월 현재 최신 버전은 1.7이다. 압축을 푼 다음 /usr/local 디렉토리로 복사했다.\n# wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz # tar -xvzf go1.7.linux-amd64.tar.gz # mv go /usr/local go 실행을 위해서 환경 변수를 설정했다.\n# export PATH=$PATH:/usr/local/go/bin # echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin go를 실행해보자.\n# go version go version go1.7 linux/amd64 이제 작업 디렉토리 \u0026lsquo;\u0026lsquo;\u0026lsquo;workspace'\u0026lsquo;\u0026lsquo;를 만들었다. Go언어에게 작업 디렉토리를 알려주기 위해서 환경변수 GOPATH도 설정했다.\n# mkdir $HOME/workspace # export GOPATH:$HOME/workspace 이들 환경변수들은 .bashrc 등에 설정해서, 로그인 시간에 적용되도록 하자.\n이것으로 go 언어 개발 환경을 마쳤다. 이제 Hello World 프로그램을 만들면서 Go 프로그램의 기본적인 특징들을 살펴보자.\n패키지 관리 시스템 Hello World 프로그램을 만들기 전에 Go 언어의 패키지 관리 시스템을 살펴봐야 할 것같다. 앞서 나는 workspace 라는 작업 디렉토리를 만들었다. 다른 프로그램이라면 workspace 디렉토리 밑에 프로젝트 파일을 만드는 것으로 개발을 시작할 것이다. 예컨데 mkdir workspace/helloworld 로 디렉토리를 먼저 만들 것이다.\ngo 언어는 다르다. 우선 go 언어는 인터넷을 기본 개발 환경으로 한다. Go로 원할히 개발하기 위해서는 컴퓨터가 인터넷에 연결되어 있어야 하며, 코드를 저장하고 읽기 위한 github, bitbucket 혹은 직접 구성한 git 서버가 있어야 한다. 즉 go 언어에서 패키지는 프로젝트 저장소 단위로 관리한다.\n예를 들어 sqlite3을 사용하는 애플리케이션을 개발한다고 가정해 보자. 이를 위해서 sqlite3 패키지를 go get으로 다운로드 해야 하는데 git 주소로 부터 다운로드 한다.\ngo get github.com/mattn/go-sqlite3 거의 모든 패키지가 이처럼 인터넷 상에 있는 git으로 관리 되고 있다. sqlite3 패키지를 설치한 후 workspace를 살펴보자.\n. ├── pkg │ └── linux_amd64 │ └── github.com │ └── mattn │ └── go-sqlite3.a ├── src | └── github.com | └── mattn | └── go-sqlite3 | ├── backup.go | ├── backup_test.go | ├── callback.go | ├── callback_test.go └── bin 패키지의 경로가 github 경로인 것을 확인 할 수 있다. 물론 인터넷에 연결하지 않고도 프로젝트를 수행 할 수는 있지만 제대로 go 프로그래밍을 하려면 인터넷과 github 계정이 필요하다. 아래 주요 디렉토리의 용도를 정리했다.\n src : 패키지의 소스코드가 위치한다. pkg : 패키지의 소스코드를 빌드해서 만들어진 라이브러리 파일(.a - ar archive 파일)이 위치한다. go-sqlite3.a 파일이 보일 것이다. bin : 패키지가 main 함수를 포함할 경우 실행 파일이 만들어 지는데, 이들 실행파일이 복사된다. go-sqlite3는 실행파일이 없으므로 bin에 파일이 복사되지 않는다.  아래에서 다룰 Hello World 프로젝트도 github 기반으로 진행 할 것이다. github 계정이 없다면 지금 계정을 만들자. 내가 사용하고 있는 github 계정은 yundream 이다.\nHello World를 만들어보자. Hello World 프로젝트를 시작하기 위해서 내가 사용하는 github 계정에 helloworld 프로젝트를 만들었다. 프로젝트를 만들 때 Initialize this repository with a README 옵션을 체크하자. 이제 go get 명령을 이용해서 패키지를 다운로드 한다.\n$ go get github.com/yundream/helloworld package github.com/yundream/helloworld: no buildable Go source files in /home/yundream/golang/src/github.com/yundream/helloworld 지금은 README.md 파일만 있으므로 빌드 할 수 있는 go 파일이 없다는 경고메시지뜰 것이다. 무시하자. GOPATH 환경에 등록된 /home/yundream/golang 디렉토리 밑에 패키지를 다운로드(README.md) 해서 설치하는 것을 확인 할 수 있을 것이다. 디렉토리로 이동해서 helloworld.go 파일을 만들어보자.\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } 터미널에 \u0026ldquo;Hello World\u0026quot;를 출력하는 간단한 프로그램이다. go run 명령으로 실행해보자.\n$ go run main.go Hello World go run은 임시디렉토리에서 코드를 컴파일 하고 실행하는 일을 한다. go가 컴파일 언어임에도 불구하고 (컴파일 시간이 매우빠르다)유저 입장에서는 인터프리터 언어처럼 사용 할 수 있다. python 같은 언어에 비해서는 즉시성이 떨어지기는 하지만 왠만한 프로젝트에서는 굳이 컴파일 과정을 거치지 않고도 바로 바로 실행 할 수 있다.\ngo build 명령으로 소스코드를 컴파일 할 수 있다.\n$ go build $ ls README.md helloworld main.go $ ./helloworld Hello World 이제 소스코드를 살펴보자. C 언어와 매우 비슷하다는 느낌을 받을 것이다.\npackage main 패키지를 선언한다. 모든 go 언어는 패키지 선언으로 시작해야 한다. 이 패키지이름을 이용해서 코드를 조직화하고 재사용 할 수 있다. C언어와 유사하게 go 언어도 실행 프로그램과 라이브러리, 두 개의 코드 타입을 가지고 있다. 실행 프로그램이란 쉘 에서 명령을 내려서 직접 실행 할 수 있는 (우리가 일반적으로 알고 있는)프로그램이고, 라이브러리는 다른 프로그램에서 이용 할 수 있게 패키징된 코드의 모음이다. 실행 프로그램을 만들기 위한 go 코드는 반드시 package main을 선언해야 한다.\nimport ( \u0026#34;fmt\u0026#34; ) 외부 패키지를 import 하기 위해서 사용한다. java의 import와 매우 유사하다. 위에서 go 코드는 실행 프로그램과 라이브러리 타입이 있다고 했던 것을 기억할 것이다. import는 라이브러리 타입의 go 코드를 재사용 하기 위해서 사용한다. 여기에서는 화면과 파일 출력에 관련된 여러 유용한 기능을 담고 있는 fmt 패키지를 import했다. fmt는 git 저장소 경로가 없는데, go에서 제공하는 기본 패키지라고 보면 된다.\nfunc main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } go 언어의 기본 구성요소는 함수이며, func 키워드로 정의해서 사용 할 수 있다. 이 함수의 이름은 main 이며, 0개의 매개변수(parameter)과 0개의 반환 값을 가지고 있다. main은 프로그램의 시작 점이 되는 특수한 함수다. 실행 가능한 타입의 go 코드는 반드시 하나의 main 함수를 가지고 있어야 한다.\nfmt.Println(\u0026#34;Hello World\u0026#34;) fmt는 패키지 이름으로 해석하자면 fmt 패키지가 가지고 있는 Println 함수를 사용해서 \u0026ldquo;Hello World\u0026quot;를 출력하라는 의미가 된다.\n빌드 성공까지 끝냈다면 main.go를 github 저장소에 push하자. 그리고 go get 으로 다시 패키지를 다운로드 해보자. go get으로 패키지를 설치 하면 소스코드들은 $GOPATH/src 밑에 설치된다. 만약 패키지가 실행 가능한 코드 즉 main 함수를 포함하고 있다면 빌드를 수행하고 그 결과를 $GOPATH:/bin 에 복사한다.\n# $GOPATH/bin/helloworld Hello World go 프로젝트를 진행하다 보면, go get을 이용해서 go 기반의 소프트웨어들을 설치하게 될 것이다. 이들은 $GOPATH/bin에 설치가 되니, 실행을 위해서 환경변수 PATH에 $GOPATH/bin 도 추가하자.\n만약 패키지를 지우고 싶다면 $GOPATH/src로 이동해서 패키지 디렉토리를(이 경우 $GOPATH/src/github.com/yundream/helloworld) 지워주기만 하면 된다.\n첫 번째 패키지 개발 이제 라이브러리 타입의 패키지를 만들어 보자. 패키지의 이름은 stringutil로 문자열 조작과 관련된 함수들을 만들 것이다.\npackage stringutil func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i \u0026lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) } Reverse 함수 하나만을 포함하고 있다. 매개변수로 받은 문자를 뒤집어서 반환하는 일을 한다.\ngithub 계정에 stringutil 저장소를 만들고 stringutil.go 파일을 push 한후, go get 으로 패키지를 다운로드하자.\n# go get github.com/yundream/stringutil go get으로 설치된 패키지를 확인해보자.\n# go list ... | grep yundream github.com/yundream/helloworld github.com/yundream/stringutil stringutil는 라이브러리 타입의 패키지로 빌드한 결과는 pkg/ 디렉토리 밑에 .a 파일로 저장된다.\n# file $GOPATH/pkg/linux_amd64/github.com/yundream/stringutil.a /home/yundream/golang/pkg/linux_amd64/github.com/yundream/stringutil.a: current ar archive 이제 helloworld 패키지에서 stringutil 패키지를 임포트해서 함수를 사용 할 수 있다.\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/yundream/stringutil\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello World !!\u0026#34;) val := stringutil.Reverse(\u0026#34;ABCDEF\u0026#34;) fmt.Println(val) } 실행해 보면 stringutil.Reverse 함수가 작동하는 걸 확인할 수 있다.\n# go run main.go Hello World !! FEDCBA One 파일 배포 Go 언어에서 라이브러리 타입의 패키지들은 .a(정적 라이브러리) 형태로 만들어진다. **공유 라이브러리(Shared Library - 리눅스는 .so파일 윈도우즈는 dll)**를 지원하기는 하지만 운영체제에 따라 제한 적일 수 있다. 보통은 정적 라이브러리를 코드내에 포함해서 하나의 실행 파일로 배포하는 방법을 사용한다.\n이 방법은 패키징이 단순해지며, 운영체제의 동적 라이브러리와의 호환문제에서 자유롭기 때문에 배포가 쉬워진다는 장점이 있다. 대신 라이브러리 코드가 포함되므로 코드가 더 커지고, 취약점이 있는 라이브러리에 대한 체크와 업데이트가 쉽지 않다는 문제가 있다. 특정 라이브러리에서 어떤 취약점이 발견됐다면, 해당 라이브러리를 포함한 모든 애플리케이션을 재 빌드 해야 한다.\n현대적인 애플리케이션들이 공유 라이브러리를 선호한다는 점에서 시대에 역행한다는 생각을 가질 수 있을 것이다. 이러한 방식을 선택한 이유를 생각해봐야 한다. 구글은 프라이빗한 클라우드 환경에서 작동하는 시스템 애플리케이션의 개발을 위해서 go 언어를 사용하고 있다. 다양한 운영체제와 운영 환경등을 가지고 있는 클라우드 환경에 애플리케이션을 배포하기 위해서는 외부 의존성을 없애고 빠르게 배포하는게 더 나을 것 이다. 프라이빗한 네트워크에서 실행되며, 직접 서비스에 관여하는 일도 없을 테니 취약점에 대한 대응 문제도 그리 심각하지 않을 것이다.\n클라우드와 같은 분산된 환경에서는 go 언어의 방식이 더 나을 수 있다.\n마치며 테스트에 사용한 코드들은 아래 github에서 찾을 수 있다.\n https://github.com/yundream/helloworld https://github.com/yundream/stringutil  # go get github.com/yundream/helloworld # go get github.com/yundream/stringutil "
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/getting-started/",
	"title": "시리즈 #1 - Hugo 시작하기",
	"tags": ["Blog", "Hugo"],
	"description": "",
	"content": "Hugo 시작하기 Hugo는 Go로 제작되고 하나의 실행파일로 배포됩니다. 다양한 설치 방법이 있지만 우선 Package Manager를 쓰시는 분들을 중심으로 살펴보겠습니다.\nPackage Manager로 설치하기 MacOS를 쓰시는 분들은 Homebrew를 이용해 쉽게 설치하실 수 있습니다.\nbrew update \u0026amp;\u0026amp; brew install hugo Windows에서 Chocolatey를 쓰시는 분들도 비슷한 방법으로 설치가 가능합니다.\nC:\\\u0026gt; choco install hugo Linux에서는 조금 복잡해 집니다. 우분트를 쓰시는 분들은 우선 Hugo 릴리즈 페이지로 가서 최신 deb 버전을 다운로드한 후에 다음 명령을 실행 시키면 됩니다.\nsudo dpkg -i hugo*.deb 소스로 직접 빌드해 쓰는 방법 이미 Go로 개발 환경을 갖추고 계신 분들은 직접 소스를 빌드해 쓰시는 방법이 가장 편합니다. 간단히 go get툴을 이용해 설치하실 수 있습니다.\ngo get -v github.com/spf13/hugo Hugo가 설치되었는지를 version 보조 명령어를 사용해 확인하십시요.\n$ hugo version Hugo Static Site Generator v0.17-DEV BuildDate: 2016-08-21T19:44:40-04:00 프로젝트 폴더 만들기 정적 사이트 제너레이터를 처음 접하시는 분들을 위해 Hugo를 간단하게 설명하자면, Hugo는 소스 폴더 아래 존재하는 파일과 컨텐츠 템플릿을 입력으로 사용해서 웹사이트 전체를 출력하는 시스템입니다. 보통 소스는 Markdown을 이용한 컨텐츠이거나 템플릿 언어로 작성된 HTML에 자바스크립과 CSS스타일로 구성되어 웹 개발자에게 매우 친숙한 환경이라 할 수 있습니다.\n+------------------+ | Content +--------+ | (Markdown) | | +------------------+ | +------------+ +------------------+ +--v---+ |Full Website| |Template | | | +-------+----+ |(text/template) | | Hugo | | | | |(Ace) +-----\u0026gt; +-------\u0026gt; | | |(Amber) | | | | | | +------------------+ +--^--^+ | | | +------------------+ | | | | | |Configuraton | | | +-------+----+ |(toml, yaml, json)+--------+ | +------------------+ | +------------------+ | | Static | | | (image) | | | (javascript) +-----------+ | (css) | +------------------+ Hugo는 커맨드라인 명령어 체계는 각종 보조 명령어와 POSIX를 준수하는 플래그로 구성되어 빌드와 유틸리티 기능을 제공합니다. 우선 Hugo가 제공하는 Scaffolding 명령어를 가지고 프로젝트 폴더를 만들어 보도록 합니다.\n$ hugo new site golangkorea-hugo Hugo의 모든 명령1은 hugo로 시작하고 보조 명령어가 뒤를 따릅니다. 여기서 new는 보조 명령어로서 site 보조 명령어와 함께 프로젝트를 초기화합니다. 초기화된 프로젝트의 폴더 구조는 다음과 같습니다.\n$ cd golangkorea-hugo $ tree -a . ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 6 directories, 1 file 초기화된 프로젝트에는 텅빈 폴더 6개와 config.toml 파일 하나가 만들어 집니다. 각 폴더의 용도를 간단히 나열하면 다음과 같습니다.\n archetypes: hugo new명령으로 컨텐트 생성시 Front Matter2에 컨텐트 타입에 따른 기본 값들을 어떻게 정해줄 것인가를 결정하는 파일들을 저장합니다. content: 컨텐츠가 저장됩니다. data: 템플랫으로 불러쓸 수 있는 데이터 파일을 저장하는 공간입니다. 데이터의 타입은 toml, yaml, 과 json이 지원됩니다. layouts: 테마를 커스터마이징할 때 기존의 테마내 탬플릿의 내용을 수정하거나 덧씌우기를 하는 템플릿을 저장하는 공간입니다. static: 이미지, 자바스크립, CSS등을 저장하는 공간 themes: 사이트의 테마를 저장하는 공간.  config.toml의 내용을 보면 다음과 같습니다.\nbaseurl = \u0026quot;http://replace-this-with-your-hugo-site.com/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot; baseurl은 말 그대로 사이트내 모든 리소스의 URL의 베이스를 형성합니다. 예를 들어 content/post/my-first-blog.md라는 컨텐트가 있으면 Full URL은 http://replace-this-with-your-hugo-site.com/post/my-first-blog이 됩니다.\n첫번째 컨텐트 만들기 그럼, 다음 Scaffolding 명령을 써서 첫번째 블로그 포스트를 만들어 보도록 합니다.\n$ hugo new post/my-first-blog.md content/post/my-first-blog.md가 만들어 지면 아래와 같이 편집을 하고 저장하십시요.\n+++ date = \u0026quot;2016-08-24T21:51:10-04:00\u0026quot; draft = true title = \u0026quot;my first blog\u0026quot; +++ # Hello, Hugo! \u0026lt;- 편집 부분 hugo server명령을 써서 Hugo가 제공하는 웹서버를 구동한 다음 http://localhost:1313을 브라우저로 열어 보십시요. 텅빈 페이지로 나타날 겁니다. 왜 그럴까요? 답 부터 말씀드리면 Hugo의 입장에서는 무엇으로 페이지를 렌더링할 지 아무런 정보가 없는 경우인 것입니다. layouts 폴더안에 index.html이라는 파일을 만들고 다음과 같이 편집해 저장하신 다음 다시 http://localhost:1313을 열어 보십시요.\n\u0026lt;h1\u0026gt;Hello, Hugo!\u0026lt;/h1\u0026gt; **Hello, Hugo!**라고 크게 나타나는 것을 보게 될 것입니다.\n이제 http://localhost:1313/post/my-first-blog를 열어 보십시요. 심지어 404 page not found라고 나옵니다. 텅빈 페이지가 아니고 왜 404일까요? 이유는 포스트의 Front Matter에 draft = true라고 명시되어 있어서 Hugo의 입장에서는 렌더링을 할 이유가 없는 것이죠. Ctrl-C로 Hugo 웹서버를 중단시킨 다음 hugo server -D=true명령을 써서 다시 웹서버를 가동시키시고 http://localhost:1313/post/my-first-blog를 열어 보십시요. 이번에는 404가 아니고 텅빈 페이지가 보일 겁니다. Hugo를 의인화해서 다시 설명을 드리면, -D=true 플래그를 보고 드래프트 포스트도 렌더링을 해야 하는데 어떻게 해야 할 지 몰라 백지를 낸 상황인 겁니다. 이건 어떻게 고쳐야 할까요?\nlayouts/post/single.html라는 파일을 만드시고 다음의 내용을 저장하신 다음, http://localhost:1313/post/my-first-blog을 열어 보세요.\n\u0026lt;p\u0026gt;Before content\u0026lt;/p\u0026gt; {{ .Content }} \u0026lt;p\u0026gt;After content\u0026lt;/p\u0026gt; 첫번째 포스트가 이제 보이십니까?\n이렇게 힘들게 만들어야 하나? 이런 질문이 당연히 생기실 겁니다. 사이트의 구조와 컨텐츠의 템플릿을 하나씩 만들어 나가야 한다면 사이트 발생기라고 부를 이유가 없겠죠. 누군가 그런 힘든 노동을 통해 layouts의 구조와 템플랫을 모두 작성했다면 공유할 수 있는 메카니즘이 필요합니다. 그런 공유의 매카니즘을 테마(theme)이라고 부릅니다.\n이제 layouts/index.html과 layouts/post/single.html을 제거하시고 테마를 사용하는 방법을 배워 봅시다. 다음과 같이 hugo-octopress 테마를 설치하십시요.\n$ rm layouts/index.html $ rm layouts/post/single.html $ cd themes $ git clone https://github.com/parsiya/Hugo-Octopress.git $ cd .. 테마가 설치된 후에는 Hugo의 웹서버를 다음과 같이 시작해 보십시요.\n$ hugo server -D=true -t=hugo-octopress Hugo로 만든 당신의 첫번째 포스트가 보일 겁니다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/go-start/",
	"title": "Go 시작하기",
	"tags": ["beginning"],
	"description": "",
	"content": "Go 시작하기\n페이지 리스트  Go언어 시작하기  Go 언어에 대해서 구글이 2009년에 만든 비교적 새로운 프로그래밍 언어다. 2009년이면 거의 7년 이상된 구닥다리 언어잖아? 라고 생각 할 수 있겠으나, Rub\n Go의 주요 특징들  단순함 Go 언어는 단순함(simplicity)과 실용성(pragmatism)을 지향하는 언어로 이 두가지 철학이 다른 모든 것들 보다 상위에 있다. go 언어\n Go와 객체지향  객체지향 프로그래밍 Go는 클래스(Class)가 없다!! Struct가 Class의 역할을 수행 할 수 있기는 하지만 메서드도 구조체로부터 분리되는 구성을\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/mytips/",
	"title": "사용팁",
	"tags": [],
	"description": "실제 적용할 때 필요한 팁 정리",
	"content": " 그냥 쓰다보면 꼭 그대로 잘 안되고 걸린다. 필요한 내용을 정리해 두자.\n 🥢 Hugo 활용시 팁 정리 _index.md 파일은  .Kind 는 .section 으로 선택되고, 레이아웃은 list.html 이 선택되어 변환된다.  테마 수정이 필요하면  직접 테마를 복사해서 수정하지 말고, Hugo 디렉토리 밑에 layouts 라는 디렉토리에 복사해서 수정하면 된다.  여기에 동일한 파일이 있으면, 테마의 파일보다 우선해서 사용하게 되어 있다. 자세한 내용은 \u0026ldquo;Hugo 테마 깔끔하게 사용하기\u0026rdquo; 글 참고    "
},
{
	"uri": "https://devbj.com/golangkorea/go-walkthrough/encoding-json-package/",
	"title": "Go 둘러보기 - encoding/json 패키지",
	"tags": ["Golang", "Encoding"],
	"description": "",
	"content": " Go Walkthrough 시리즈의 Go Walkthrough: encoding/json package를 번역한 글입니다.\n 좋든 나쁘든, JSON은 인터넷의 인코딩이다. 이것의 공식적인 정의는 냅킨 뒷면에 쓸 수 있을 정도로 간단하지만 이는 문자열, 숫자, 부울, 널(nulls), 맵(maps) 그리고 배열을 인코딩 할 수 있다. 이러한 간결함 덕에, 모든 언어는 JSON 파서를 가지고 있다.\nGo에서의 구현체는 encoding/json이라고 하는 패키지이며 이는 Go 객체에 대한 JSON 인코딩을 원활하게 추가할 수 있도록 해준다. 그러나, 광범위하게 리플렉션을 사용함으로써, encoding/json 은 가장 많이 사용되는 패키지중 하나임에도 불구하고 이해하기 어려운 패키지중 하나이다. 우리는 이 패키지가 어떻게 동작하는지에 대해 자세히 살펴볼 볼 것이다. 패키지의 사용법뿐만 아니라 내부 함수들이 어떻게 동작하는지도 살펴볼 것이다.\n이 포스트는 표준 라이브러리를 이해하는데 도움을 주기위한 Go 둘러보기 시리즈의 일부이다. 기존에 생성된 문서(자동으로 생성된 Go 문서)는 많은 정보를 제공하지만, 이는 패키지를 실제 상황에서 이해하기에는 어려울 수 있다. 이 시리즈는 일상적으로 사용되는 애플리케이션에서 표준 패키지들이 어떻게 사용되는지에 대한 컨텍스트를 제공할 수 있도록 도와준다. 질문이나 코멘트가 있다면 트위터에서 @benbjohnson로 찾아오면 된다.\nJSON이란 무엇인가? JSON은 JavaScript Object Notation 의 약자로 객체 리터럴을 정의하는 자바스크립트의 하위 집합이다. 자바스크립트는 정적 선언 타이핑이 없기 때문에 언어 리터럴은 암시적 타입을 가져야 한다. 문자열은 쌍 따옴표로 감싸고, 배열은 괄호로 감싸며, 맵은 중괄호로 감싼다.\n{\u0026#34;name\u0026#34;: \u0026#34;mary\u0026#34;, \u0026#34;friends\u0026#34;: [\u0026#34;stu\u0026#34;, \u0026#34;becky\u0026#34;], age: 30} 이 느슨한 타입 정보들은 자바스크립트 개발자들에겐 저주지만, 이는 데이터를 매우 쉽고 간결하게 표현하는 방법을 제공한다.\nJSON 사용의 트레이드 오프 JSON은 사용하기는 쉽지만, 몇가지 문제가 발생할 수 있다. 사람이 쉽게 읽을 수 있는 포맷들은 일반적으로 컴퓨터가 파싱하기에는 느리다. 예를 들면, 내 맥북 프로에서 encoding/json 를 벤치마킹하면 인코딩과 디코딩 속도가 각각 100 MB/sec과 27 MB/sec가 나온다.\n$ go test -bench=. encoding/json BenchmarkCodeEncoder-4 106.26 MB/s BenchmarkCodeDecoder-4 27.76 MB/s 그러나 일반적으로 바이너리 디코더는 데이터를 몇 배 더 빠르게 파싱할 수 있다. 이 문제는 데이터를 읽는 방식 때문에 발생한다. \u0026ldquo;123.45\u0026quot;와 같은 JSON 숫자 리터럴은 두 가지 반복적인 단계로 디코딩 되어야한다.\n 각 바이트를 읽어 숫자인지 닷(dot, .)인지를 검사한다. 만약 숫자가 아닌 데이터를 읽으면 숫자 리터럴 스캐닝을 멈춘다. 10진수 숫자 리터럴을 int64 나 IEEE-754 부동 소수점 숫자 표현식과 같은 2진수 포맷으로 변환한다.  이는 들어오는 모든 바이트에 대한 많은 파싱들뿐만 아니라 디코더상의 미리보기 버퍼를 포함한다. 이와는 대조적으로, 바이너리 디코더는 단순히 얼마나 많은 바이트를 파싱해야 하는지(예를 들어 2,4, 또는 8)와 플립할 수 있는 엔디안만 알면된다. 이 바이너리 파싱 연산은 또한 CPU 파이프라이닝(pipelining)을 늦추는 분기(branching)가 필요하지 않다.\n언제 JSON을 사용해야 하는가? 일반적으로 JSON은 손쉬운 데이터 교환이 가장 큰 목적이고 성능이 크게 중요하지 않을 경우 사용된다. JSON은 사람이 읽기 쉽기 때문에, 뭔가 잘못될 경우 디버깅 하기가 쉽다. 반면에, 바이너리 프로토콜은 분석되기 전에 우선 디코딩 되어야한다.\n많은 애플리케이션에서 인코딩/디코딩 성능은 쉽게 수평 확장이 가능하기 때문에 낮은 우선순위를 가진다. 예를 들어, API 엔드포인트를 제공하기 위해 추가적인 서버를 증설하는건 쉽다. 왜냐하면 인코딩은 서로 다른 서버들간의 조정 등이 필요없기 때문이다. 그러나 데이터베이스는 서버를 추가해야할 때 스케일링 하기가 쉽지 않다.\n스트림 인코딩 json 패키지에는 값을 JSON으로 인코딩하는 두 가지 방법이 있다. 첫번째는 값을 io.Writer로 인코딩하는 스트림 기반 json.Encoder이다:\ntype Encoder struct {} func NewEncoder(w io.Writer) *Encoder func (enc *Encoder) Encode(v interface{}) error  io : io, Writer : Writer, Encode : Encoder, error : error\n 두번째 옵션은 인코딩된 값을 인메모리 바이트 슬라이스로 반환하는 json.Marshal()이다:\nfunc Marshal(v interface{}) ([]byte, error)  byte : byte, error: error\n 이 인코더들에 값을 전달하면, JSON 라이브러리는 타입 정의 검사, 인코더 컴파일 그리고 데이터값 재귀 처리의 복잡한 프로세스를 실행한다. 이제 각각에 대해 자세히 알아보자.\n타입 검사 인코더에 값을 전달하면 가장 먼저 값의 타입 인코더를 검색한다. 타입들은 Go의 reflect 패키지에 의해 검사되며 json 패키지는 이 reflect.Type 값들에 대한 내부 매핑을 가지고 있다. json 패키지에는 int, string, map, struct 그리고 slice와 같은 내장 타입들에 대한 하드코딩된 구현체들이 있다. 이들은 정말 단순하다 - stringEncoder 는 문자열값을 쌍 따옴표로 감싸며 필요한 경우 문자들을 이스케이프하고, intEncoder 는 정수를 문자열 포맷으로 변환하고, 등등.\n인코더 컴파일 내장 타입이 아닌 타입들에 대해선, 인코더가 즉시 생성되고 재사용을 위해 캐싱된다. 우선, 인코더는 해당 타입이 json.Marshaler를 구현하고 있는지 확인한다:\ntype Marshaler interface { MarshalJSON() ([]byte, error) }  byte : byte, error: error\n 만약 구현하고 있다면 마샬링은 타입에 따라 결정된다. 이는 타입중 하나가 json 패키지의 리플렉션 기반 인코더로 처리할 수 없는 특별한 JSON 표현식을 가진 경우 매우 유용하다.\n다음으로, 인코더는 타입이 encoding.TextMarshaler을 구현하고 있는지 확인한다:\ntype TextMarshaler interface { MarshalText() (text []byte, err error) }  byte : byte, error: error\n 만약 구현하고 있다면 이는 해당 함수로부터 값을 생성하고 결과값을 JSON 문자열로 인코딩 할 것이다. 이는 time.Time을 사용할 때 항상 볼 수 있다. 왜냐하면 time.Time은 MarshalText() 메서드를 가지고 있기 때문이며, JSON 인코더는 time.Time 값을 RFC 3339 포맷 문자열로 인코딩 할 것이다.\n마지막으로, 두 인터페이스 모두 구현되어 있지 않을 경우엔 기본 인코더를 기반으로 재귀적으로 인코더를 생성한다. 예를 들어, int 필드와 string 필드를 가지는 struct 로 이루어진 타입은 intEncoder 와 stringEncoder 를 갖는 structEncoder 를 생성할 것이다. 다시 말하지만, 인코더 생성은 딱 한 번만 이루어지며 만들어진 인코더는 차후의 사용을 위해 캐싱될 것이다.\n필드별 옵션 구조체 인코더에 대한 한가지 중요한 점은 이는 인코딩을 위한 필드별 옵션을 결정하기 위해 필드 태그를 읽는다는 것이다. 태그는 구조체의 끝에서 가끔 볼 수 있는 역 따옴표(`)로 감싸진 문자열이다.\n예시:\ntype User struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age,omitempty\u0026#34;` Zipcode int `json:\u0026#34;zipcode,string\u0026#34;` } 이 옵션은 다음을 포함한다:\n 필드 키 이름을 바꾼다. 많은 JSON 키는 카멜케이스이므로 이에 일치하도록 이름을 바꾸는것은 중요할 수 있다. omitempty 플래그는 빈 값을 갖는 비구조체 필드들을 하도록 설정할 수 있다. string 플래그는 필드가 문자열로 인코딩 되도록 강제하는데 사용될 수 있다. 예를 들면, 정수가 문자열로 인코딩 되도록 강제할 수 있다.  재귀 처리 마지막으로, 인코딩이 수행될 때 이는 encodeState 라고 하는 내장 버퍼에 기록된다. 이 객체는 값이 필요로하는 각 인코더로 전달되어 인코더가 바이트를 추가할 수 있도록 한다. json.Marshal이 호출되면, 이 버퍼의 바이트에 대한 참조가 반환된다.\njson.Encoder를 사용할 때, encodeState 버퍼를 재사용하기 위해 내부적으로 sync.Pool가 사용된다. 이는 인코더가 필요로 하는 힙 메모리 할당 횟수를 최소화하므로 스트림 처리는 항상 json.Encoder를 사용한다.\n스트림 디코딩 JSON으로 인코딩된 바이트를 다시 객체로 변환하는 것은 인코딩 프로세스의 역과 비슷하지만 중요한 차이점이 있다.\n바이트에서 JSON을 디코딩하는 방법은 두 가지가 있다. 첫번째는 io.Reader로부터 디코딩 할 수 있는 스트림 기반 json.Decoder이다:\ntype Decoder strcut {} func NewDecoder(r io.Reader) *Decoder func (dec *Decoder) Decode(v interface{}) error  io : io, Reader : Reader, Decoder : Decoder, error : error\n 또는 json.Unmarshal 함수를 사용해 바이트 슬라이스로부터 디코딩 할 수 있다:\nfunc Unmarshal(data []byte, v interface{}) error  byte : byte, error : error\n 이 디코더들은 두 부분으로 동작한다. 우선 scanner 가 입력된 바이트를 토큰화하고 decodeState 가 토큰들을 Go 객체로 변환한다.\nJSON 스캐닝 scanner 는 JSON을 파싱하는데 쓰이는 내부 상태 머신(state machine)이다. 이는 여러 단계로 동작한다. 첫번째로, 이는 파싱을 위한 토큰의 타입을 결정하기 위해 값의 첫번째 바이트를 검사한다. 만약 그게 \u0026ldquo;{\u0026ldquo;라면 객체를 파싱해야하고, \u0026ldquo;[\u0026ldquo;라면 배열을 파싱해야한다. 이는 단순한 값에도 똑같이 적용된다. 쌍 따옴표는 문자열의 시작점을 나타내고, \u0026ldquo;t\u0026rdquo; 나 \u0026ldquo;f\u0026rdquo; 는 부울값의 시작을 나타내며, 0-9 는 숫자의 시작을 나타낸다.\n스캐닝 타입 결정이 끝나면, 이는 타입별 함수 (문자열 스캔, 숫자 스캔 등)로 전달된다. 맵이나 배열같은 복잡한 객체들에 대해선, 닫는 중괄호를 추적하는데 스택이 사용된다.\n버퍼 미리보기 스캐닝의 흥미로운 부분은 버퍼 미리보기이다. JSON은 \u0026ldquo;LL(1)으로 파싱가능\u0026quot;하며 이는 스캐닝하는데 딱 하나의 바이트 버퍼만 필요하다는 의미이다. 이 버퍼는 다음 바이트를 미리 보는데 사용된다.\n예를 들면, 숫자 스캐닝 함수는 숫자가 아닌 문자를 찾을 때까지 바이트를 계속 읽을 것이다. 그러나, 스트림으로부터 문자를 이미 읽었기 때문에 다른 스캐닝 함수가 사용할 수 있도록 이를 버퍼에서 빼줘야 한다. 이게 바로 버퍼 미리보기가 필요한 이유이다.\n파서 작성에 관심이 있다면, 내가 Gopher Academy에 쓴 Handwriting Parsers \u0026amp; Lexers in Go를 보라\n토큰 디코딩 토큰이 스캔되면 이제 해석해야한다. 이는 decodeState 의 일이다. 이 단계에서 디코딩될 입력값들은 처리될 각 토큰과 일치한다.\n예를 들면, 만약 구조체 타입을 전달하면 디코더는 \u0026quot;{\u0026quot; 값을 기대할 것이다. 다른 토큰들이 들어오면 디코딩은 에러를 반환할 것이다. 토큰들을 값들과 일치시키는 이 단계는 reflect 패키지를 많이 사용하지만 디코더는 이를 캐싱하지 않으므로 매 디코딩마다 리플렉션이 이루어진다.\n여러분은 또한 Decoder.Token()과 Decoder.More() 메서드를 사용해 토큰들을 스트림으로 처리할 수도 있다. 나는 이 메서드들을 사용해본 적은 없지만, 이런것들을 사용할 수 있다는걸 알아두면 좋다.\n커스텀 언마샬링(Unmarshaling) 인코딩과 마찬가지로, 디코딩 커스텀 구현체도 만들 수 있다. 디코더는 먼저 타입이 json.Unmarshaler 를 구현하고 있는지를 검사한다:\ntype Unmarshaler interface { UnmarshalJSON([]byte) error }  byte : byte, error : error\n 이는 타입이 한 타입에 대한 JSON 값 전체를 받도록하며 타입 자체를 파싱할 수 있다. 이는 자체적으로 최적화 구현체를 구현하고싶을때 유용하다.\n다음으로 디코더는 타입이 encoding.TextUnmarshaler를 구현하고 있는지를 검사한다:\ntype TextUnmarshaler interface { UnmarshalText(text []byte) error }  byte : byte, error : error\n 이는 사용하고 싶은 타입의 문자열 표현을 가지고 있을때 유용하다. 이의 한 예시는 내부적으로 정수로 표현되는 enum 타입을 문자열로써 인코딩/디코딩하는 경우이다.\n지연 처리 json.Unmarshaler의 대체제는 json.[RawMessage] 타입이다. RawMessage를 사용하면, 원본 JSON 표현이 언마샬링이 완료된 후에 처리할 수 있는 필드에 저장된다. 이는 JSON 객체의 \u0026ldquo;type\u0026rdquo; 필드를 해석하고 값을 기반으로 JSON 파싱을 변경해야 할 때 유용하다.\ntype T struct { Type string `json:\u0026#34;type\u0026#34;` Value json.RawMessage `json:\u0026#34;value\u0026#34;` } func (t *T) Val() (interface{}, error) { switch t.Type { case \u0026#34;foo\u0026#34;: // \u0026#34;t.Value\u0026#34;를 Foo로 파싱  case \u0026#34;bar\u0026#34;: // \u0026#34;t.Value\u0026#34;를 Bar로 파싱  default: return nil, errors.New(\u0026#34;invalid type\u0026#34;) } } 나는 개인적으로 추후 해석을 위해 JSON을 저장해두는것을 좋아하지 않기 때문에 json.Unmarshaler가 좀 더 유용하다고 생각한다.\n또 다른 지연 처리 방법은 JSON 숫자를 사용하는것이다. 왜냐하면 JSON은 정수와 실수를 구분하지 못하기 때문에 디코더는 interface{} 필드로 숫자를 디코딩 할 시 float64 로 변환한다. 파싱을 지연 시키기위해 json.Number 타입을 대신 사용할 수 있다.\ntype T struct { Value json.Number } ... if strings.Contains(t.Value, \u0026#34;.\u0026#34;) { v, err := t.Value.Float64() // 실수로 처리 } else { v, err := t.Value.Int64() // 정수로 처리 } 나는 디코딩시 주로 정적 타입을 사용하기 때문에 json.Number를 잘 사용하지 않는다.\n깔끔한 출력 JSON은 일반적으로 추가 공백 없이 하나의 긴 바이트로 쓰이지만, 이는 읽기가 어렵다. 여러분은 두 가지 방법으로 들여쓰기를 설정할 수 있다. JSON으로 인코딩된 인메모리 바이트 슬라이스의 경우엔 이를 json.Indent() 함수에 전달할 수 있다:\nfunc Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error  bytes : bytes, Buffer : Buffer, byte : byte, string : string, error : error\n prefix 인자는 모든 라인에 쓸 문자를 지정하고 inednt 는 들여쓰기에 사용는 문자를 지정한다. 나는 prefix 는 많이 사용하지 않지만 indent 값으로는 보통 2-스페이스 또는 탭을 사용한다.\njson.Marshal()를 호출한 다음 json.Indent를 호출해주는 json.MarshalIndent()라는 헬퍼 함수가 있다.\n만약 스트림 기반의 json.Encoder를 사용하고 있다면 SetIndent() 메서드를 사용해 들여쓰기를 할 수 있다:\nfunc (enc *Encoder) SetIndent(prefix, indent string)  Encoder : Encoder, string : string\n 많은 사람들이 SetIndent()에 대해 모르고 바이트 슬라이스를 마샬링하고 들여쓴 후 그 결과를 스트림에 쓴다.\n들여쓰기 함수의 반대는 Compact() 함수이다:\nfunc Compact(dst *bytes.Buffer, src []byte) error  bytes : bytes, Buffer : Buffer, byte : byte, error : error\n 이는 src 를 대상 버퍼로 재작성하지만 모든 공백을 지운다.\n인코딩/디코딩시 에러 핸들링 json 패키지는 상당수의 에러 타입을 가지고 있다. 아래에 인코딩 또는 디코딩시 마주할 수 있는 에러 리스트가 있다:\n 디코딩을 하기 위해 포인터가 아닌 값을 전달하여 실제로는 값의 복사본을 전달하게되면 디코더는 원래값에 디코딩을 할 수 없다. 디코더는 이를 잡아내고 InvalidUnmarshalError를 반환한다. 만약 데이터가 잘못된 JSON 값을 포함하고 있으면 잘못된 문자의 바이트 위치와 함께 SyntaxError가 반환된다. 만약 에러가 json.Marshaler나 encoding.TextMarshaler에 의해 반환되면 이는 MarshalerError로 래핑된다. 만약 토큰이 대응하는 값으로 언마샬링 될 수 없는 경우 UnmarshalTypeError가 반환된다. Infinity 와 NaN 의 실수값은 JSON으로 표현할 수 없으며 UnsupportedValueError가 반환된다. JSON으로 표현할 수 없는 타입들(예를 들어, 함수, 복소수, 포인터 등등)의 경우 UnsupportedTypeError가 반환된다. Go 1.2 이전에서 잘못된 UTF-8 문자는 InvalidUTF8Error에러를 반환한다. 이후 버전은 단순히 잘못된 문자를 \u0026ldquo;알 수 없는 문자\u0026quot;를 의미하는 유니코드 문자인 U+FFFD로 변환한다.  에러가 많은 것처럼 보일 수 있지만, 에러를 로깅하고 사람이 직접 개입해서 조작하는것 이외에 코드에서 처리할 수 있는것은 많지 않다. 또한, 이들중 대부분은 유닛 테스트 커버리지가 있다면 개발 도중 잡아낼 수 있다.\n대체 구현 몇 년 전 나는 리플렉션을 완전히 피하기 위해 컴파일 시 특정 타입별 인코더와 디코더를 생성해주는 megajson라는 툴을 개발했었다. 이는 인코딩과 디코딩을 훨씬 빠르게 만들어주었다. 그러나, 이 툴은 개념 증명이었으며 지원의 한계가 있어 결국 버려졌다.\n운좋게도, Paul Querna이 동일한 일을 하지만 훨씬 나은 ffjson이라는 구현체를 만들었다. JSON 인코딩과 디코딩 성능을 향상시키고자 한다면 이 툴을 강력히 추천한다.\n결론 JSON은 빠르게 실행해야하거나 유저에게 간단한 API를 제공해야 할 때 훌륭한 데이터 포맷이 될 수 있다. Go의 구현체는 리플렉션을 사용하여 간단하게 사용할 수 있는 많은 기능들을 제공한다.\n우리는 JSON 표현을 포맷팅 하는 방법 뿐만 아니라 JSON의 인코딩과 디코딩 측면의 내부를 살펴보았다. 이 툴들은 밖에선 간단해 보일 수 있지만 내부적으로는 최대한 빠르고 효율적으로 만들기 위해 많은 일들이 일어나고 있다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part2/",
	"title": "Golang의 내부, 2부: Go 컴파일러 들여다 보기",
	"tags": ["Golang", "Internals", "Compiler", "Structure"],
	"description": "",
	"content": "독자는 인터페이스 레퍼런스를 통해 변수를 사용할 경우 Go 런타임내에서 어떤 일이 있는지 정확하게 알고 있는가? 이 질문에 쉽게 답할 수 없는 이유는 어떤 인터페이스를 구현하는 타입의 경우 그 인터페이스를 가리키는 어떤 레퍼런스도 갖고 있지 않기 때문이다. 하지만 여전히 시도는 해 볼 수 있는데 이전 블로그 포스트에서 논했던 Go 컴파일러의 지식을 이용하는 것이다.\n그러면, Go 컴파일러속으로 잠수해 들어가자: 간단한 Go 프로그램을 제작하고 Go 타입캐스팅(typecasting)이 내부적으로 어떻게 동작하는 지 살펴보겠다. 이 것을 예로 들면서, 어떻게 노드 트리가 생성되고 사용되는지 설명하겠다. 이렇게 함으로써 독자도 이 지식을 다른 Go 컴파일러 기능에 적용할 수 있을 것이다.\n시작하기 전에 실험을 하기 전에, (Go 툴을 쓰는 것이 아니라) Go 컴파일러를 직접 사용할 필요가 있다. 다음 명령을 사용해 이 기능에 접근할 수 있다:\n  go tool 6g test.go\n 이 명령으로 *test.go* 소스파일은 컴파일되고 오브젝트 파일(object file)이 만들어 진다. 여기서 *6g* 는 AMD64 아키텍쳐인 저자의 머신을 위한 컴파일러의 이름이다. 다른 아키텍쳐에서는 상응하는 컴파일러를 사용해야 함을 주목하라. 컴파일러를 직접 사용할 때 유용한 커맨드 라인 인수들을 사용할 수 있는데, 자세한 내용은 [여기](https://golang.org/cmd/gc/#hdr-Command_Line)를 참고하라. 이 실험을 위해서, 노드 트리의 레이아웃을 출력해 주는 *-W* 플래그를 사용하겠다. # 간단한 Go 프로그램 만들기 우선 간단한 Go 프로그램을 만들자. 저자의 버전은 다음과 같다: \u0026gt;```go 1 package main 2 3 type I interface { 4 DoSomeWork() 5 } 6 7 type T struct { 8 a int 9 } 10 11 func (t *T) DoSomeWork() { 12 } 13 14 func main() { 15 t := \u0026amp;T{} 16 i := I(t) 17 print(i) 18 } 정말 간단하지 않은가? 불필요하게 생각되는 단 하나는 17째 줄인데, i 변수를 출력하는 부분이다. 불필요하다고 판단됨에도 불구하고 이 줄이 없다면, i 는 사용하지 않은 변수로 간주되어 프로그램은 컴파일 되지 않을 것이다. 다음 단계는 이 프로그램을 -W 를 사용해 컴파일 하는 것이다:\n  go tool 6g -W test.go\n 이 명령을 실행한 후에, 프로그램내 정의된 각 메서드에 해당하는 노드 트리를 포함한 출력을 보게 될 것이다. 이 경우, *main* 과 *init* 메서드가 있다. *init* 메서드가 언급된 이유는 모든 프로그램에 암시적으로 정의되어 있기 때문인데, 실제로 여기에서는 다루지 않겠다. 각 메서드마다, 컴파일러는 두개의 노드트리 버전을 출력한다. 첫번째는 소스파일을 파싱하고 얻는 노드 트리의 원본이고 두번째는 타입체킹후 모든 필요한 수정을 거친 버전이다. # main 메서드의 노드 트리에 대한 이해 우선 main 메서드에서 나온 노드 트리의 원본을 자세히 들여다 보고 정확하게 무슨 일이 일어나고 있는지를 이해하기 위한 시도를 해보자. \u0026gt;``` DCL l(15) . NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T AS l(15) colas(1) tc(1) . NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T . PTRLIT l(15) esc(no) ld(1) tc(1) PTR64-*main.T . . STRUCTLIT l(15) tc(1) main.T . . . TYPE \u0026lt;S\u0026gt; l(15) tc(1) implicit(1) type=PTR64-*main.T PTR64-*main.T DCL l(16) . NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I AS l(16) tc(1) . NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T . NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T AS l(16) colas(1) tc(1) . NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I . CONVIFACE l(16) tc(1) main.I . . NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T VARKILL l(16) tc(1) . NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T PRINT l(17) tc(1) PRINT-list . NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I 아래 설명할 때는 불필요한 부분을 모두 제거한 요약한 버전을 사용하겠다.\n첫번째 노드는 꽤 단순하다.\n  DCL l(15) . NAME-main.t l(15) PTR64-*main.T\n 첫번째 노드는 선언 노드이다. *l(15)* 는 노드가 줄 15에 정의되어 있음을 알려준다. 선언 노드는 *main.t* 변수를 나타내는 이름 노드(name node)에 레퍼런스를 갖는다. 변수가 정의된 곳은 main 패키지이고 실제로 *main.T* 타입를 가리키는 64비트 포인터이다. 15째 줄을 보면 어떤 선언이 되어 있는지 쉽게 이해할 수 있다. 다음 것은 약간 까다롭다. \u0026gt;``` AS l(15) . NAME-main.t l(15) PTR64-*main.T . PTRLIT l(15) PTR64-*main.T . . STRUCTLIT l(15) main.T . . . TYPE l(15) type=PTR64-*main.T PTR64-*main.T 최상위 노드(root node)는 할당(assignment) 노드이다. 첫번째 자식노드는 이름 노드(name node)로 main.t 변수를 대표한다. 두번째 자식노드는 main.t 에 할당되는, 포인터 리터럴 노드이다: \u0026amp;를 생각하라. 이 노드는 struct 리터럴 노드를 자식으로 갖고 있고, 그 노드는 또 실제 타입인 (main.T)를 대표하는 타입 노드를 포인터로 가리킨다.\n다음 노드는 또 다른 선언이다. 이번에는 main.I 타입에 속하는 main.i 변수의 선언이다.\n  DCL l(16) . NAME-main.i l(16) main.I\n 그런 다음, 컴파일러는 또 다른 변수, *autotmp_0000* 를 만들고, *main.t* 변수를 할당한다. \u0026gt;``` AS l(16) tc(1) . NAME-main.autotmp_0000 l(16) PTR64-*main.T . NAME-main.t l(15) PTR64-*main.T 마침내, 흥미로운 노드들에 도착했다.\n  AS l(16) . NAME-main.i l(16)main.I . CONVIFACE l(16) main.I . . NAME-main.autotmp_0000 PTR64-*main.T\n 여기를 보면, 컴파일러가 *CONVIFACE* 라고 불리는 특별한 노드를 *main.i* 에 할당하는 것을 볼 수 있다. 하지만 이것만으로는 실제로 내부에서 어떤 일이 일어나는지 알 수 없다. 한가지 방법은 모든 모드 트리 수정이 적용되고 난 후에 main 메서드의 노드 트리속을 들여다 보는 것인데, 출력된 내용 중 \u0026quot;after walk main\u0026quot; 라는 섹션내의 정보를 통해 알아보는 것이다. # 컴파일러는 어떻게 할당노드를 번역하는가 아래를 보면 컴파일러가 어떻게 할당 노드(assignment node)를 번역하는 지 알 수 있다: \u0026gt;``` AS-init . AS l(16) . . NAME-main.autotmp_0003 l(16) PTR64-*uint8 . . NAME-go.itab.*\u0026quot;\u0026quot;.T.\u0026quot;\u0026quot;.I l(16) PTR64-*uint8 . IF l(16) . IF-test . . EQ l(16) bool . . . NAME-main.autotmp_0003 l(16) PTR64-*uint8 . . . LITERAL-nil I(16) PTR64-*uint8 . IF-body . . AS l(16) . . . NAME-main.autotmp_0003 l(16) PTR64-*uint8 . . . CALLFUNC l(16) PTR64-*byte . . . . NAME-runtime.typ2Itab l(2) FUNC-funcSTRUCT-(FIELD- . . . . . NAME-runtime.typ·2 l(2) PTR64-*byte, FIELD- . . . . . NAME-runtime.typ2·3 l(2) PTR64-*byte PTR64-*byte, FIELD- . . . . . NAME-runtime.cache·4 l(2) PTR64-*PTR64-*byte PTR64-*PTR64-*byte) PTR64-*byte . . . CALLFUNC-list . . . . AS l(16) . . . . . INDREG-SP l(16) runtime.typ·2 G0 PTR64-*byte . . . . . ADDR l(16) PTR64-*uint8 . . . . . . NAME-type.*\u0026quot;\u0026quot;.T l(11) uint8 . . . . AS l(16) . . . . . INDREG-SP l(16) runtime.typ2·3 G0 PTR64-*byte . . . . . ADDR l(16) PTR64-*uint8 . . . . . . NAME-type.\u0026quot;\u0026quot;.I l(16) uint8 . . . . AS l(16) . . . . . INDREG-SP l(16) runtime.cache·4 G0 PTR64-*PTR64-*byte . . . . . ADDR l(16) PTR64-*PTR64-*uint8 . . . . . . NAME-go.itab.*\u0026quot;\u0026quot;.T.\u0026quot;\u0026quot;.I l(16) PTR64-*uint8 AS l(16) . NAME-main.i l(16) main.I . EFACE l(16) main.I . . NAME-main.autotmp_0003 l(16) PTR64-*uint8 . . NAME-main.autotmp_0000 l(16) PTR64-*main.T 출력을 통해 볼 수 있듯이, 컴파일러는 우선 초기화 노드 리스트 (AS-init) 를 할당 노드에 첨가한다. AS-init 내에서는, go.itab.*””.T.””.I 변수 값을 새로 만든 변수 main.autotmp_0003 에 할당한다. 그런 다음, 변수가 nil 인지를 검사한다. 만약에 nil 이면, 컴파일러는 runtime.typ2Itab 함수를 다음의 인수들을 사용해 호출한다:\n main.T 타입의 포인터, main.I 인터페이스 타입의 포인터, go.itab.*””.T.””.I 변수를 가리키는 포인터.  코드에서 보면, 이 변수가 main.T 에서 main.I 로 타입변환된 결과를 저장하는데 사용되고 있음이 명백하다.\ngetitab 메서드의 내부 논리적인 다음 단계는 runtime.typ2Itab 를 찾아보는 것이다. 아래에 이 함수를 나열해 놓았다.\n  func typ2Itab(t *_type, inter *interfacetype, cache **itab) *itab { tab := getitab(inter, t, false) atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab)) return tab }\n 확실해 보이는 것은 실제 작업은 *getitab* 메서드 내부에서 진행된다는 점인데, 두번째 줄에서 단순히 tab 변수를 cache 변수에 저장하는 점을 통해 알 수 있다. 그럼 *getitab* 내부를 들여다 보자. 꽤 긴 내용이라 가장 들여다 볼 가치가 있는 부분만 복사했다. \u0026gt;``` m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0, \u0026amp;memstats.other_sys)) m.inter = interm._type = typ ni := len(inter.mhdr) nt := len(x.mhdr) j := 0 for k := 0; k \u0026lt; ni; k++ { i := \u0026amp;inter.mhdr[k] iname := i.name ipkgpath := i.pkgpath itype := i._type for ; j \u0026lt; nt; j++ { t := \u0026amp;x.mhdr[j] if t.mtyp == itype \u0026amp;\u0026amp; t.name == iname \u0026amp;\u0026amp; t.pkgpath == ipkgpath { if m != nil { *(*unsafe.Pointer)(add(unsafe.Pointer(\u0026amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn } } } } 우선 결과를 저장할 메모리를 할당한다.\n  (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0, \u0026amp;memstats.other_sys))\n Go 언어에서 왜 메모리를 할당하는지 그리고 왜 이렇게 이상한 방식으로 하는지 궁금해 진다. 이 질문에 답하기 위해 *itab* struct 정의를 들여다 보아야 할 필요가 있다. \u0026gt;``` type itab struct { inter *interfacetype _type *_type link *itab bad int32 unused int32 fun [1]uintptr // variable sized } 마지막 특성인 fun 은 요소가 하나인 배열로 정의되어 있다. 하지만 실제로 배열의 크기는 변할 수 있다고 코멘트되어 있다. 나중에 보겠지만 이 특성은 특정한 타입내 정의된 메서드들을 가리키는 포인터 배열를 가지고 있다. 이 메서드들은 인터페이스 타입의 메서드에 상응한다. Go 언어의 저자들은 이 특성을 위해 동적 메로리 할당을 사용한다. (그렇다, unsafe 패키지를 사용하면 이런 일들이 가능하다.) 메모리를 얼마나 할당해야 하는지는 struct 자체의 크기에 인터페이스내 메서드의 숫자에 포인터 크기를 곱한 값을 더해 계산할 수 있다.\n  unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize\n 다음으로 두개의 중첩된 루프를 볼 수 있다. 첫째로 인터페이스의 모든 메서드를 차례로 처리한다. 인터페이스의 각 메서드에 대해서 특정한 타입내에 상응하는 메서드를 찾으려 한다. (메서드는 *mhdr* 컬렉션에 저장되어 있다.) 두 메서드가 서로 같은지를 비교하는 과정은 굳이 설명할 필요가 없겠다. \u0026gt;``` if t.mtyp == itype \u0026amp;\u0026amp; t.name == iname \u0026amp;\u0026amp; t.pkgpath == ipkgpath 만약 매치를 찾으면, 결과값의 fun 에 메서드를 가리키는 포인터를 저장한다:\n  *(*unsafe.Pointer)(add(unsafe.Pointer(\u0026amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn\n 성능에 대해 짧게 언급하면: 인터페이스와 사전에 설정된 타입 정의에 대해 메서드는 알파벳 순서로 정렬되어 있어서, 이 중첩 루프는 *O(n * m)* 대신 *O(n + m)* 으로 반복한다. n 과 m 은 상응하는 메서드 숫자들 마지막으로, 할당의 마지막 부분을 기억하는가? \u0026gt;``` AS l(16) . NAME-main.i l(16) main.I . EFACE l(16) main.I . . NAME-main.autotmp_0003 l(16) PTR64-*uint8 . . NAME-main.autotmp_0000 l(16) PTR64-*main.T 여기에서 EFACE 노드를 main.i 변수에 할당한다. EFACE 노드는 main.autotmp_0003 와 main.autotmp_0000 변수들에 대한 레퍼런스를 가지고 있는데 - main.autotmp_0003 는 runtime.typ2Itab 에 의해 반환된 itab struct를 가리키는 포인터이고, main.autotmp_0000 변수는 main.t 와 같은 값을 가지고 있다. 인터페이스 레퍼런스를 통해 메서드를 호출하는데 필요한 것은 이게 전부이다.\n그래서, main.i 변수는 런타임 runtime 패키지내 정의된 iface struct의 인스턴스를 가지고 있다.\n  type iface struct { tab *itab data unsafe.Pointer }\n # 다음에 살펴볼 내용은? 저자가 지금까지 Go 컴파일러와 런타임에 대해 아주 작은 부분만 설명했다는 점을 이해한다. 얘기해 볼만한 흥미로운 주제들이 여전히 많이 남아있다. 예를 들면, 오브젝트 파일, 링커, 재배치(relocations), 등에 대해서는 다음 블로그 포스트에서 살펴보기로 하겠다. * 원문: [Golang Internals, Part 2: Diving Into the Go Compiler](http://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html) * 저자: Siarhei Matsiukevich * 번역자: Jhonghee Park "
},
{
	"uri": "https://devbj.com/golangkorea/go-start/feature/",
	"title": "Go의 주요 특징들",
	"tags": ["beginning"],
	"description": "",
	"content": "단순함 Go 언어는 단순함(simplicity)과 실용성(pragmatism)을 지향하는 언어로 이 두가지 철학이 다른 모든 것들 보다 상위에 있다. go 언어에 없는 것들을 보자.\n 패턴매칭 함수 프로그래밍 : 어느 정도 특징을 가지고 있기는 하지만 지향점은 아니다. immutable variables Option types : 값외에 유효한지, 초기화가 됐는지 등의 추가적인 정보를 설정할 수 있다. 예외(exception)가 없다. 클래스도 없다. 제너릭(generics)를 지원하지도 않는다.  현대적인 언어들이라면 당연히 가지고 있음직한 굵직한 특성들을 가지고 있지 않다. 심지어 \u0026ldquo;Go는 40년 동안의 프로그래밍 언어에 대한 연구를 던져버린 유일한 언어\u0026quot;라고 평가를 받기도 한다(제너릭의 경우 지원하려는 움직임이 있는 것 같기는 하다). 그리고 이러한 철학을 그대로 하고 있는데, 1.0 버전이 나온 이후 1.7 까지 문법적인 변화가 거의 없다.\n1.0 이 나온게 2012년이니 5년 동안 변한게 없다는 이야기다. 따라서 개발자는 호환성 문제에서 자유로우며, 기술에 대한 숙련도를 꾸준히 유지 할 수 있다. 단순함을 포기하지 않기 때문에 가능한 일이다. Go release History에서 버전별 변경점을 찾아 볼 수 있는데, 버그 수정, 지원 플랫폼, 툴 추가, 컴파일러 변경, 가비지 컬랙터 효율화 등 언어 내적인 것들이 대부분이다.\n계속 단순함을 유지하면서, 언어적인 발전이 가능 할 것인지에 대한 의구심을 가질 수 있다. 이렇게 생각해보자. 복싱은 주먹을 사용하는 격투기 중 최고로 평가받고 있다. 그런데 복싱이 가지고 있는 기술이라는게 스트레이트, 잽, 어퍼, 훅 4가지 밖에 없다. 기술이 적기 때문에 시작하기가 쉽고 반복훈련을 통해서 빠르게 기량을 높일 수 있다. 그리고 직관적인 만큼 실전에서의 응용이 용이하다.\nGo 언어도 마찬가지다. 1-2주면 언어의 거의 모든 기능에 익숙해질 수 있으며, 반복 훈련을 통해서 빠르게 기량을 높일 수 있다. 코드가 직관적이기 때문에 코드를 만들고 읽는게 쉬우며 그만큼 실전에 빠르게 써먹을 수 있다.\n물론 언어의 단순함이 모든 경우에 장점이 될 수는 없을 것이다. Go 언어는 시스템, 네트워크 프로그램 특히 클라우드 환경에서 작동하는 프로그램의 개발에는 강력한 면모를 보여주지만 모바일, 데스크탑 애플리케이션에도 강점을 보여줄지는 의문이다(애초에 이쪽은 별로 신경을 쓰고 있지 않기 때문에 판단하기는 애매모호하긴 하다).\n클라우드와 친한 go 언어 단순함과 이로부터 파생되는 특징은 클라우드 환경에 잘 맞는 경향이 있다. 분산환경은 시스템이 분산된다는 의미외에 소프트웨어가 분산된다는 의미도 있다. 이런 환경에서는 소프트웨어들이 많은 기능을 가지고 있을 필요가 없다. 필수적인 기능만 가진 여러 소프트웨어들이 서로 데이터를 주고 받는 식으로 작동을 하는게 더 효율적이다. 이런 소프트웨어 운영 모델은 리눅스에서 찾아볼 수 있다.\n# ps aux | grep chorm | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill ps로 프로세스 목록을 출력하면 grep으로 chrom 프로세스의 정보만 가져오고, awk를 이용해서 PID를 읽어서 kill로 죽이는 일을 하는 스크립트다. 클라우드환경에서 뜨는 MSA(go언어를 이용한 MSA 문서를 만들어봐야 겠다.)가 이런 방식으로 작동한다.\n클라우드는 컴퓨터와 네트워크, 운영체제를 하나로 통합한다. 이런 환경에서 프로그래밍 언어의 버전, 라이브러리 의존성을 신경쓰면서 애플리케이션을 배포하는 건 굉장히 어려운 일이다. 최근 도커(docker)가 핫한 것도 운영체제 등 주변환경이 어떻든지 간에 자유롭게 배포 할 수 있고, 동일하게 작동 할 것을 보장해 주기 때문이다.\nGo 언어로도 이런 개발 \u0026amp; 배포 환경을 만들 수 있다. 도커와 함께 클라우드를 위한 컨테이너 솔류션을 만들고 싶다면 Go는 최고의 선택이 될 것이다.\nstruct를 이용한 객체지향 Go는 클래스와 객체가 없다. 그렇다고 해서 객체지향 언어가 아니라고 하기도 그렇다. 원래 객체지향이라는 것은 프로그래밍 방법론으로 언어와 상관이 있는 것은 아니다. C언어로도 객체지향을 할 수 있고, C++로도 절차지향을 할 수 있다. 다만 얼마나 객체지향 프로그래밍을 잘 지원하느냐에 대한 차이는 있는데, 표면적으로는 클래스와 객체가 있는지를 기준으로 삼는 경우가 많다. 상속역시 지원하지 않는다. Go는 전통적인 의미에서의 객체지향 언어라고 하기는 애매모호 하다.\n하지만 메서드를 만들 수 있으며, interface를 이용해서 다형성을 구현 할 수도 있다. composition으로 상속을 대신 할 수도 있다. 뭔가 편법을 동원한다는 느낌이 들 수도 있겠지만, 객체지향에 있어서 반드시 무엇을 해야 한다는 어떤 규칙은 없다. Sandi Metz은 이렇게 말하고 있다. \u0026ldquo;객체지향에 있어서 클래스와 상속은 옵션이며, 한 문제는 다양한 방법으로 풀 수 있다.\u0026rdquo;\nstruct는 하나 이상의 필드들로 구성된 데이터 타입으로 레코드 형식의 데이터 그룹을 만들기 위해서 사용한다. 개인 정보를 다루는 애플리케이션을 개발한다면 아래와 같은 person 스트럭처를 만들 수 있을 것이다.\ntype person struct { name string age int } 소프트웨어 공학에서 기본적으로 클래스는 속성과 메서드의 모음으로 표현된다. 파이썬의 경우를 보자.\nclass Person: minAge = 0 def __init__(self, name, age): self.name = name self.age = age def Hello(self): print(\u0026#34;Hello. My name is %s\u0026#34; % self.name) def MyAge(self): print(\u0026#34;My age is %s\u0026#34; % self.age) minAge와 self.name, self.age라는 속성과 Hello, MyAge라는 메서드를 가지는 Person 클래스를 만들었다. 일반적으로 알고 있는 클래스의 모습이다.\n반면 go는 struct와 메서드가 서로 분리된다. 위의 파이썬 코드를 go 코드로 만들어봤다.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Person struct { minAge int name string age int } func (p Person) Hello() { fmt.Printf(\u0026#34;Hello. My name is %s\\n\u0026#34;, p.name) } func (p Person) MyAge() { fmt.Printf(\u0026#34;My age is %d\\n\u0026#34;, p.age) } func main() { yundream := Person{minAge: 0, name: \u0026#34;yundream\u0026#34;, age: 33} yundream.Hello() yundream.MyAge() } Playground\n뭔가 굉장히 낯설어 보인다. 일단 캡슐화는 지원한다. 보통 private, public 키워드를 이용하는데, Go언어에는 이런게 없다. 대신 대/소 문자로 구분을 한다. 대문자로 시작하면 public, 소문자로 시작하면 private가 되는 식이다. private 변수나 메서드는 패키지 내에서만 사용 할 수 있다.\n메서드가 구조체와 분리되기 때문에, 이 메서드가 어느 구조체에 연결된 것인지를 구분해야 한다. **수신자(receiver - func 키워드와 함수명 사이에 위치한다)**를 이용해서, 연결된 구조체를 확인 할 수 있다. 메서드는 . 연산자를 이용해서 호출 할 수 있다.\nGo는 생성자가 없다. 예제에서 처럼, 구조체를 생성 할 때 초기값을 할당 하거나 혹은 구조체 객체의 포인터를 반환하는 New 함수를 만들어서 사용한다.\nfunc New(minAge int, name string, int age) *Person { return \u0026amp;Person{minAge: minAge, name: name, age: age} } 에러 처리 Go는 예외(execption)가 없다. C언어와 같이 반환 값이 에러인지 아닌지를 비교하는 방법으로 에러를 처리한다. 대신 에러만을 전문적으로 처리하는 error 타입을 내장하고 있다. Go 프로그램은 error 값을 검사하는 것으로 에러 상태를 확인 할 수 있다.\n또한 go는 두 개 이상의 값을 반환 할 수 있다. 이 특징을 이용하면 실행 반환 값과 에러를 함께 넘기는 방식으로 에러를 처리할 수 있다. 예를 들어 os.Open 함수는 열린 파일의 데이터를 담고 있는 File 구조체와 error를 함께 반환한다.\nfunc Open(name string) (file *File, err error) 코드에서는 error 값이 \u0026ldquo;nil\u0026quot;인지 아닌지로 에러를 검사한다.\nf, err := os.Open(\u0026#34;filename.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;File open error : \u0026#34;, err.Error()) os.Exit(1) } // 파일 처리 예외 처리가 없기 때문에 C 언어처럼 모든 에러 리턴에 대한 코드를 만들어야 한다. 함수를 만들다 보면 에러처리 코드가 절반이상을 차지하는 것을 심심찮게 볼 수 있다.\n개발자는 errors 패키지를 이용해서 직접 에러를 만들 수 있다.\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func YourLevel(point int) (int, error) { if point \u0026lt; 0 { return 0, errors.New(\u0026#34;Level: 레벨 값은 0보다 커야 합니다.\u0026#34;) } if point \u0026gt; 255 { return 0, errors.New(\u0026#34;Level: 레벨 값은 255보다 작아야 합니다.\u0026#34;) } return point / 10, nil } func main() { level, err := YourLevel(25) if err != nil { fmt.Println(\u0026#34;Error \u0026#34;, err.Error()) os.Exit(1) } fmt.Printf(\u0026#34;당신의 레벨은 %d 입니다.\\n\u0026#34;, level) } Playground\n실제 코드에서는 아래와 같이 에러 케이스를 정의해서 사용한다. 위 코드를 약간 수정했다.\nvar StatusPointUnderZero = errors.New(\u0026#34;Level: 레벨 값은 0보다 커야 합니다.\u0026#34;) var StatusPointOverflow = errors.New(\u0026#34;Level: 레벨 값은 255보다 작아야 합니다.\u0026#34;) func YourLevel(point int) (int, error) { if point \u0026lt; 0 { return 0, StatusPointUnberZero } if point \u0026gt; 255 { return 0, StatusPointOverflow } return point / 10, nil } func main() { level, err := YourLevel(25) switch err { case StatusPointUnberZero: // 에러처리 코드  case StatusPointOverflow: // 에러처리코드  default: // 에러처리 코드  } fmt.Printf(\u0026#34;당신의 레벨은 %d 입니다.\\n\u0026#34;, level) } 다른 예제를 이용해서 error를 이용한 에러 처리가 가지는 장점을 살펴보자. 아래 프로그램은 입력 값이 양수인지 음수인지를 검사한다.\npackage main import \u0026#34;fmt\u0026#34; // Positive returns true if the number is positive, false if it is negative. func Positive(n int) bool { return n \u0026gt; -1 } func Check(n int) { if Positive(n) { fmt.Println(n, \u0026#34;is positive\u0026#34;) } else { fmt.Println(n, \u0026#34;is negative\u0026#34;) } } func main() { Check(1) Check(0) Check(-1) } Playground\n프로그램의 실행 결과다. 버그를 가지고 있음을 알 수 있다.\n1 is positive 0 is positive -1 is negative 0은 양수도 아니고 음수도 아니다. 양수, 음수, 0 이렇게 3개의 상태를 가지기 때문에 boolean 으로는 이들 상태를 처리 할 수없다.\nGo언어는 2개 이상의 반환 값을 가질 수 있으므로, 0인지를 측정 할 수 있는 값을 반환하면 된다.\n// 입력값이 0일 경우 두번째 리턴값으로 false를 반환한다. func Positive(n int) (bool, bool) { if n == 0 { return false, false } return n \u0026gt; -1, true } func Check(n int) { pos, ok := Positive(n) if !ok { fmt.Println(n, \u0026#34;is neither\u0026#34;) return } if pos { fmt.Println(n, \u0026#34;is positive\u0026#34;) } else { fmt.Println(n, \u0026#34;is negative\u0026#34;) } } 프로그램을 실행해보자. 버그가 잡혔다.\n1 is positive 0 is neither -1 is negative 문제없이 작동하지만 좋은 코드는 아니다. 일단 직관적이지 않다. 코드를 열어 보기 전에는 두 개의 boolean 반환 값이 무엇을 의미하는지 알 수가 없다. error를 이용해서 0 값을 예외처리 하도록 바꿔보자.\nfunc Positive(n int) (bool, error) { if n == 0 { return false, errors.New(\u0026#34;undefined\u0026#34;) } return n \u0026gt; -1, nil } func Check(n int) { pos, err := Positive(n) if err != nil { fmt.Println(n, err) return } if pos { fmt.Println(n, \u0026#34;is positive\u0026#34;) } else { fmt.Println(n, \u0026#34;is negative\u0026#34;) } } 하는 일은 차이가 없으나 코드가 명료해졌다.\n동시성 프로그래밍 Go에서 제공하는 고루틴이라고 기능을 이용해서 다른 함수를 동시에 실행 할 수 있다. 쓰레드와 비슷하게 작동한다. Go에서 고루틴은 **일급 객체(first class)**로 정수(integer)나 실수(floating point number)와 같은 데이터 타입과 동급으로 취급한다. 일급객체에 대해서는 wikipedia 문서 를 참고하자. 아래 예제 코드를 보자.\npackage main import \u0026#34;fmt\u0026#34; func f(id int) { for i := 0; i \u0026lt; 10; i++ { fmt.Println(id, \u0026#34;:\u0026#34;, i) } } func main() { go f(0) var input string fmt.Scanln(\u0026amp;input) } go 키워드 뒤에 동시 실행할 함수를 두면, 해당 함수를 실행하는 고루틴이 만들어진다. 고루틴과 main함수는 서로 독립적으로 진행이 된다. main 함수가 고루틴 보다 먼저 종료 할 수 있기 때문에 Scanln 함수를 이용해서 기다리게 했다.\n10개의 고루틴을 만들어보자. 그냥 go를 열번 호출하면 된다.\n$ go run goroutine.go 0 : 0 0 : 1 0 : 2 0 : 3 0 : 4 0 : 5 0 : 6 0 : 7 0 : 8 0 : 9 채널(channel)은 고루틴들 간에 데이터를 교환하기 위해서 사용한다. Go도 공유 잠금을 지원하기는 하지만 메시지 교환방식을 선호한다. 아래는 고루틴간 ping 메시지를 교환하는 간단한 프로그램이다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func pinger(c chan string) { for i := 0; ; i++ { c \u0026lt;- \u0026#34;ping\u0026#34; } } func pingPrinter(c chan string) { for { msg := \u0026lt;-c fmt.Println(msg) time.Sleep(time.Second * 1) } } func main() { var c chan string = make(chan string) go pinger(c) go pingPrinter(c) var input string fmt.Scanln(\u0026amp;input) } chan 키워드를 이용해서 채널 타입 데이터를 만들 수 있다. 채널은 메시지를 주고 받는 통로 역할을 하는데 struct를 포함한 모든 종류의 데이터들을 주고 받을 수 있다. 코드에서는 string 타입 데이터를 위한 채널을 만들었다.\n\u0026lt;- 연산자를 이용해서 채널에 데이터를 쓰거나 읽을 수 있다. **c \u0026lt;- \u0026ldquo;ping\u0026rdquo;**는 채널에 \u0026ldquo;ping\u0026quot;을 쓰겠다는 의미고, msg := \u0026lt;-c는 채널에서 읽은 데이터를 msg에 저장하겠다는 의미다.\n인터페이스 인터페이스는 메서드들의 모음으로 간단히 정의 할 수 있다. 또한 그 자체로 하나의 타입이기도 하다. 메서드들의 형태만 정의하고, 구현은 외부에 맡기는 방식으로 유연한 코드를 만들 수 있다.\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Shape interface { Area() float64 Type() } type Rectangle struct { width float64 height float64 } func (r Rectangle) Area() float64 { return r.width * r.height } func (r Rectangle) Type() { fmt.Println(\u0026#34;I\u0026#39;m rectangle\u0026#34;) } type Circle struct { radius float64 } func (c Circle) Area() float64 { return math.Pi * c.radius * c.radius } func (c Circle) Type() { fmt.Println(\u0026#34;I\u0026#39;m circle\u0026#34;) } func main() { rec := []Shape{ Rectangle{width: 10, height: 20}, Circle{radius: 12}, } for _, s := range rec { s.Type() fmt.Println(\u0026#34;Area :\u0026#34;, s.Area()) fmt.Println(\u0026#34;===========\u0026#34;) } } 실행 결과\nI'm rectangle Area : 200 =========== I'm circle Area : 452.3893421169302 =========== 웹 프로그래밍 Go는 특히 MSA모델의 웹 애플리케이션 개발을 잘 지원한다. 기본으로 지원하는 net/http와 gorilla만으로도 훌륭하게 작동하는 웹 애플리케이션 서버를 개발 할 수 있다. 다른 프레임워크를 사용할 필요가 없다. 그리고 성능도 매우 뛰어나다.\n아래는 net/http와 gorilla를 이용해서 만든 간단한 웹 애플리케이션 서버다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; ) func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } func sum(w http.ResponseWriter, r *http.Request) { v := mux.Vars(r) a, _ := strconv.Atoi(v[\u0026#34;a\u0026#34;]) b, _ := strconv.Atoi(v[\u0026#34;b\u0026#34;]) fmt.Fprintf(w, \u0026#34;%d\u0026#34;, a+b) } func main() { h := mux.NewRouter() h.HandleFunc(\u0026#34;/hello\u0026#34;, hello).Methods(\u0026#34;GET\u0026#34;) h.HandleFunc(\u0026#34;/sum/{a}/{b}\u0026#34;, sum).Methods(\u0026#34;GET\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, h) http.ListenAndServe(\u0026#34;:3000\u0026#34;, nil) } 군더더기를 찾아볼 수 없는 단순하고 이해하기 쉬운 코드다.\n유닛테스트 Go언어는 분산환경에 최적화된 측면이 있다. 분산환경에서는 테스트해야 할 기능이 명확하기 때문에 유닛테스트의 효과를 크게 누릴 수 있다. 특히 Go 언어는 Simple is best 철학을 지향하기 때문에, 유닛테스트의 활용이 중요하다. Go가 유닛테스트를 기본으로 제공하는 것도 이런 이유 때문일 것이다.\n유닛 테스트를 위해서 mymath라는 간단한 패키지를 만들었다. 이 코드는 github에서 다운로드 할 수 있다.\npackage mymath import ( \u0026#34;errors\u0026#34; ) var ( StatusDivideZero = errors.New(\u0026#34;Divide zero\u0026#34;) ) func Div(a float64, b float64) (float64, error) { if b == 0 { return 0, StatusDivideZero } return a / b, nil } 아래는 테스트 코드다.\npackage mymath import ( \u0026#34;testing\u0026#34; ) func Test_Div(t *testing.T) { _, err := Div(1, 0) if err != StatusDivideZero { t.Error(\u0026#34;Divide zero\u0026#34;) } v, err := Div(10, 5) if v != 2 { t.Fatal(\u0026#34;10/5 = 2 but \u0026#34;, v) } } go test 명령을 실행하면, 현재 패키지 디렉토리에 있는 파일에서 테스트 코드를 찾아서 실행 한다. 함수의 이름이 Test 로 시작하고 *testing.T 를 매개변수로 사용하면 테스트 함수인 것으로 간주한다.\n# go test PASS ok github.com/yundream/mymath\t0.001s -cover 옵션을 이용하면 테스트 커버리지 레포팅도 할 수 있다.\n# go test -cover PASS coverage: 100.0% of statements ok github.com/yundream/mymath\t0.001s Go는 함수 단위의 유닛 테스트 도구 뿐만 아니라 웹 애플리케이션 서버 단위의 테스트 툴도 제공한다. 직접 웹 서버를 실행해서 핸들러들을 테스트하고 커버리지를 측정하는 식으로 작동한다. 웹 애플리케이션 서버 개발 편에서 자세히 다뤄볼 계획이다.\n문서화 코드 문서화 도구까지 기본 툴로 제공하고 있다.\n마치며 여기에서는 Go 언어의 주요 특징들만 간단하게 살펴봤다. 자세한 내용들은 주제별로 따로 다루도록 하겠다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/content-basic/",
	"title": "시리즈 #2 - 컨텐츠 제작 기초",
	"tags": ["Blog", "Hugo"],
	"description": "Hugo 입문 두번째 시리즈로 컨텐츠 제작과 관련해 꼭 알아야 할 개념들을 소개합니다",
	"content": "컨텐츠 제작 기초 컨텐츠를 제작하면서 꼭 알아야 할 몇가지 개념을 정리하겠습니다.\n컨텐츠의 조직적인 관리 (Organization) 사이트가 많은 양의 컨텐츠를 보유하게 되면서 조직적인 관리가 필요할 때 Hugo가 어떻게 도와주는지 알아 봅시다. 시리즈 1에서 보았 듯이 Hugo의 configuration1에 특별한 세팅이 없는 한 모든 컨텐츠는 content 폴더 안에 위치하게 됩니다. Hugo를 통해 만들어질 사이트의 URL은 content내의 폴더 구조와 매우 밀접한 관계가 있습니다. 우선 content 바로 아래 위치하는 폴더는 section이라고 부르는데 매우 중요한 역활을 합니다. 다음의 예는 section이 사이트 URL과 어떤 상관이 있는지 암시합니다. 만들어진 사이트의 URL경로는 거울을 보듯이 컨텐츠 소스의 경로을 반영합니다.\n. |- content |- post | |- firstpost.md // \u0026lt;- http://1.com/post/firstpost/ | |- happy | | |- ness.md // \u0026lt;- http://1.com/post/happy/ness/ | |- secondpost.md // \u0026lt;- http://1.com/post/secondpost/ |- quote |- first.md // \u0026lt;- http://1.com/quote/first/ |- second.md // \u0026lt;- http://1.com/quote/second/ 그렇다면 컨텐트가 소스의 경로와 다른 URL 경로를 가질 수는 없는 걸까요? 예를 들어,\n 파일 이름 보다 좀 더 의미있는 단어가 URL에 나타나게 할 수는 없는가? section을 다른 이름으로 대체할 수는 없는가? 다른 section에 속한 컨텐트를 서로 조합해서 일관된 URL로 나타나게 할 수는 없는가?  이런 질문들에 대한 답을 얻기 위해서 다음의 개념들을 이해할 필요가 있습니다.\n컨텐트 경로 (Destination) 이미 살펴본 바와 같이 특별한 변수가 없다면 Hugo를 통해 생성된 컨텐트의 경로는 소스파일의 경로에 의해 결정됩니다. 하지만 컨텐트의 경로는 앞으로 살펴볼 정면 변수들(Front Matter)을 통해 다양한 형태로 조정될 수 있습니다. 그럼 Hugo는 컨텐트의 경로를 어떻게 조립하는 것일까요? 우선 몇가지 경로의 부분을 지칭하는 이름을 소개하겠습니다.\npermalink ⊢--------------^-------------⊣ http://spf13.com/projects/hugo baseURL section slug ⊢-----^--------⊣ ⊢--^---⊣ ⊢-^⊣ http://spf13.com/projects/hugo baseURL section slug ⊢-----^--------⊣ ⊢--^--⊣ ⊢--^--⊣ http://spf13.com/extras/indexes/example baseURL path slug ⊢-----^--------⊣ ⊢------^-----⊣ ⊢--^--⊣ http://spf13.com/extras/indexes/example baseURL url ⊢-----^--------⊣ ⊢-----^-----⊣ http://spf13.com/projects/hugo baseURL url ⊢-----^--------⊣ ⊢--------^-----------⊣ http://spf13.com/extras/indexes/example  section 컨텐트 타입의 기본값을 결정합니다.  컨텐트 소스의 위치에 따라 값이 정해집니다. url 정면변수의 값은 section 부분경로를 바꿀 수 있습니다.   slug 확장자를 제외한 컨텐트 소스의 파일 이름으로 정해집니다.  slug 정면변수의 값을 통해 바꿀 수 있습니다.   path section에서 시작하여 slug직전까지의 경로  컨텐트 소스의 경로에 의해 결정됩니다.   url basicURL 다음부터 slug까지 포함된 상대적인 URL  정면변수에 의해 결정될 수 있으며 컨텐트 경로를 결정하는 다른 정면변수의 영향을 무력화 합니다.    slug나 url 정면변수들을 통해 컨텐트의 목적지 경로(Destination)를 부분적으로 수정하거나 전면적으로 교체할 수 있다는 걸 알 수 있습니다. 이제 목적지 경로 변경 기능외에 컨텐트 처리와 HTML변환시 정면 변수들이 어떤 역활을 하는지 알아봅시다.\n정면 변수들(Front Matter) Front Matter는 컨텐트의 메타 데이터라고 할 수 있습니다. 컨텐트보다 먼저 나타난다는 의미로 front matter라는 이름을 지었을 것으로 추측해 봅니다. 시작과 끝을 나타내는 문자열에 따라 여러가지 포맷이 지원됩니다.\n +++로 시작과 끝이 표시되면 TOML을 사용해 Front Matter를 정의할 수 있습니다. ---로 시작과 끝이 표시되면 YAML을 사용해 Front Matter를 정의할 수 있습니다. {로 시작하고 }로 끝이 표시되면 JSON을 사용해 Front Matter를 정의할 수 있습니다.  이 글에서는 TOML의 예만을 살려보도록 하겠습니다.\n+++ date = \u0026quot;2016-08-23T23:25:04-04:00\u0026quot; draft = true title = \u0026quot;시리즈 #2 - 컨텐츠 제작 기초\u0026quot; description = \u0026quot;Hugo 입문 두번째 시리즈로 컨텐츠 제작과 관련해 꼭 알아야 할 개념들을 소개합니다\u0026quot; tags = [\u0026quot;Blog\u0026quot;, \u0026quot;Hugo\u0026quot;] categories = [\u0026quot;How-to\u0026quot;] series = [\u0026quot;Hugo Introduction\u0026quot;] authors = [\u0026quot;Jhonghee Park\u0026quot;] toc = true +++ Front Matter로 정의될 수 있는 변수에 특별한 제약사항은 없습니다. 어떤 변수라도 템플렛안에서 .Params.varname형식으로 접근할 수 있습니다. 템플릿 안에서 변수이름은 항상 소문자로 표현됩니다. 예를 들어 camelCase = true라고 정의된 변수는 템플릿안에서는 .Params.camelcase2로 값을 출력할 수 있습니다. 다음은 컨텐트 제작에 필수적인 변수들입니다.\n title 컨텐트의 제목 description 컨텐트에 대한 설명 date 컨텐츠를 정열할 때 사용할 날짜 taxonomies 항상 복수형으로 표현되는 분류변수로 위의 예제에 나와있는 tags, categories, series, 그리고 authors  이외에 다음과 같은 선택적으로 사용할 수 있는 변수들도 있습니다.\n aliases 하나 이상의 이름들이 나열된 정렬(예를 들면 이름을 바꾼 컨텐트가 과거에 사용했던 URL)로 현재의 컨텐트 URL로 리디랙트 되는 별명들. 자세한 내용은 다음 링크를 참조, Aliases. draft 만약 값이 true이면, 컨텐트는 HTML로 만들어 지지 않습니다. 하지만 \u0026ndash;buildDrafts 플래크를 써서 강제할 수 있습니다. publishdate 만약 날짜가 미래로 잡혀 있으면, 컨텐트는 HTML로 변환되지 않습니다. \u0026ndash;buildFuture 플래그를 써서 강제할 수 있습니다. type 컨텐트 타입 (없는 경우는 컨텐트가 속한 디렉토리를 통해 값이 정해집니다. 즉, type의 기본값은 section을 통해 정해집니다.) isCJKLanguage 값이 true인 경우, 컨텐트를 한중일 언어로 작성된 것으로 간주하고, .Summary와 WordCount와 같은 값들이 한중일 언어에 맞게 생성됩니다. weight 컨텐트의 차례를 정렬하는데 사용됩니다. markup (실험적변수) rst는 reStructuredText (rst2html 툴을 사용합니다) or md (기본값) 은 Markdown slug URL의 말단에 위치하는 토큰(token) url 웹 루트에서 컨텐트까지의 전체 경로.  사이트 개발자의 입장에서 사이트의 기능을 확장하고 컨텐트 제작자에게 그 기능을 조종할 수 있는 인터페이스를 제공하려고 할 때 정면 변수를 유용하게 사용할 수 있습니다. 위에 정면변수 예를 보면, 렌더링된 컨텐트의 상단에 목차를 구현하고 그 기능을 컨텐트 제작시 toc = true를 이용해 나타나게 하는 예가 있습니다. 또 다른 예는 authors를 분류변수(taxonomies)로 등록하고 테마를 통해 구현한 뒤 정면변수의 하나로 컨텐트 제작자에게 자신의 이름을 입력할 수 있게 합니다. 컨텐츠 제작자는 항상 동일한 이름을 사용함으로서 사이트가 제공하는 컨텐츠 목록의 자동 발생을 사용할 수 있습니다.\n지원되는 컨텐트의 포맷 컨텐트 상단에 정면변수들의 정의되고 그 뒤로 컨텐트의 내용이 따라옵니다. Hugo의 컨텐트는 다양한 포맷으로 제작될 수 있습니다. asciidoc, reStructuredText는 외부 프로그램의 도움을 얻어 지원되는 포맷들입니다. 외부 툴에 의존하지 않고 Hugo 자체적으로 컨텐트를 제작할 수 있는 포맷은 Markdown입니다. Markdown을 이용해 새로운 컨텐트를 제작하고 싶으면 hugo new명령에 md확장자를 가지는 파일이름을 사용해 시작할 수 있습니다.\n$ hugo new post/my-first-blog.md 이 명령이 실행되면 Markdown 파일이 만들어 지고 기본적인 정면변수들의 셑업이 이루어 집니다. 이 Scaffolding 과정에서 Hugo는 post라는 archetype을 찾기 위해 테마의 archetypes 폴더나 프로젝트 내 archetypes 폴더안을 검색하고 정면변수들의 기본 셑업을 진행합니다. 만약에 post archetype이 정의되어 있지 않을 때는 Hugo의 기본 값들을 사용합니다.\n컨텐트 타입과 전형 (Content Types and archetypes) 컨텐트 타입은 기본적으로 소스의 위치가 어디에 있느냐에 따라 결정 됩니다. post/my-first-blog.md에 작성된 컨텐트는 정면변수 type이 존재하지 않는 한 post 컨텐트 타입으로 간주되어 타입에 맞는 렌더링이 이루어 집니다. 만약에 전혀 새로운 컨텐트 타입을 도입하고자 하면 어떻게 해야 할까요? 예를 들어 musician이라는 컨텐트 타입을 통해 유명한 음악가들의 소개를 하고자 하는 가정을 합시다. hugo new musician/bach.md로 컨텐트를 초기화 했을때 Hugo의 입장에서는 musician이라는 컨텐트 타입으로 bach.md의 HTML을 렌더링하려고 할 것입니다. musician 컨텐트에 특화된 렌더링을 제공하려면 다음과 같이 새로운 탬플릿을 layouts에 추가해야 합니다.\n 우선 컨텐트 자체의 렌더링을 위해 layouts/musician/single.html을 추가합니다. section 리스트 페이지의 렌더링을 지원하기 위해서는 layouts/section/musician.html을 추가합니다. 음악가의 시대에 따라 조금씩 다른 페이지 뷰(View)를 제공하려면 layouts/musician안에 변형된 템플릿을 추가하고 컨텐트의 정면변수로 layout을 사용해 지정해 줍니다.  템플릿을 준비하면서 musician 컨텐트 타입에 필요한 새로운 정면변수들이 생길 수 있습니다. 저자의 입장에서는 새로운 musician 컨텐트를 hugo new명령으로 발생 시킨 후 첨가된 정면변수들을 일일이 기억해서 입력해야 하는 불편함이 생깁니다. 이런 불편함을 해소하기 위해 musician 컨텐트 타입의 전형(archetype)을 정의해 줄 필요가 있습니다. musician archetype은 archetypes/musician.md를 사용해 정의되고 이 archetype 문서에 필요한 기본값들을 지정해 줄 수 있습니다.\narchetypes/musician.md\n+++ name = \u0026quot;\u0026quot; bio = \u0026quot;\u0026quot; genre = \u0026quot;\u0026quot; +++ 이 archetype을 사용해 새 musician 컨텐트를 만들어 봅시다.\n$ hugo new musician/mozart.md Hugo는 musician 타입을 인지하고 준비된 archetype을 이용하여 정면변수들을 자동으로 입력해 줍니다. content/musician/mozart.md\n+++ title = \u0026quot;mozart\u0026quot; date = \u0026quot;2015-08-24T13:04:37+02:00\u0026quot; name = \u0026quot;\u0026quot; bio = \u0026quot;\u0026quot; genre = \u0026quot;\u0026quot; +++ 컨텐츠 저자의 관점에서 보면 이제 어느 정도 Hugo를 이용해 정적사이트를 건설할 준비가 끝난 셈입니다. 이어지는 시리즈에서는 사이트 개발자의 관점에서 어떻게 새로운 테마를 만들 수 있는지, 정면변수들과 사이트 구성변수(configuration)들이 템플릿안에서 어떻게 접근할 수 있는지를 알아보겠습니다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/go-walkthrough/encoding-package/",
	"title": "Go 둘러보기 - encoding 패키지",
	"tags": ["Golang", "Encoding"],
	"description": "",
	"content": " Go Walkthrough 시리즈의 Go Walkthrough: encoding package를 번역한 글입니다.\n 우리는 이제까지 로우(raw) 바이트 스트림과 제한된 바이트 슬라이스를 다뤄봤지만 단순히 바이트만을 사용하는 애플리케이션은 별로 없다. 바이트 자체는 많은 의미를 전달해주지 않지만 바이트 위에서 데이터 구조를 인코딩 한다면 우리는 진정으로 유용한 애플리케이션을 구축할 수 있다.\n이 포스트는 표준 라이브러리를 이해하는데 도움을 주기위한 Go 둘러보기 시리즈의 일부이다. 기존에 생성된 문서( 자동으로 생성된 Go 문서)는 많은 정보를 제공하지만, 이는 패키지를 실제 상황에서 이해하기에는 어려울 수 있다. 이 시리즈는 일상적으로 사용되는 애플리케이션에서 표준 패키지들이 어떻게 사용되는지에 대한 컨텍스트를 제공할 수 있도록 도와준다. 질문이나 코멘트가 있다면 트위터에서 @benbjohnson로 찾 아오면 된다.\n인코딩이란 정확히 무엇인가? 컴퓨터 과학에서는 간단한 개념에 대한 팬시한 단어들이 있다. 이 뿐만 아니라 많은 경우 하나의 개념을 지칭하는 많은 팬시한 단어들이 존재하기도 한다. 인코딩(Encoding) 은 그 중 하나이다. 가끔 이는 시리얼라이제이션(serialization) 또는 마샬링(marshaling) 으로 불리기도 하며 이는 모두 로우(raw) 바이트에 논리적 구조체를 더한다는 것을 의미한다.\nGo 표준 라이브러리에서, 우리는 두 가지의 분리되었지만 서로 관련이 있는 아이디어를 위해 encoding과 marshaling 라는 용어를 사용한다. Go에서 encoder 는 구조체를 바이트 스트림에 적용하는 객체인 반면 marshaling 은 구조체를 제한된 인메모리 바이트에 적용하는 것을 말한다.\n예를 들면, encoding/json 패키지는 각각의 io.Writer와 io.Reader로 작업을 하기 위한 json.Encoder와 json.Decoder를 가지고있다. 이 패키지는 또한 바이트 슬라이스에 데이터를 쓰고 읽기 위한 json.Marshaler과 json.Unmarshaler를 가지고 있다.\n두 가지 타입의 인코딩 인코딩간에는 또 다른 중요한 차이점이 있다. 몇몇의 인코딩 패키지는 문자열, 정수등의 프리미티브에서 동작한다. 문자열은 아스키나 유니코드 또는 다른 언어별 인코딩과 같은 문자 인코딩을 가지고 인코딩이 된다. 정수는 엔디안(endianness)기반 또는 가변 길이 인코딩에 따라 조금 다르게 인코딩 될 수 있다. 심지어 바이트자체는 종종 출력가능한 문자들로 변환 하기위해 Base64와 같은 방식으로 인코딩된다.\n그러나 우리는 종종 인코딩이라고 하면, 객체 인코딩을 떠올린다. 이는 구조체(structs), 맵(maps), 그리고 슬라이스(slices) 같은 복잡한 구조체들을 바이트열로 변환하는것을 지칭한다. 이런 변환을 하는데 있어선 많은 트레이드 오프가 있으며 오랜 시간에 걸쳐 많은 사람들이 서로 다른 객체 인코딩 방식을 개발해왔다.\n타협(Trade-offs)하기 이 구조체들은 이미 내부적으로 바이트 형태의 인메모리로 표현되기 때문에 처음엔 논리적 구조체를 바이트로 변환하는게 충분히 간단해 보일 수 있다. 그냥 이 포맷을 사용하면 되지 않나?\n왜 Go의 인메모리 포맷이 바이트를 변환해서 디스크에 저장하거나 네트워크를 통해 전송하는데에 적합하지 않은지에 대한 이유는 다양하다. 첫번째로 호환성이다. Go의 내부 데이터 구조 포맷은 Java의 내부 포맷과 맞지 않기에 우리는 서로 다른 시스템간 통신을 할 수가 없다. 가끔 우리는 프로그래밍 언어가 아닌 사람과의 호환성이 필요하다. CSV, JSON, 그리고 XML은 모두 사람이 읽을 수 있는 포맷이며 보거나 수정하기가 쉽다.\n사람이 읽기 가능한 포맷을 만드는것은 트레이드 오프를 이끌어낸다. 사람이 분석하기 쉬운 포맷은 컴퓨터가 분석하기에는 느리다. 정수가 좋은 예이다. 사람은 정수를 10진법으로 읽지만 컴퓨터는 2진법으로 동작한다. 사람은 또한 1또는 1,000과 같은 가변 길이의 숫자를 읽을 수 있지만 컴퓨터는 32비트나 64비트의 정수와 같은 고정 크기의 숫자를 가지고 동작한다. 성능이 숫자 하나에 대해선 별로 차이가 없어 보일 수 있지만 수백만, 수십억개의 숫자를 분석할 때에는 그 차이가 빠르게 벌어진다.\n또한 우리가 처음에 생각하지 않은 다른 트레이드 오프도 있다. 데이터 구조는 시간이 지나면서 변하지만 우리는 여전히 오래전에 인코딩된 바이트 위에서 동작을 시켜야 할 필요가 있다. 프로토콜 버퍼(Protocol Buffers)와 같은 몇몇 인코딩은 여러분의 데이터와 필드의 버전(새로운 필드가 추가될 수 있는 반면, 이전 필드가 더 이상 사용되지 않을 수 있다)에 대한 스키마를 작성할 수 있도록 해준다. 이것의 단점은 객체를 인코딩하고 디코딩 하기위해선 스키마 정의가 필요하다는 것이다. Go의 자체적인 gob 포맷은 다른 방법을 택하는데 실제로 인코딩시 스키마 포맷을 포함한다. 그러나, 이 방법의 단점은 인코딩 사이즈가 매우 커질 수 있다는 것이다.\n일부 포맷은 전적으로 주의를 기울여야 하고 유연한 스키마를 지향한다. JSON과 MessagePack는 여러분이 바로 구조체를 인코딩 하도록 해주지만 기존의 포맷에서 구조체를 안전하게 디코딩 하는것에 대한 보장을 제공해주진 않는다.\n우리는 또한 따로 인코딩을 생각하지 않아도 우리를 위해 인코딩을 대신 수행해주는 시스템을 사용한다. 예를 들면, 데이터베이스는 우리의 논리적 데이터 구조를 가지고 이들을 디스크에 바이트로 영구 저장하는 우회적인 방법이다. 이는 네트워크 호출, SQL 파싱, 그리고 쿼리 계획을 포함 할 수 있지만 이들은 모두 기본적으로 인코딩이다.\n마지막으로, 만약 여러분이 다른 것들보다 정말로 속도가 필요하다면, 데이터 저장을 위해 Go의 내부 포맷을 사용할 수 있다. 심지어 나는 이를 위해 raw라는 라이브러리를 만들기도했다. 이것의 인코딩과 디코딩 시간은 말그대로 0초다. 여러분은 이걸 프로덕션 환경에서 사용해야 하는가? 아마 아닐 것이다.\n4가지 인코딩 인터페이스 만약 여러분이 encoding 패키지를 들여다본 몇 안되는 사람들 중 한 명이라면, 조금 실망했을 것이다. 이는 errors 패키지 다음으로 두번째로 가장 작은 패키지이며 단 4개의 인터페이스만 가지고있다.\n처음에 살펴볼 두 개의 인터페이스는 BinaryMarshaler와 BinaryUnmashaler이다:\ntype BinaryMarshaler interface { MarshalBinary() (data []byte, err error) } type BinaryUnmashaler interface { UnmarshalBinary (data []byte) error }  byte : byte, error : error\n 이들은 객체를 바이너리 포맷으로 변환하거나 역변환하는 방법을 제공한다. 이는 time.Time.MarshalBinary와 같은 표준 라이브러리에서 몇군데 사용된다. 여러분은 이를 많이 보진 못할텐데 보통 객체를 바이너리 포맷으로 마샬링하는 방법이 단일하게 정의되어 있지 않기 때문이다. 보다시피, 수많은 serialization 포맷이 있다.\n그러나, 애플리케이션 레벨에서 여러분은 아마 마샬링을 위해 하나의 포맷만 선택할 것이다. 예를 들면, 여러분은 여러분의 모든 데이터에 대해 프로토콜 버퍼를 선택 했을 수 있다. 일반적으로 애플리케이션 데이터를 위해 여러개의 바이너리 포맷을 지원할 이유가 없으므로 BinaryMarshaler를 구현하는건 의미가 있다.\n다음으로 살펴볼 두 인터페이스는 TextMarshaler와 TextUnmarshaler이다:\ntype TextMarshaler interface { MarshalText() (text []byte, err error) } type TextUnmarshaler interface { UnmarshalText(text []byte) error }  byte : byte, error : error\n 이 두 인터페이스는 출력값이 UTF-8 포맷인걸 제외하고는 바이너리 마샬링 인터페이스와 유사하다.\n몇몇 포맷은 json.Marshaler와 같이 동일한 네이밍 스타일을 따르는 자체적인 마샬링 인터페이스 가지고 있다.\n인코딩 패키지 개요 표준 라이브러리에는 많은 유용한 인코딩 패키지들이 있다. 우리는 이들의 자세한 내용들은 나중 포스트에서 다룰 것이지만 일단 개요를 살펴보고자 한다. 이들 중 몇몇은 encoding 의 서브패키지인 반면 그 외에는 다른 곳에 뿔뿔이 흩어져 있다.\n프리미티브 인코딩 Go를 시작할 때 처음으로 사용하게될 패키지는 아마 fmt 패키지일 것이다. (\u0026ldquo;fumpt\u0026quot;라 발음한다.) 이는 숫자, 문자열, 바이트, 그리고 일부 지원되는 객체 인코딩까지 포함한 것들을 인코딩 및 디코딩 하기 위해 C 스타일의 printf() 컨벤션을 사용한다. fmt 패키지는 템플릿으로부터 사람이 쉽게 읽을 수 있는 문자열을 훌륭하고 쉽게 만들 수 있는 방법을 제공하지만 템플릿 파싱은 추가적인 오버헤드를 발생시킬 수 있다.\n만약 더 나은 성능이 필요하다면 문자열 변환 패키지인 strconv을 사용함으로써 템플레이팅을 피할 수 있다. 이는 기본적인 포맷팅 그리고 문자열, 정수, 실수, 그리고 부울을 위한 스캐닝을 제공하는 로우 레벨 패키지이며 매우 빠르다.\nGo 자체와 함께 이 패키지들은 여러분이 UTF-8의 문자열을 인코딩함을 가정한다. 표준 라이브러리에서 유니코드가 아닌 문자의 인코딩 지원이 미약한건 지난 수년간에 걸쳐 UTF-8의 표준이 인터넷의 많은 부분을 빠르게 지배하고 있기 때문에 가능하거나 Rob Pike가 Go와 UTF-8의 공동개발자이기 때문에 가능한일 일 것이다. 누가 아는가? 나는 운좋게도 여태까지 Go에서 비 UTF-8의 인코딩을 처리할 필요가 전혀 없었다. 그러나, unicode/utf16, encoding/ascii85, 그리고 golang.org/x/text 패키지 트리에 몇가지 인코딩 지원이 있긴하다. \u0026ldquo;x\u0026rdquo; 패키지 트리는 Go 프로젝트의 일부로 엄청난 패키지들을 많이 포함하고 있지만 Go 1 호환성 요건으로는 적용되지 않는다.\n정수 인코딩을 위해, encoding/binary 패키지는 큰 엔디안과 작은 엔디안 인코딩뿐만 아니라 가변 길이의 인코딩도 제공한다. 엔디안이란 바이트가 디스크에 쓰여지는 순서를 가리키는 말이다. 예를 들면, 1,000 (16진법으로는 0x03E8) 의 uint16 표현식은 두 바이트 03 과E8 의 조합으로 이루어진다. 큰 엔디안 인코딩에서는 바이트가 \u0026ldquo;03 E8\u0026quot;의 순서로 쓰여진다. 작은 엔디안에서는 \u0026ldquo;E8 03\u0026quot;으로 순서가 뒤바뀐다. 많은 일반적인 CPU 아키텍처는 작은 엔디안을 사용한다. 그러나, 큰 엔디안은 보통 네트워크를 통해 바이트를 전송할 때 사용된다. 큰 엔디안은 그래서 (네트워크 바이트 순서) network byte order 라고도 한다.\n마지막으로, 바이트 인코딩을 위해 사용할 수 있는 패키지 쌍이 있다. 바이트 인코딩은 보통 바이트를 출력가능한 포맷으로 변환하는데 사용된다. 예를 들면, encoding/hex 패키지는 바이너리 데이터를 16진법으로 볼 필요가 있을때 사용될 수 있다. 나는 개인적으로 디버깅 목적으로만 사용해봤다. 반면, 가끔은 역사적으로 제한된 바이너리 지원 (예로 이메일이 있다.)을 가지고 프로토콜 위에서 데이터를 전송해야하기 때문에 출력가능한 포맷이 필요할 때도 있다. encoding/base32과 encoding/base64 패키지는 이의 한 예이다. 또 다른 예시는 TLS 인증서를 인코딩 하기 위해 사용되는 encoding/pem 패키지가 있다.\n객체 인코딩 우리는 표준 라이브러리에서 객체 인코딩을 위한 몇개의 패키지들을 찾았다. 그러나 실제로 이 패키지들은 우리가 필요로 하는 모든 것들을 가지고 있다.\n만약 여러분이 지난 10년간 세상을 등지고 살아왔다면, 아마 JSON이 인터넷의 기본 객체 인코딩이 되었다는 것을 알아챘을 것이다. 위에서도 언급했듯이, JSON은 결점을 가지고 있지만 사용하기가 쉬우며 모든 언어에서 라이브러리가 지원 되기 때문에 채택이 급증했다. encoding/json 패키지는 이 프로토콜을 위한 훌륭한 지원을 제공하며 ffjson과 같은 빠른 파서를 생성하기 위한 서드파티 구현체들 또한 존재한다.\nJSON이 머신 사이의 프로토콜로서 지배하고 있는 동안, CSV 포맷은 사람들에게 데이터를 내보내기 위한 더 일반적인 프로토콜이다. encoding/csv 패키지는 테이블 형식의 데이터를 이 포맷으로 내보내기 위한 좋은 인터페이스를 제공한다.\n만약 여러분이 약 2000년경에 구축된 시스템과 상호 작용을 하는 경우엔 아마 XML을 사용해야 할 것이다. encoding/xml 패키지는 json 패키지와 유사한 추가적인 태그 기반 marshaler/unmarshaler를 가진 SAX 스타일의 인터페이스를 제공한다. 만약 DOM, XPath, XSD, 또는 XSLT같은 좀 더 복잡한 기능들을 찾고 있다면 아마 cgo를 통한 libxml2을 사용해야 할 것이다.\nGo는 또한 gob라고 하는 자체적인 스트림 인코딩을 가지고 있다. 이 패키지는 두 Go 서비스간의 원격 프로시저 호출을 구현하기 위한 net/rpc 패키지에의해 사용된다. Gob은 사용하기가 쉽다. 그러나 이는 그 어떤 언어 크로스도 지원하지 않는다. 만약 서로 다른 언어간 통신이 필요하다면 gRPC가 인기있는 대안이 될 수 있을 것 같다.\n마지막으로, encding/asn1라는 패키지가 있다. 문서에는 제한된 정보만 있고 패키지에는 오직 25페이지의 텍스트로 이루어진 layman의 ANS.1 가이드에 대한 링크만 있다. ANS.1은 특히 SSL/TLS의 X.509 인증서에 많이 사용되는 복잡한 객체 인코딩 스키마이다.\n결론 인코딩은 바이트 위에서 정보를 레이어링 하기위한 기초적인 기반을 제공한다. 이게 없다면 우린 문자열이나 데이터 구조나 데이터베이스 또는 그 어떤 유용한 애플리케이션도 가질 수 없을 것이다. 상대적으로 간단한 개념처럼 보이는것이 많은 구현의 역사와 다양한 트레이드 오프를 가지고 있다.\n이 포스트에서 우리는 표준 라이브러리에 있는 다양한 인코딩 구현의 개요와 그것들의 트레이드 오프들을 살펴봤다. 우리는 이러한 프리미티브와 객체 인코딩 패키지가 우리의 바이트 스트림과 슬라이스의 지식선상에서 어떻게 구현되는지를 보았다. 다음 몇 개의 포스트에선 실제 상황에서 이들을 어떻게 사용할 수 있는지를 알아보기 위해 이 패키지들을 좀 더 깊이 파헤쳐 볼 것이다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/go-start/object-oriented/",
	"title": "Go와 객체지향",
	"tags": ["Object Oriented", "struct"],
	"description": "",
	"content": "객체지향 프로그래밍 Go는 클래스(Class)가 없다!! Struct가 Class의 역할을 수행 할 수 있기는 하지만 메서드도 구조체로부터 분리되는 구성을 가지고 있다. 단일 상속도 없고 당연히 다중 상속도 없다. 왠지 객체지향스럽지 않은 언어로 보일 수 있겠지만 충분히 객체지향적이다. 그냥 좀 다른 방법으로 객체를 지향하고 있을 따름이다.\n struct가 클래스를 대신한다. 다른 OOP에서의 클래스와는 달리 non-virtual(real) 메서드로만 구성된다. receiver로 구조체와 함수를 연결 해서 메서드를 구현한다. 네임스페이스(namespacing)는 exports로 대신한다. 인터페이스(interfaces)로 다형성을 구현할 수 있다. 다른 OOP에서는 필드 없이, virtual 메서드로만 구성된 클래스 형태로 구현된다. embedding으로 상속을 대신한다. 객체지향의 composition 모델과 비슷하다. Go 언어를 이용한 객체지향 프로그래밍 기술에 대해서 살펴보자.  struct(구조체)와 메서드 Go언어는 struct가 class 키워드를 대신한다. class와의 눈에 보이는 차이점은 real 타입(non-virtual)의 메서드만 올 수 있다는 점이다. Area 메서드를 가지는 Rectangle 구조체는 아래와 같이 만들 수 있다.\ntype Rectangle struct { Name string Width, Height float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } class 키워드를 가지고 있는 객체지향 언어의 경우 아래와 같은 의사코드로 표현할 것이다.\nclass Rectangle field Name: string field Width: float64 field Height: float64 method Area() return this.Width * this.Height Go는 구조체 내에 메서드를 포함 할 수 없다. 구조체 바깥에 만들어지며, **리시버(receiver)**를 이용해서 어느 구조체의 메서드인지를 정의 할 수 있다. 아래 그림은 리시버를 이용해서 구조체와 함수가 연결되는 과정을 묘사하고 있다.\n리시버는 Value 리시버와 포인터 리시버 두 가지 타입이 있다. 아래 코드를 보자.\npackage main import \u0026#34;fmt\u0026#34; type Mutatable struct { a int b int } func (m Mutatable) StayTheSame() { m.a = 5 m.b = 7 } func (m *Mutatable) Mutate() { m.a = 5 m.b = 7 } func main() { m := \u0026amp;Mutatable{0, 0} fmt.Println(m) m.StayTheSame() fmt.Println(m) m.Mutate() fmt.Println(m) } 코드 실행\nStayTheSame은 Value 리시버이고 Mutate는 포인터 리시버다. 포인터 리시버의 경우 구조체의 필드 값을 변경(Mutate)하는 반면 Value 리시버는 스트럭처의 값을 변경하지 않는다. Mutate 하느냐 하지 않느냐가 Value 리시버와 포인터 리시버의 눈에 보이는 차이다. 포인터라는게 데이터가 저장된 주소를 가리킨다는 것을 생각해보면, 포인터 리시버의 Mutate 한 성질을 유추 할 수 있을 것이다.\n이제 구조체로 부터 객체를 만들어 보자. 몇 가지 방법이 있는데, 첫 번째 방법은 패키지에 객체를 반환하는 New 같은 함수를 만드는 것이다. **빌더 패턴(builder pattern)**의 응용이다.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Rectangle struct { Name string Width, Height float64 } // Rectangle 를 반환하는 함수를 만들었다. func New(name string) *Rectangle { return \u0026amp;Rectangle{Name: name} } func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r *Rectangle) SetWidth(width float64) { r.Width = width } func (r *Rectangle) SetHeight(height float64) { r.Height = height } func main() { myRectangle := New(\u0026#34;Rect-A\u0026#34;) // 출력 : 0  fmt.Println(myRectangle.Area()) myRectangle.SetWidth(52.2) myRectangle.SetHeight(30.3) // 출력 : 1581.66  fmt.Println(myRectangle.Area()) } 코드 실행\nNew() 함수를 실행해서 Rectangle 객체를 만들었다.\n두 번째로 구조체의 초기화 문법을 이용해서 직접 객체를 만드는 방법이 있다.\nfunc main() { yourRectangle := Rectangle{} myRectangle := Rectangle{Name:\u0026#34;Rect-A\u0026#34;, Width:12.5, Height:13.5} } 구조체 초기화 문법을 이용 하면, 필드의 값을 초기화 할 수 있다. 초기화 하지 않는 필드들은 **기본 값(zero-value)**으로 초기화 된다. float64는 0, string은 \u0026ldquo;\u0026quot;, 포인터는 nil로 초기화 된다. 예를 들어서 위 코드의 yourRectangle의 경우 Height와 Width가 0으로 초기화 되기 때문에 yourRectangle.Area()는 0을 반환 할 것이다.\n마지막으로 Go의 new()내장 함수를 이용하는 방법이 있다.\nfunc new(Type) *Type new 함수를 호출하고 나면, 메모리를 할당하고 포인터를 반환한다. 필드의 값들은 기본 값으로 초기화 된다. c++의 new와 사용방법이 비슷하다.\nfunc main() { myRectangle := new(Rectangle) // 출력 : 0  fmt.Println(myRectangle.Area()) myRectangle.SetWidth(52.2) myRectangle.SetHeight(30.3) // 출력 : 1581.66  fmt.Println(myRectangle.Area()) } Go 언어는 생성자가 없다. 하지만 팩토리 패턴(factory pattern)을 이용해서 구현 할 수 있다. 예제에서 다루었던 **New()**함수가 팩토리 패턴을 이용하고 있다. 아래와 같이 수정해서 생성자를 구현했다.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Rectangle struct { Name string Width, Height float64 } // 팩토리 패턴을 이용 생성자를 구현했다. func New(name string, width float64, height float64) *Rectangle { return \u0026amp;Rectangle{Name: name, Width: width, Height: height} } func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r *Rectangle) SetWidth(width float64) { r.Width = width } func (r *Rectangle) SetHeight(height float64) { r.Height = height } func main() { myRectangle := New(\u0026#34;Rect-A\u0026#34;, 12.3, 10.9) fmt.Println(myRectangle.Area()) myRectangle.SetWidth(52.2) myRectangle.SetHeight(30.3) fmt.Println(myRectangle.Area()) } 코드 실행\n혹은 **Rectangle{Width:11, Height:12}**와 같은 초기화 문법을 이용하면 된다.\nExports Go언어는 패키지로 네임스페이스를 구현하고 있다. 그리고 대문자로 시작하는지에 따라서 export 여부가 결정된다. 소문자로 시작할 경우 패키지 안에서만 사용 할 수 있고, 대문자로 사용 할 경우 패키지 바깥에서 사용 할 수 있다.\ntype Part struct { name string description string needsSpare bool } 이제 아래와 같이 export setter과 getter 메서드를 만들 수 있다.\nfunc (p Part)Name string { return part.name } func (part *Part) SetName(name string) { part.name = name } 이렇게 대/소문자만으로 public 메서드와 private(internal 필드 혹은 메서드)를 결정 할 수 있다.\n상속(Inheritance)과 composition 객체지향 디자인은 클래스 간의 관계를 구성하는 것에서 시작한다. 클래스간의 관계는 **상속(Inheritance)**과 컴포지션(composition) 두 가지 방법으로 구성 할 수 있다.\n상속은 아래 처럼 묘사 할 수 있다.\n이 그림은 원형 클래스의 특징을 물려 받은 하위 원형 클래스를 만들 겠다라는 의미를 내포하고 있다. 이때 상위 클래스를 부모 클래스, 하위 클래스를 자식 클래스라고 부른다. 이렇게 **계층적(hierarchy)**으로 클래스 간에 관계를 구성하는 방법은 다른 분야에서도 널리 사용한다. 생물학 시간에 배웠을 종 \u0026gt; 속 \u0026gt; 과 \u0026gt; 목 \u0026gt; 강 \u0026gt; 문 \u0026gt; 계가 전형적인 형태다.\n컴포지션은 부모클래스를 호출해서 포함 하는, 즉 embedding하는 방식으로 클래스 관계를 구성한다. 다중 상속의 경우 composition 모델은 두 개 이상의 부모 클래스를 embedding 하면 된다. 상속은 IS - A Relationship, 컴포지션은 Has a Relationship 으로 그 관계를 묘사 할 수 있다. 아래 그림은 composition 모델을 그리고 있다.\nMountainBike, RoadBike, TandemBike가 Bicycle 스크럭처를 embedding 하는 방식으로 클래스 관계를 구성한 코드다.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Bicycle struct { } func (b Bicycle) Spare() { fmt.Println(\u0026#34;Bicycle\u0026#39;s Spare\u0026#34;) } func (b Bicycle) Run() { fmt.Println(\u0026#34;Bicycle Run\u0026#34;) } type MountainBike struct { Bicycle } func (m MountainBike) Run() { fmt.Println(\u0026#34;Mountain Bicycle Run\u0026#34;) } func (m MountainBike) Jump() { fmt.Println(\u0026#34;Mountain Bicycle Jump\u0026#34;) } type RoadBike struct { Bicycle } func main() { rBike := RoadBike{} rBike.Run() mBike := MountainBike{} mBike.Run() mBike.Jump() } 코드 실행\nMountainBike 구조체와 RoadBike 구조체에 Bicycle 구조체를 embeded 했다. Bicycle 구조체의 메서드들을 마치 자신의 메서드인 것처럼 사용 할 수 있으며, 오버라이딩도 할 수 있다.\n이제 Multiple embedding을 이용해서 다중 상속을 구현해 보자.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Phone struct { Model string } func (p Phone) Call(num string) { fmt.Println(\u0026#34;Ring Ring....\u0026#34;, num) } type Camera struct { Model string } func (p Camera) TakePicture() { fmt.Println(\u0026#34;Click ....\u0026#34;) } type SmartPhone struct { Phone Camera } func main() { myPhone := SmartPhone{} myPhone.TakePicture() myPhone.Call(\u0026#34;101-1111-2222\u0026#34;) fmt.Println(\u0026#34;=================\u0026#34;) yourPhone := SmartPhone{} yourPhone.Call(\u0026#34;201-2222-1111\u0026#34;) } Camera와 Phone의 기능을 가진(상속받은) SmartPhone 구조체를 만들었다. 그냥 embeded 한 것으로 상속의 주요 기능들을 구현했다. 이제 코드를 약간 수정해서 Phone과 Camera에 모델명을 설정해 보자.\nfunc main() { myPhone := SmartPhone{ Phone: Phone{Model: \u0026#34;ioph-0001\u0026#34;}, Camera: Camera{Model: \u0026#34;huca-0002\u0026#34;}, } fmt.Println(myPhone.Model) } 실행하면 \u0026ldquo;ambiguous selector myPhone.Model\u0026quot;에러가 출력된다. 어느 구조체의 Model을 선택해야 할지 모호(ambiguous)해서 생기는 문제다. 셀렉터(selector)를 설정하면 된다. SmartPhone.Model 까지 추가한 완전한 예제다.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Phone struct { Model string } func (p Phone) Call(num string) { fmt.Println(\u0026#34;Ring Ring....\u0026#34;, num) } type Camera struct { Model string } func (p Camera) TakePicture() { fmt.Println(\u0026#34;Click ....\u0026#34;) } type SmartPhone struct { Model string Phone Camera } func main() { myPhone := SmartPhone{ Model: \u0026#34;Android-007\u0026#34;, Phone: Phone{Model: \u0026#34;ioph-0001\u0026#34;}, Camera: Camera{Model: \u0026#34;huca-0002\u0026#34;}, } fmt.Println(myPhone.Model) fmt.Println(myPhone.Phone.Model) fmt.Println(myPhone.Camera.Model) yourPhone := SmartPhone{ Model: \u0026#34;iphone-8\u0026#34;, Phone: Phone{Model: \u0026#34;Lxg-0001\u0026#34;}, Camera: Camera{Model: \u0026#34;Apppll-0002\u0026#34;}, } fmt.Println(yourPhone.Model) fmt.Println(yourPhone.Phone.Model) fmt.Println(yourPhone.Camera.Model) } 코드 실행\n다중 상속과 다이아몬드 문제 다중 상속은 직관적이고 사용하기 편하지만 죽음의 다이아몬드라는 골치아픈 문제가 있기 때문에, 별로 권장하지 않는다. 아래 그림을 보자.\nAnimal로 부터 Tiger과 Lion 클래스가 파생됐다. 그리고 다중 상속을 이용해서 Tiger과 Lion으로 부터 파생된 Liger 클래스가 있다. Liger 객체에서 getWeight()를 호출 할 경우 어느 클래스의 getWeight()를 호출해야 할지 모호 하므로 컴파일 실패한다.\nGo언어는 selector를 이용해서 네임스페이스를 설정하는 것으로 문제를 피해갈 수 있다. 아래 예제를 보자.\npackage main import ( \u0026#34;fmt\u0026#34; ) type Animal struct { } func (a Animal) GetGene() { fmt.Println(\u0026#34;동물 유전자\u0026#34;) } type Tiger struct { Animal } func (t Tiger) GetGene() { fmt.Println(\u0026#34;호랑이 유전자\u0026#34;) } type Lion struct { Animal } func (l Lion) GetGene() { fmt.Println(\u0026#34;사자 유전자\u0026#34;) } type Liger struct { Tiger Lion } func main() { fmt.Println(\u0026#34;유전자 정보\u0026#34;) myLiger := Liger{} myLiger.Tiger.GetGene() myLiger.Lion.GetGene() myLiger.Lion.Animal.GetGene() } 코드 실행\n셀렉터를 이용 해서 모호함을 없애고 있다.\nStructs와 Interface Go의 구조체는 non-virtual 메서드만 가질 수 있다. 가상 메서드(virtual method)를 만들려면 interface를 이용해야 한다. Go에서 interface는 오로지 가상 메서드로만 구성 할 수 있다. 아래 Go interface의 특징을 정리했다.\n interface는 하나의 타입으로 변수(var)와 매개변수(parameter)로 쓸 수 있다. interface의 구현은 concret class(struct)에서 이루어진다. concret class는 구상 클래스라고 번역한다. interface는 다른 interface에 상속(embed)할 수 있다.  인터페이스 응용 예제 코드를 만들어 보자.\n나는 범용 위키애플리케이션을 만들려고 한다. 이 애플리케이션은 MediaWiki의 문법뿐만 아니라 마크다운(MarkDown) 문법도 처리를 할 수 있어야 한다. 필요 할 경우 모니위키(Moniwiki) 등 다른 위키 문법들까지 처리 할 수 있게 만들려고 한다. 플러그인 방식으로 확장을 하게 될테다.\n나는 Wiki interface를 만들고, 위키문서를 HTML로 변환하기 위한 **Parser()**메서드를 등록했다. 개발자는 새로운 위키 파서가 필요할 경우 구조체를 만들고 Parser() 메서드만 만들면 된다.\npackage main import \u0026#34;fmt\u0026#34; // Interface를 만들었다. type Wiki interface { Parser(string) string } // MediaWiki 엔진 구현을 위한 구조체 type MediaWiki struct { Type string } // MediaWiki 파서 실제 구현 func (m MediaWiki) Parser(a string) string { return \u0026#34;Moniwiki \u0026#34; + a } // 마크다운 엔진 구현을 위한 구조체 type MarkDown struct { Type string } // 마크다운 파서 실제 구현 func (m MarkDown) Parser(a string) string { return \u0026#34;Markdown \u0026#34; + a } func main() { md := MarkDown{Type: \u0026#34;MarkDown\u0026#34;} me := MediaWiki{Type: \u0026#34;MoniWiki\u0026#34;} // 위키엔진 저장을 위한 map 자료구조를 만들었다.  WikiEngine := make(map[string]Wiki, 2) WikiEngine[\u0026#34;markdown\u0026#34;] = md WikiEngine[\u0026#34;mediawiki\u0026#34;] = me // MarkDown과 MediaWiki는 서로다른 구조체다.  // 하지만 Wiki interface로 서로 연결이 됐다.  for _, value := range WikiEngine { fmt.Println(value.Parser(\u0026#34;Text Data\u0026#34;)) } } 실제 위키엔진 구현이라면 설정으로 위키 엔진 정보를 읽어온 다음, 맵에 저장할 것이다. 그 후 문서의 타입에 따라서 적당한 Parser()메서드를 호출할 것이다. interface를 이용하면, 같은 이름의 메서드라고 하더라도 다른 구현을 할 수 있다. 즉 객체지향의 다형성을 구현할 수 있다.\nempty interface Go의 interface는 가상 메서드만 가진다고 했다. 가상 메서드도 가지지 않으면 **빈 인터페이스(empty interface: \u0026ldquo;interface{}\u0026quot;)**가 된다. 흔히 빈 인터페이스는 어떠한 타입이라도 사용 할 수 있다라고 생각하곤 하는데, 그렇지 않다. 빈 인터페이스에는 인터페이스 타입을 사용해야 한다. 아래 코드를 보자.\nfunc DoSomething(v interface{}) { // ... } DoSomething는 빈 인터페이스 타입인 v를 매개변수로 취하고 있다. 여기에 인터페이스 타입의 값을 넘기면, Go언어는 런타임에 형 변환(Type conversion - 언제나 가능한 건 아니다)을 한 후, 정적 타입의 값으로 변경해서 넘긴다. 아래 예제를 보자.\npackage main import ( \u0026#34;fmt\u0026#34; ) func PrintAll(vals []interface{}) { for _, val := range vals { fmt.Println(val) } } func main() { names := []string{\u0026#34;stanley\u0026#34;, \u0026#34;david\u0026#34;, \u0026#34;oscar\u0026#34;} PrintAll(names) } 코드 실행\n코드를 실행하려 하면 main.go:15: cannot use names (type []string) as type []interface {} in argument to PrintAll 에러가 떨어진다. 타입이 맞지 않기 때문이다. 아래와 같이 타입을 맞춰줘야 한다.\npackage main import ( \u0026#34;fmt\u0026#34; ) func PrintAll(vals []interface{}) { for _, val := range vals { fmt.Println(val) } } func main() { names := []string{\u0026#34;stanley\u0026#34;, \u0026#34;david\u0026#34;, \u0026#34;oscar\u0026#34;} vals := make([]interface{}, len(names)) for i, v := range names { vals[i] = v } PrintAll(vals) age := []int{38, 27, 42} vals = make([]interface{}, len(age)) for i, v := range age { vals[i] = v } PrintAll(vals) } 코드 실행\n빈 인터페이스를 적절하게 사용하는 메서드로 fmt.Printf가 있다. Printf 메서드는 다양한 타입의 값을 매개변수로 받아서 처리해야 하는데 이 때 빈 인터페이스를 사용한다.\nfunc Printf(format string, a ...interface{}) (n int, err error) 빈 인터페이스를 이용해서 하나의 메서드로 여러 데이터를 처리하는 예제 코드다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) type Stringer interface { String() string } func ToString(any interface{}) string { if v, ok := any.(Stringer); ok { return v.String() } switch v := any.(type) { case int: return strconv.Itoa(v) case float64: return strconv.FormatFloat(v, \u0026#39;f\u0026#39;, 4, 64) } return \u0026#34;???\u0026#34; } type User struct { Name string } func (u User) String() string { return u.Name } func main() { fmt.Println(ToString(1234)) fmt.Println(ToString(17.4)) fmt.Println(ToString(\u0026#34;Hello World\u0026#34;)) fmt.Println(ToString(User{\u0026#34;yundream\u0026#34;})) } 코드 실행\n매개변수로 넘어온 (빈 인터페이스 타입의)데이터를 연산하기 위해서는, 데이터의 타입을 알아야 한다. **reflect.TypeOf()**혹은 type assertions를 이용해서 데이터 타입을 알 수 있다. 예제 코드에서는 type assertion(any.(type))을 이용하고 있다.\n참고  golang oop How to use interfaces in go  "
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part3/",
	"title": "Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치",
	"tags": ["Golang", "Internals", "linker", "object file", "relocations"],
	"description": "",
	"content": "오늘은 Go 링커와 오브젝트 파일, 그리고 재배치(relocations)에 대해 얘기해 보자.\n이런 것들이 독자들과 무슨 상관이 있을까? 만약 독자가 어떤 대형 프로젝트의 내부에 대해 배우고자 한다면, 첫번째 할 일이 그 것을 콤포넌트나 모듈로 자를 필요가 있다. 둘째로 이 모듈들이 서로에게 어떤 인터페이스를 제공하는지 이해할 필요가 있다. Go 언어 프로젝트의 경우, 이런 상위 모듈들이 컴파일러, 링커, 그리고 런타임이다. 컴파일러가 제공하고 링커가 사용하는 것이 오프젝트 파일인데, 오늘은 그 것으로 조사를 시작해 보자.\nGo 오브젝트 파일 생성하기 실용적인 실험을 하나 해 보자-아주 간단한 프로그램을 하나 만들고, 컴파일하고, 어떤 오브젝트 파일이 만들어 지는지 관찰하자. 저자의 경우, 프로그램은 다음과 같다:\n  1: package main 2: 3: func main() { 4: print(1) 5: }\n 너무 쉽지 않은가? 이제 컴파일을 한다: \u0026gt;``` go tool 6g test.go 이 명령은 test.6 오브젝트 파일을 생산한다. 이 파일의 내부 구조를 조사하기 위해, goobj 라이브러리를 사용하겠다. 이 라이브러리는 내부적으로 Go 소스 코드에 채택되어 주로 유닛 테스트를 구현하는데 쓰인다. 이 유닛 테스트는 여러 상황에서 오브젝트 파일이 정확히 생성되었는지를 테스트한다. 이 블로그 포스트를 위해 goobj 라이브러리를 통해 생성된 출력을 콘솔로 프린트하는 매우 간단한 프로그램을 만들었다. 이 프로그램의 소스코드는 여기에서 살펴볼 수 있다.\n무엇보다도 우선, 저자의 프로그램을 다운받아 설치해야 한다:\n  go get github.com/s-matyukevich/goobj_explorer\n 그런 후에 다음의 명령을 실행하라: \u0026gt;``` goobj_explorer -o test.6 이제 goob.Package 구조를 콘솔안에서 살펴 볼 수 있을 것이다.\n오브젝트 파일 조사하기 이 오브젝트 파일에서 가장 흥미로운 부분은 Syms 배열이다. 이것은 실제로 심볼 테이블이다. 프로그램안에 정의된 모든 것들, 함수, 전역 변수, 타입, 상수, 등이 이 테이블에 적혀있다. main 함수에 상응하는 엔트리에 대해 살펴보자. (Roloc 과 Func 필드는 출력에서 생략되었음을 주목하라. 이 필드들은 나중에 논하겠다.)\n  \u0026amp;goobj.Sym{ SymID: goobj.SymID{Name:\u0026ldquo;main.main\u0026rdquo;, Version:0}, Kind: 1, DupOK: false, Size: 48, Type: goobj.SymID{}, Data: goobj.Data{Offset:137, Size:44}, Reloc: \u0026hellip;, Func: \u0026hellip;, }\n *goobj.Sum* 구조내 필드의 이름들은 따로 설명이 필요 없다: \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt;\u0026lt;!-- .myTable { background-color:white;border-collapse:collapse; } .myTable th { background-color:#E0E0E0;color:black; } .myTable td, .myTable th { padding:5px;border:1px solid #989898; } --\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;table class=\u0026quot;myTable\u0026quot;\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\u0026lt;center\u0026gt;필드\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;width: 530px;\u0026quot; width=\u0026quot;70%\u0026quot;\u0026gt;\u0026lt;center\u0026gt;설명\u0026lt;/center\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;SumID\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;독특한 심볼 아이디로 심볼의 이름과 버전으로 구성된다. 버전을 통해 동일한 이름에 차이를 부여한다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Kind\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;어떤 종류의 심볼에 속하는지를 나타낸다 (상세한 내용은 나중에).\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;DupOK\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;이 필드는 중복된 이름(같은 이름의 심볼들)이 허락되는지를 나타낸다.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Size\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;심볼 데이터의 크기.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Type\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;만약 있는 경우, 심볼 타입을 대표하는 또 다른 심볼에 대한 레퍼런스.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Data\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;바이너리 데이터를 가진다. 다른 종류의 심볼에 따라 다른 의미를 갖고 있다. 예를 들어, 함수에는 어셈블리 코드를, 문자열 심볼에는 원자재 문자열 콘텐트, 기타 등등.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Reloc\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;재배치 리스트 (더 상세한 내용은 나중에 제공될 것이다.)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;Func\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;함수 심볼에 대한 특별한 함수 메타 데이터를 갖고 있다. (자세한 내용은 아래를 보라).\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 이제, 다른 종류의 심볼들을 살펴보자. 모든 사용 가능한 종류의 심볼들이 상수로서 *goobj* 패키지 ([여기](https://github.com/golang/go/blob/master/src/cmd/internal/goobj/read.go#L30))에서 찾아 볼수 있)안에 정의되어 있다. 아래에, 이러한 상수들의 첫번째 부분을 복사해 놓았다: \u0026gt;``` const ( _ SymKind = iota // readonly, executable STEXT SELFRXSECT // readonly, non-executable STYPE SSTRING SGOSTRING SGOFUNC SRODATA SFUNCTAB STYPELINK SSYMTAB // TODO: move to unmapped section SPCLNTAB SELFROSECT ... 보다시피, main.main 심볼은 종류 1에 속하고 STEXT 상수에 상응한다. STEXT 는 실행 가능한 코드를 갖는 심볼이다. 이제, Reloc 배열을 살펴보자. 다음과 같은 struct들로 구성되어 있다:\n  type Reloc struct { Offset int Size int Sym SymID Add int Type int }\n 각 재배치는 *[Offset, Offset+Size]* 간격에 위치한 바이트들이 특정 주소로 교체되어야 함을 암시한다. 이 주소는 *Sym* 심볼의 위치에 *Add* 바이트 숫자를 더하여 계산된다. # 재배치 이해하기 이제 예를 통해 재배치가 어떻게 작동하는지를 알아보자. 그러기 위해서, *-S* 스위치를 이용해 프로그램을 컴파일 할 필요가 있다. *-s* 스위치는 생성된 어셈블리 코드를 출력할 것이다: \u0026gt;``` go tool 6g -S test.go 어셈블러를 들여다 보면서 main 함수를 찾아보자.\n  \u0026ldquo;\u0026quot;.main t=1 size=48 value=0 args=0x0 locals=0x8 0x0000 00000 (test.go:3)\tTEXT\t\u0026ldquo;\u0026quot;.main+0(SB),$8-0 0x0000 00000 (test.go:3)\tMOVQ\t(TLS),CX 0x0009 00009 (test.go:3)\tCMPQ\tSP,16(CX) 0x000d 00013 (test.go:3)\tJHI\t,22 0x000f 00015 (test.go:3)\tCALL\t,runtime.morestack_noctxt(SB) 0x0014 00020 (test.go:3)\tJMP\t,0 0x0016 00022 (test.go:3)\tSUBQ\t$8,SP 0x001a 00026 (test.go:3)\tFUNCDATA\t$0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB) 0x001a 00026 (test.go:3)\tFUNCDATA\t$1,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB) 0x001a 00026 (test.go:4)\tMOVQ\t$1,(SP) 0x0022 00034 (test.go:4)\tPCDATA\t$0,$0 0x0022 00034 (test.go:4)\tCALL\t,runtime.printint(SB) 0x0027 00039 (test.go:5)\tADDQ\t$8,SP 0x002b 00043 (test.go:5)\tRET\t,\n 나중에 올 블로그 포스트에서 이 코드에 대해 더 자세히 살펴보며 Go의 런타임이 어떻게 작동하는지를 이해하기 위한 시도들 할 것이다. 지금은 다음 한줄에 관심이 있다: \u0026gt;``` 0x0022 00034 (test.go:4)\tCALL\t,runtime.printint(SB) 이 명령은 함수 데이터내 (16진수로는) 0x0022의 오프셋 이나 (10진수로는) 00034 오프셋에 위치한다. 이 줄은 실제로 runtime.printint 함수를 호출하는 책임을 진다. 문제는 컴파일러가 컴파일이 진행되는 동안 runtime.printint 함수의 정확한 주소를 모른다는 것이다. 이 함수는 컴파일러가 전혀 모르는 다른 오브젝트 파일내에 위치한다. 그런 경우, 컴파일러는 재배치를 사용한다. 아래는 이 메서드 호출에 상응하는 정확한 재배치이다. (저자가 goobj_explorer 유틸리티의 첫번째 출력에서 복사해 왔다.):\n  { Offset: 35, Size: 4, Sym: goobj.SymID{Name:\u0026ldquo;runtime.printint\u0026rdquo;, Version:0}, Add: 0, Type: 3, },\n 이 재배치는 링커에게 35 바이트의 오프셋에서 시작하면서, 4 바이트의 데이터를 *runtime.printint* 심볼의 시작점 주소로 교체할 필요가 있다고 말한다. 하지만 메인 함수 데이터로 부터 35 바이트의 오프셋는 실제로 이전에 본적이 있는 호출 명령(call instruction)의 인수이다. (이 (호출) 명령은 34 바이트의 오프셋에서 시작한다. 1 바이트는 호출 명령 코드이고 4 바이트는 이 명령의 주소를 가리킨다.) # 링커는 어떻게 작동하는가 이제 위의 설명을 이해한다면, 링커가 어떻게 작동하는 지를 알아낼 수 있다. 다음의 개요는 매우 단순화 시킨 것이긴 하지만 주요한 아이디어를 반영한다: * 링커는 메인 패키지로 부터 참조된 모든 패키지의 심볼을 모아서 하나의 긴 바이트 배열(혹은 바이너리 이미지)에 실는다. * 각 심볼에 대해서는, 링커가 이러한 이미지내의 주소를 계산한다. * 그런다음, 모든 심볼에 대해 정의된 재배치를 적용한다. 링커가 그런 재배치에서 참조된 모든 다른 심볼들의 정확한 주소들들 알고 있기 때문에 매우 쉬운 일이다. * 링커는 (리눅스의) Executable and Linkable (ELF) 포맷이나 (윈도우의) Portable Executable (PE) 포맷에 필요한 모든 헤더를 준비한다. 그런 다음, 그 결과물로 링커는 실행파일을 발생시킨다. # TLS 이해하기 조심성 있는 독자는 main 메서드에 대해 *goobj_explorer* 유틸리티 출력속에 이상한 재배치가 있음을 알아챌 것이다. 어떤 메서드 호출에도 상응하지 않고 심지어 빈 심볼을 가리키고 있다: \u0026gt;``` { Offset: 5, Size: 4, Sym: goobj.SymID{}, Add: 0, Type: 9, }, 과연, 이 재배치가 하는 것이 무엇일까? 5 바이트의 오프셋을 가지고 있고 크기가 4 바이트임을 알 수 있다. 이 오프셋에는 다음 명령이 있다:\n  0x0000 00000 (test.go:3)\tMOVQ\t(TLS),CX\n 0 오프셋에서 시작하고 9 바이트을 차지한다 (다음 명령이 9 바이트 오프셋애서 시작하는 걸로 알 수 있다). 추측컨대, 이 재배치는 낯선 *(TLS)* 구문을 어떤 주소로 교체한다. 그러면 TLS는 무엇이며, 무슨 주소를 사용하는가? TLS는 쓰레드 지역 저장 공간(Thread Local Storage)의 축약형이다. 이 기술은 많은 프로그래밍 언어에 사용되었는데 상세한 내용은 [여기](https://en.wikipedia.org/wiki/Thread-local_storage)를 참조하라. 간단하게 설명하면, 다른 쓰레드에 의해 사용될 때, 다른 메모리 장소를 가리키는 변수의 사용을 가능하게 한다. Go 언어에서 TLS는 *G 구조체* 를 가리키는 포인터를 저장하는 데 사용된다. *G 구조체* 는 특정한 Go 루틴 내부의 상세한 내용을 담고 있는데 나중에 올 블로그 포스트에서 더 자세히 다룰 것이다. 그러므로, 다른 Go 루틴들이 어떤 한 Go 루틴을 접근할 때, 이 Go 루틴 내부의 자세한 정보를 담고 있는 구조체를 가리키는 변수가 항상 존재한다는 얘기다. 이 변수의 위치는 링커에게 알려져 있어서 (우리가) 분석중인 명령안에서 이 변수가 CX 레지스터에 이동된다는 것을 알 수 있다. TLS는 아키텍쳐마다 다르게 구현될 수 있다. AMD64에서는, *FS* 레지스터를 통해 구현되어서, 이 명령은 *MOVQ FS, CX* 로 번역될 수 있다. 재배치에 대한 토론을 마감하기 위해, 모든 재배치 타입을 담고 있는 열거형 타입(enum) 을 소개하겠다: \u0026gt;``` // Reloc.type enum { R_ADDR = 1, R_SIZE, R_CALL, // relocation for direct PC-relative call R_CALLARM, // relocation for ARM direct call R_CALLIND, // marker for indirect call (no actual relocating necessary) R_CONST, R_PCREL, R_TLS, R_TLS_LE, // TLS local exec offset from TLS segment register R_TLS_IE, // TLS initial exec offset from TLS base pointer R_GOTOFF, R_PLT0, R_PLT1, R_PLT2, R_USEFIELD, }; 이 enum에서 볼 수 있듯이, 재배치 타입 3는 R_CALL 이고 재배치 타입 9은 R_TLS이다. 이 enum 이름들은 방금 설명한 행동들을 완벽하게 설명한다.\nGo 오브젝트 파일에 대한 부연 설명 다음 포스트에서 오브젝트 파일에 대한 설명을 계속해 나가겠다. 또한 Go 런타임이 어떻게 작동하는 지를 이해하는데 필요한 정보들을 더 제공하겠다. 질문이 있다면 코멘트란에 부담없이 해 주길 바란다.\n 원문: Golang Internals, Part 3: The Linker, Object Files, and Relocations 저자: Siarhei Matsiukevich 번역자: Jhonghee Park  "
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/theme-customizing/",
	"title": "시리즈 #3 - 사이트 테마 개발하기",
	"tags": ["Blog", "Hugo"],
	"description": "",
	"content": "사이트 테마 개발하기 시리즈 1 마지막에 hugo-octopress 테마를 사용하여 처음으로 사이트를 구축한 기억을 하실 겁니다. 사이트를 구축하기 전에 Hugo에서 사용할 수 있는 테마가 어떤것 있는지 한번 살펴보고 생각하고 있는 사이트와 잘 맞는 테마를 선택하는 일도 중요합니다. Hugo의 테마 쇼케이스에서 한번 감상하시길 바랍니다.\n Hugo 테마 쇼케이스  자신만의 테마를 개발하기 위한 첫걸음은 남이 개발해 놓은 테마를 사용하는 것에서 부터 시작합니다.\n테마 설치하는 법 테마의 사용법은 대단히 간단합니다. hugo new site명령으로 사이트 프로젝트를 초기화하면 themes 폴더가 생기는 것을 이미 아실 것입니다. 사용하고자 하는 테마를 선택하고 난 뒤 themes 폴더 밑에 다운로드 받은 테마 패키지를 설치해 주면 됩니다.\n테마의 깃헙주소를 아는 경우\n$ cd themes $ git clone https://github.com/parsiya/Hugo-Octopress.git 테마 쇼케이스의 모든 테마를 설치하는 경우\n$ git clone --recursive https://github.com/spf13/hugoThemes.git themes 테마 사용법 테마를 themes에 설치하고 난 뒤 다음과 같이 선택한 테마로 사이트를 구축할 수 있습니다.\n$ hugo -t ThemeName ThemeName은 themes 폴더내 설치된 테마의 디렉토리 이름과 일치하여야 합니다.\n테마 커스터마이징 설치된 테마를 사용하다 보면 맘에 들지 않는 부분이 생기거나 부족한 부분을 발견할 지도 모릅니다. 어떤 경우가 생기더라도 themes밑에 설치된 테마에 속한 파일들을 직접 편집하지 마십시요. Hugo는 이러한 경우가 생길때 보충하거나 기존의 템플릿을 오버라이드할 수 있도록 허락합니다. 설치된 테마의 구조를 살펴보시면 힌트를 얻을 수 있습니다.\n. └── Hugo-Octopress ├── LICENSE.md ├── README.md ├── images │ ├── Thumbs.db │ ├── codecaption1.png │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── list.html │ │ ├── single.html │ │ └── terms.html │ ├── index.html │ ├── indexes │ │ ├── category.html │ │ └── tag.html │ ├── license │ │ └── single.html │ ├── partials │ │ ├── disqus.html │ │ ├── footer.html │ │ ├── header.html │ │ ├── navigation.html │ │ ├── octo-header.html │ │ ├── pagination.html │ │ ├── post_footer.html │ │ ├── post_header.html │ │ └── sidebar.html │ ├── post │ │ └── single.html │ └── shortcodes │ ├── codecaption.html │ └── imgcap.html ├── sample-config.toml ├── static │ ├── css │ │ └── hugo-octopress.css │ └── favicon.png └── theme.toml 지금 개발하고 있는 사이트 프로젝트 폴더 밑으로 layouts, static, archetypes가 있듯이 테마도 같은 구조를 가지고 있습니다.\n정적 리소스를 교체하는 법 테마에 따라온 jQuery버전이 맘에 안 드시나요? 교체하는 법은 기존의 것은 그대로 두고 새로운 jQuery버전을 다운로드 받아 테마에 위치한 장소와 같은 상대적 경로에 배치하면 Hugo는 테마의 jQuery를 사용하지 않고 프로젝트에 배치된 것을 사용해서 사이트를 구축합니다.\n테마 밑\n/themes/themename/static/js/jquery.min.js 프로젝트 Root\n/static/js/jquery.min.js 템플릿 교체하는 법 Hugo는 탬플릿을 찾을 때 항상 프로젝트 밑 layouts폴더를 먼저 검색하고 없으면 테마의 layouts을 찾아봅니다. 이런 Hugo의 특성을 이용하여 테마의 템프렛을 수정해야 할 필요가 생길 때 layouts폴더 밑으로 같은 경로와 이름의 템플릿으로 교체하면 됩니다.\n테마 밑\n/themes/themename/layouts/_default/single.html 프로젝트 Root\n/layouts/_default/single.html 특히 부분 템플릿(partial template)을 잘 활용한 테마의 경우 이런 교체법은 사이트의 보수유지를 최소화하고 미래에도 호환성을 보장하게 해 주는 장점을 가지고 있습니다.\narchetype 교체하는 법 Archetype을 제공하는 테마의 경우 archetypes폴더로 교체하고자 하는 archetype 파일을 복사한 다음 필요에 맞게 수정하면 됩니다.\nDefault 템플릿 사용 주의 layouts/_default폴더내의 템플릿들은 테마에 비슷한 파일들을 가리지 않고 교체하는 효과가 있어 사용을 자제해야 합니다. 항상 default 템플릿을 사용하기 보다는 특정한 템플릿 교체가 더 낫다는 사실을 명심하십시요.\n새 테마 만들기 새로 테마를 만들기 위한 명령어는 다음과 같습니다.\n$ hugo new theme golangkorea 이 명령은 themes폴더 안에 다음과 같이 테마구조를 발생시킵니다.\ngolangkorea ├── LICENSE.md ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── footer.html │ └── header.html ├── static │ ├── css │ └── js └── theme.toml 템플릿은 Go의 템플릿 언어로 만들어 집니다. Go template primer은 Go 템플릿 언어를 숙지하기 위한 좋은 출발점입니다.\n테마 콤퍼넌트  Layouts 근본적으로 웹사이트는 두가지 형식의 페이지를 통해 컨텐트를 제공합니다: 컨텐트 자체가 하나의 페이지인 경우와 여러 항목을 나열해 놓은 페이지. Hugo의 테마는 이 두가지 페이지를 처리하는 기본(default) 템플릿에서 시작해서 컨텐트 타입(type)과 section을 통해 추가로 layout을 제공하는 템플릿을 준비합니다. Single Content 기본 템플릿은 layouts/_default/single.html에 위치합니다. List of Contents 기본 템플릿은 layouts/_default/list.html에 위치합니다. Partial Templates 부분 템플릿은 테마 제작에 있어 매우 중요한 요소입니다. 부분 템플릿을 통해 코드 재사용이 가능하고 아주 작은 부분만 교체하거나 삽입할 수 있게 해 주는 메카니즘이어서 테마의 유지보수가 간단해 지고 미래의 호환성을 보장해 줍니다. Static 테마내 정정 리소스의 구조는 전적으로 개발자에게 달려 있습니다. 보통은 /css, js, img와 같은 폴더를 이용해 정적 자원을 관리합니다. Archetypes 특정한 컨텐트 타입의 정면 변수를 정의하는 archetype을 테마에 포함시킬 수 있습니다. 자세한 내용은 Archetype Guideline을 확인할 수 있습니다. Generator meta tag 테마 개발자들에게 HTML의 \u0026lt;head\u0026gt;에 Generator meta tag, .Hugo.Generator을 포함시킬 것을 권유합니다. Hugo의 사용과 인기도를 가늠하는데 도움을 줍니다.  "
},
{
	"uri": "https://devbj.com/golangkorea/go-walkthrough/io-package/",
	"title": "Go 둘러보기 - io 패키지",
	"tags": ["Golang", "IO", "Package"],
	"description": "",
	"content": " Go Walkthrough 시리즈의 Go Walkthrough: io package를 번역한 글입니다.\n Go는 바이트(bytes)를 사용하여 작업하기 위해 만들어진 프로그래밍 언어이다. 바이트의 리스트, 바이트의 스트림, 또는 단일 바이트중 무얼 가지고 있는지와 상관없이 Go는 이를 쉽게 처리해준다. 이러한 간단한 기본적인 것들로 우리는 추상화 및 서비스를 구축한다.\nio 패키지는 표준 라이브러리 내에서 가장 기본적인 패키지 중 하나이다. 이는 바이트 스트림을 가지고 작업을 하기 위한 인터페이스와 헬퍼(함수)의 모음을 제공한다.\n이 포스트는 표준 라이브러리를 이해하는데 도움을 주기위한 Go 둘러보기 시리즈의 일부이다. 기존에 생성된 문서(자동으로 생성된 Go 문서)는 많은 정보를 제공하지만, 이는 패키지를 실제 상황에서 이해하기에는 어려울 수 있다. 이 시리즈는 일상적으로 사용되는 애플리케이션에서 표준 패키지들이 어떻게 사용되는지에 대한 컨텍스트를 제공할 수 있도록 도와준다. 질문이나 코멘트가 있다면 트위터에서 @benbjohnson로 찾아오면 된다.\n바이트 읽기 바이트로 작업을 할 때 사용되는 두 가지 기본적인 연산이 있는데 바로 읽기와 쓰기이다. 우선 바이트 읽기에 대해서 살펴보자.\nReader 인터페이스 스트림에서 바이트를 읽기 위한 기본 구조체는 Reader 인터페이스이다:\ntype Reader interface { Read(p []byte) (n int, err error) }  byte : byte, int : int, error : error\n 이 인터페이스는 network connections부터 files와 wrappers for in-memory slices에 이르기까지 모든 표준 라이브러리에 걸쳐 구현된다.\nReader는 동일한 바이트를 재사용할 수 있도록 버퍼(p를 말함)를 Read() 메서드에 전달함으로써 동작한다. 만약 Read()가 바이트 슬라이스를 하나의 인자로 받는 대신 이를 반환하게되면 Reader는 Read()를 호출할 때마다 새로운 바이트 슬라이스를 할당해야 할 것이다. 이는 가비지 컬렉터에 안좋은 영향을 끼친다.\nReader 인터페이스의 한 가지 문제점은 애매한 규칙들을 가지고 있다는 것이다. 첫째, 이는 스트림이 완료되면 io.EOF 에러를 정상적인 동작을 하는 것처럼 반환한다. 이는 초보자에게는 혼란을 가져올 수 있다. 둘째, 버퍼가 채워질거라는 보장이 없다. 만약 여러분이 8 바이트 슬라이스를 전달한다면 여러분은 0부터 8바이트 사이의 그 어떤값으로도 돌려받을 수 있다. 부분 읽기를 다루는것은 지저분하고 에러가 발생하기 쉽다. 다행히도 이 문제를 해결하기 위한 헬퍼 함수가 있다.\nReader의 보장성 개선하기 여러분이 파싱 프로토콜을 가지고있고 Reader로부터 unit64 타입의 값을 8 바이트 읽어야한다고 해보자. 이런 경우엔 고정된 크기만큼 읽어야하기 때문에 io.ReadFull()을 사용하는게 더 적합하다.\nfunc ReadFull(r Reader, buf[] byte) (n int, err error)  Reader : Reader, byte : byte, error : error\n 이 함수는 버퍼가 반환되기 전에 데이터가 완전히 채워짐을 보장한다. 만약 버퍼가 일부만 읽었을 경우 여러분은 io.ErrUnexpectedEOF을 돌려받을 것이다. 만약 버퍼가 아무것도 읽지 않았을 경우엔 io.EOF가 반환된다. 이 간단한 보증은 코드를 매우 단순화시킨다. 8 바이트를 읽기 위해선 다음처럼만 하면된다.\nbuf := make([]byte, 8) if _, err := io.ReadFull(r, buf); err == io.EOF { return io.ErrUnexpectedEOF } else if err != nil { return err } Go에는 특정 타입의 파싱을 처리하는 binary.Read()와 같은 고수준의 파서들이 많이 있다. 우리는 이들을 나중에 다른 패키지에서 다룰 것이다.\n또 다른 사용빈도가 낮은 헬퍼 함수는 ReadAtLeast이다:\nfunc ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) 이 함수는 추가 데이터를 읽을 수 있는 경우 이를 버퍼로 읽어들이지만 항상 최소한의 바이트 수를 반환한다. 개인적으로는 이 함수의 필요성을 찾지 못했지만 Read() 호출을 최소화하고 추가 데이터를 버퍼링하고자 한다면 유용하게 사용할 수 있을 것 같다.\n스트림 연결 여러개의 Reader를 하나로 결합해야하는 경우를 많이 볼 것이다. MultiReader를 사용하면 이들을 하나의 Reader로 합칠 수 있다.\nfunc MultiReader(readers ...Reader) Reader  Reader : Reader\n 예를 들면, 디스크에 있는 데이터와 인메모리 헤더가 결합된 HTTP 요청을 보낼 수도 있을 것이다. 많은 사람들이 헤더와 파일을 인메모리 버퍼로 복사하려고 하지만 이는 느리고 많은 메모리를 사용할 수 있다.\n다음과 같은 간단한 방법이 있다:\nr := io.MultiReader( bytes.NewReader([]byte(\u0026#34;...my header...\u0026#34;)), myFile, ) http.Post(\u0026#34;http://example.com\u0026#34;, \u0026#34;application/octet-stream\u0026#34;, r)  MultiReader : MultiReader, NewReader : NewReader, Post : Post\n MultiReader는 http.Post()가 두 개의 Reader를 하나의 연결된 Reader로 간주하도록 한다.\n스트림 복제 Reader를 사용할 때 맞닥뜨릴 수 있는 한가지 문제는 Reader가 한 번 읽히면, 데이터를 다시 읽을 수 없다는 것이다. 예를 들어, 애플리케이션이 HTTP 요청 파싱을 실패하면 파서는 이미 데이터를 다 사용했기 때문에 디버깅을 할 수 없을 것이다.\nTeeReader는 Reader에서 데이터를 다 읽어버리는것에 방해받지 않으면서 Reader의 데이터를 캡쳐하는데 있어 훌륭한 선택이다.\nfunc TeeReader(r Reader, w Writer) Reader  Reader : Reader, Writer : Writer\n 이 함수는 여러분의 Reader(r을 말함)를 래핑하는 새로운 Reader를 생성한다. 새로운 Reader에서 읽는것들은 또한 w에 저장될 것이다. 이 Writer는 in-memory buffer부터 로그 파일, STDERR까지 그 어떤것도 가능하다.\n예를 들면, 잘못된 요청은 다음과 같이 캡쳐할 수 있다:\nvar buf bytes.Buffer body := io.TeeReader(req.Body, \u0026amp;buf) // ... process body ...  if err != nil { // inspect buf  return err } 그러나, 메모리가 부족하지 않도록 캡쳐하려는 요청을 제한하는것이 중요하다.\n스트림 길이 제한 스트림은 제한이 없기 때문에 몇몇 상황에선 메모리나 디스크 이슈를 일으킬 수 있다. 가장 일반적인 예시는 파일 업로드 엔드포인트이다. 엔드포인트는 일반적으로 디스크가 꽉 차는걸 방지하기위해 크기 제한을 가지고 있지만, 이를 직접 구현하는건 지루할 수 있다.\nLimitReader는 Reader가 전체 바이트 수를 제한하도록 래핑함으로써 이 기능을 제공한다.\nfunc LimitReader(r Reader, n int64) Reader  Reader : Reader, int64 : int64\n LimitReader의 한가지 문제는 Reader가 n을 초과하는지에 대한것을 알려주지 않는다는 것이다. 이는 단순히 r에서 n 바이트를 읽게되면 io.EOF를 반환할 것이다. 여러분이 사용할 수 있는 한가지 트릭은 제한값을 n+1로 설정한 후 마지막 바이트을 보고 n 바이트보다 많은 바이트를 읽었는지 아닌지를 판별하는 것이다.\n바이트 쓰기 스트림으로부터 바이트를 읽는것에 대해 다뤄봤다. 이제 이를 어떻게 스트림에 쓸 수 있는에 대해 살펴보자.\nWriter 인터페이스 Writer 인터페이스는 단순히 Reader의 반대이다. 우리는 스트림에 넣기 위한 바이트 버퍼를 제공한다.\ntype Writer interface { Write(p []byte) (n int, err error) }  byte : byte, int : int, error : error\n 일반적으로 바이트 쓰기는 읽기보다 간단하다. Reader는 부분 읽기를 허용하기 때문에 데이터 다루기가 까다롭지만, 부분 쓰기는 항상 에러를 반환한다.\n쓰기 복제 가끔은 쓰기 작업을 여러개의 스트림에 보내고 싶을 것이다. 아마 로그 파일 또는 STDERR로. 이는 읽기를 복제하는 대신 쓰기를 복제한다는것만 제외하면 TeeReader와 유사하다\n이 경우엔 MultiWriter가 유용하다:\nfunc MultiWriter(writers ...Writer) Writer  Writer : Writer\n 이는 MultiReader의 Writer 버전이 아니기 때문에 이름이 약간 혼란스러울 수 있다. MultiReader는 여러개의 Reader를 하나로 합쳐주는데 반해, MultiWriter는 각 쓰기를 여러개의 Writer에 복제하는 하나의 Writer를 반환한다.\n나는 서비스가 제대로 로깅을 하고 있다는걸 단언해야하는 단위 테스트에서 광범위하게 MultiWriter를 사용하고 있다.\ntype MyService struct { LogOutput io.Writer } var buf bytes.Buffer var s MyService s.LogOutput = io.MultiWriter(\u0026amp;buf, os.Stderr)  Buffer : Buffer, MultiWriter : MultiWriter, Stderr : Stderr\n MultiWriter를 사용하면 디버깅을 위해 터미널에서 전체 로그를 보는 동시에 버퍼의 내용을 검증할 수 있게 해준다.\n문자열 쓰기 최적화 표준 라이브러리에는 문자열을 바이트 슬라이스로 변환할 때 별다른 메모리 할당을 요구하지 않음으로써 쓰기 성능을 향상 시킬 수 있는 WriteString() 메서드를 가진 많은 Writer가 있다. io.WriteString() 함수를 사용하면 이 최적화를 활용할 수 있다.\n이 함수는 간단하다. 먼저 Writer가 WriteString() 메서드를 구현하고 있는지를 확인하며 만약 구현이 되어있으면 이를 사용한다. 그렇지 않은 경우엔 Write() 메서드를 사용하여 문자열을 바이트 슬라이스로 복사한다.\n(이 부분을 짚어준 Bouke van der Bijl에게 감사를 전한다)\n바이트 복사 이제 우린 바이트를 읽고 쓸 수 있으며, 이 양쪽을 연결하는것과 Reader와 Writer간의 복사만 이해하면된다.\nReader와 Writer를 연결 Reader를 Writer로 복사하는 가장 기초적인 방법은 적절하게 명명된 Copy() 함수이다:\nfunc Copy(dst Writer, src Reader) (written int64, err error)  Writer : Writer, Reader : Reader, int64 : int64, error : error\n 이 함수는 src로부터 값을 읽기 위해 32KB 버퍼를 사용하며 이를 dst에 쓴다. 만약 읽기 또는 쓰기를 하는 도중 io.EOF 이외의 어떤 에러가 발생하면 복사는 중단되며 에러가 반환된다.\nCopy()의 한가지 문제점은 바이트 수의 최댓값을 보장할 수 없다는 것이다. 예를 들면, 로그 파일을 현재 파일 사이즈만큼 복사하고 싶을 수 있다. 만약 로그가 복사를 하는중에 계속 증가하게되면 예상했던것보다 더 많은 바이트를 읽게될 것이다. 이 경우엔 정확히 몇 바이트를 쓸건지 지정할 수 있는 CopyN() 함수를 사용할 수 있다.\nfunc CopyN(dst Writer, src Reader, n int64) (written int64, err error)  Writer : Writer, Reader : Reader, int64 : int64, error : error\n Copy()의 또 다른 문제는 매 호출마다 32KB의 할당이 필요하다는 것이다. 만약 많은 양의 복사를 한다고하면 CopyBuffer()를 대신 사용함으로써 버퍼를 재사용 할 수 있다:\nfunc CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)  Writer : Writer, Reader : Reader, byte : byte, int64 : int64, error : error\n 나는 Copy()의 오버헤드가 매우 커지는 경우를 본 적이 없어서 개인적으로는 CopyBuffer()를 사용하지 않는다.\n복사 최적화 중간 버퍼를 아예 사용하지 않기위해, 타입은 직접 읽기와 쓰기 인터페이스를 구현할 수 있다. 구현된 경우, Copy() 함수는 중간 버퍼를 사용하지 않고 이러한 구현을 직접 사용한다.\nWriterTo 인터페이스는 직접 데이터를 쓰고자하는 타입에서 사용할 수 있다.\ntype WriterTo interface { WriteTo(w Writer) (n int64, err error) }  Writer : Writer, int64 : int64, error : error\n 나는 이걸 BoltDB의 사용자가 트랜젝션으로부터 데이터베이스 스냅샷을 만들 수 있도록 해주는 Tx.WriteTo()에 사용했었다.\n읽기쪽에서는, ReaderFrom이 타입으로 하여금 Reader로부터 데이터를 직접 읽을 수 있게 해준다.\ntype ReaderFrom interface { ReadFrom(r Reader) (n int6, err error) }  Reader : Reader, int64 : int64, error : error\n Reader와 Writer 개조하기 가끔 Reader를 받는 함수가 있지만 Writer만 가지고 있는 경우가 있을 수 있다. 아마도 여러분은 HTTP 요청에 동적으로 데이터를 써 보내야할 필요가 있을지도 모른다. 그러나 http.NewRequest()는 오직 Reader만 받는다.\nio.Pipe()를 사용해 Writer를 반전시킬 수 있다:\nfunc Pipe() (*PipeReader, *PipeWriter)  PipeReader : PipeReader, PipeWriter : PipeWriter\n 이는 새로운 Reader와 Writer를 제공해준다. 새로운 PipeWriter에 대한 모든 쓰기는 PipeReader로 이동할 것이다.\n나는 이 기능을 직접 사용해본적은 거의 없지만, exec.Cmd()가 명령어 실행 작업을 할 때 매우 유용하게 사용되는 Stdin, Stdout, 그리고 Stderr 파이프를 구현하는데 이를 사용한다.\n스트림 닫기 모든 좋은 것들은 마무리를 지어야하며 이는 바이트 작업시에도 예외는 아니다. 스트림을 닫기 위한 일반적인 방법으로 Closer 인터페이스가 제공된다.\ntype Closer interface { Close() error }  error : error\n Closer는 매우 간단해서 별로 말할게 없지만, 나는 Closer가 필요할 때 내가 만든 타입이 이를 구현할 수 있도록 내 Close()로부터 항상 에러를 반환시키는게 유용하다는걸 발견했다. Closer는 항상 직접 사용되지는 않지만 가끔 ReadCloser, WriteCloser, 그리고 ReadWriteCloser와 같은 다른 인터페이스와 결합해서 사용될 수 있다.\n스트림 내에서의 이동 스트림은 보통 시작부터 끝까지 연속적인 바이트의 흐름(flow)이지만, 몇 가지 예외가 있다. 예를 들면, 파일은 스트림으로 동작할 수 있지만 파일 내의 특정한 위치로 건너뛸 수도 있다.\n스트림 내에서 건너뛸 수 있도록 Seeker 인터페이스가 제공된다.\ntype Seeker interface { Seek(offset int64, whence int) (int64, error) }  int64 : int64, int : int, error : error\n 건너뛰기 위한 방법은 3가지가 있다: 현재 위치를 기준으로 이동하기, 시작점을 기준으로 이동하기, 그리고 끝점을 기준으로 이동하기. whence 인자를 사용해 이동 모드를 지정할 수 있다. offset 인자는 몇 바이트를 이동할 것인지를 지정한다.\n데이터 타입 최적화 청크에서의 읽기와 쓰기는 단일 바이트나 단일 룬이 필요할 때에는 지루해질 수 있다. Go는 이를 쉽게 만들어주는 몇 가지 인터페이스를 제공한다.\n단일 바이트 작업 ByteReader와 ByteWriter 인터페이스는 단일 바이트를 읽고 쓰기 위한 간단한 인터페이스를 제공한다:\ntype ByteReader interface { ReadByte() (c byte, err error) } type ByteWriter interface { WriteByte(c byte) error }  byte : byte, error : error\n 길이는 항상 0 또는 1이 될 것이기 때문에 길이 인자가 없다는걸 볼 수 있다. 만약 바이트가 읽히거나 쓰이지 않으면 에러가 반환된다.\n버퍼링된 바이트 Reader로 작업을 하기 위한 ByteScanner 인터페이스 또한 제공된다.\ntype ByteScanner interface { ByteReader UnreadByte() error }  ByteReader : ByteReader, error : error\n 이는 다음에 읽을 수 있도록 이전에 읽은 바이트를 다시 Reader에 넣는다. 이는 다음에 사용가능한 바이트를 미리 볼 수 있도록 해주기 때문에 LL(1) 파서를 작성할 때 특히 유용하다.\n단일 룬 작업 만약 유니코드 데이터를 파싱중이라면 개별 바이트 대신 룬으로 작업을 해야할 것이다. 이 경우, RuneReader와 RuneScanner가 대신 사용된다.\ntype RuneReader interface { ReadRune() (r rune, size int, err error) } type RuneScanner interface { RuneReader UnreadRune() error }  rune : rune, int : int, error : error\n 결론 바이트 스트림은 대부분의 Go 프로그램에 필수적이다. 이들은 네트워크 연결에서 디스크의 파일, 키보드로부터의 사용자 입력에 이르기까지의 모든 것에 대한 인터페이스이다. io 패키지는 이러한 모든 인터랙션을 위한 기초를 제공한다.\n우리는 바이트 읽기, 바이트 쓰기, 바이트 복사하기, 그리고 마지막으로 이 연산들을 최적화하는 방법들을 살펴봤다. 이러한 기본적인 요소들은 간단해 보일 수 있지만 이들은 모든 데이터 중심 애플리케이션을 위한 빌딩 블록을 제공한다. io 패키지를 살펴보고 여러분의 애플리케이션에서 이들의 인터페이스를 고려해보길 바란다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part4/",
	"title": "Golang의 내부, 4부: 오브젝트 파일, 그리고 함수 메타데이터",
	"tags": ["Golang", "Internals", "linker", "object file", "relocations", "metadata"],
	"description": "",
	"content": "오늘은, Func 구조에 대해 좀 더 자세히 들여다 보고 어떻게 가비지 컬렉션이 작동하는지 몇가지 자세한 내용을 논하겠다.\n이 포스트는 Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치의 연속이어서, 독자가 아직 읽지 않았다면 이 포스트를 소화하기 전에 읽기를 적극 권장한다.\n함수 메타데이터의 구조 재배치에 대한 주요한 아이디어는 3부를 통해 분명해 졌을 것이다. 이제 main 메서드의 Func 구조를 살펴보자:\n  01 Func: \u0026amp;goobj.Func{ 02 Args: 0, 03 Frame: 8, 04 Leaf: false, 05 NoSplit: false, 06 Var: { 07 }, 08 PCSP: goobj.Data{Offset:255, Size:7}, 09 PCFile: goobj.Data{Offset:263, Size:3}, 10 PCLine: goobj.Data{Offset:267, Size:7}, 11 PCData: { 12 {Offset:276, Size:5}, 13 }, 14 FuncData: { 15 { 16 Sym: goobj.SymID{Name:\u0026ldquo;gclocals·3280bececceccd33cb74587feedb1f9f\u0026rdquo;, Version:0}, 17 Offset: 0, 18 }, 19 { 20 Sym: goobj.SymID{Name:\u0026ldquo;gclocals·3280bececceccd33cb74587feedb1f9f\u0026rdquo;, Version:0}, 21 Offset: 0, 22 }, 23 }, 24 File: {\u0026quot;/home/adminone/temp/test.go\u0026rdquo;}, 25 },\n 이 구조체는 Go언어의 런타임이 사용하는, 컴파일러가 오브젝트 파일에 방출한 함수 메타데이터로 생각해 볼 수 있다. [이 문서](https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub)를 통해 Func내 정확한 포맷과 여러 필드들의 의미에 대한 설명을 접할 수 있다. 이제, 런타임에서 이 메타데이터가 어떻게 사용되는지 보겠다. runtime 패키지 안에서 이 메타데이터는 다음 구조체에 매핑되어 있다. \u0026gt;``` 01 type _func struct { 02 entry uintptr // start pc 03 nameoff int32 // function name 04 05 args int32 // in/out args size 06 frame int32 // legacy frame size; use pcsp if possible 07 08 pcsp int32 09 pcfile int32 10 pcln int32 11 npcdata int32 12 nfuncdata int32 13 } 오브젝트 파일 안에 있는 정보가 모두 다 직접적으로 매핑되어 있는 것은 아니다. 몇몇 필드들은 링커에만 사용된다. 그렇다 해도 여기에서 가장 흥미로운 필드들은 pcsp, pcfile, 그리고 pcln 이다. 이 필드들은 프로그램 카운터가 stack pointer, filename, 그리고 line으로 번역될 때 사용된다.\n예를 들면, panic 이 발생할 경우 이 메타데이터 필드들이 필요할 것이다. 그 순간에 런타임이 알고 있는 바는 오직 panic 을 야기한 현재의 어셈블리 명령의 프로그램 카운터이다. 그래서 런타임은 그 카운터를 이용해 현재 파일과 라인 번호, 그리고 stack trace 전부를 얻는 것이다. 파일과 라인 번호는 pcfile 과 pcln 필드를 이용하면 바로 해결된다. stack trace는 pcsp 를 이용하여 재귀적으로 해결한다.\n이제 프로그램 카운터를 가지고 어떻게 상응하는 라인 번호를 얻을 수 있는지에 대한 질문에 답을 하자. 답을 얻기 위해서는 어셈블리 코드를 들여다 보고 오브젝트 파일에 라인 번호가 어떻게 저장되어 있는 지를 이해해야 한다:\n  1 0x001a 00026 (test.go:4) MOVQ $1,(SP) 2 0x0022 00034 (test.go:4) PCDATA $0,$0 3 0x0022 00034 (test.go:4) CALL ,runtime.printint(SB) 4 0x0027 00039 (test.go:5) ADDQ $8,SP 5 0x002b 00043 (test.go:5) RET ,\n 프로그램 카운터 26에서 38까지는 라인 번호 4에 상응하고 카운터 39에서 *next_function_program_counter - 1* 까지는 라인 번호 5에 해당된다. 효율적 공간사용을 생각하면 다음과 같은 맵을 저장하는 것으로 충분하다: \u0026gt;``` 1 26 - 4 2 39 - 5 3 … 이것은 컴파일러가 하는 일과 거의 일치한다. pcln 필드는 현재 실행중인 함수의 첫번째 프로그램 카운터에 상응하는 특정한 오프셋을 맵안에서 가리키고 있다. 이 오프셋과 또 다음 함수의 첫번째 프로그램 카운터의 오프셋을 알고, 런타임은 바이너리 검색을 이용해 주어진 프로그램 카운터에 상응하는 라인 번호를 찾는다.\nGo 언어에서 이런 아이디어는 일반화 되어 있다. 라인 번호와 스택 포인터만 프로그램 카운터에 맵팅되어 있는게 아니라 어떤 정수 값도 매핑될 수 있다. PCDATA 명령을 통해서 가능한 것이다. 매번 링커는 다음 명령을 찾는다:\n  1 0x0022 00034 (test.go:4) PCDATA $0,$0\n 이 명령은 실제로 어셈블러 명령을 생산하지 않는다. 대신, 이 명령의 두번째 인수를 맵안에서 현재의 프로그램 카운터를 사용해 저장하고, 첫번째 인수는 어떤 맵이 사용되는 지를 나타낸다. 이 첫번째 인수를 통해, 새로운 맵을 쉽게 첨가할 수 있는데, 컴파일러와 런타임에는 그 의미가 알려지지만 링커에게는 보이지 않는다. # 가비지 컬렉터는 어떻게 함수 메타데이터를 사용하는가 마지막으로 아직 설명을 더 명확하게 해야할 함수 메타데이터의 내용은 FuncData 배열인데, 가비지 컬렉션에 필요한 정보를 담고 있다. Go 언어는 [mark-and-sweep](http://www.brpreiss.com/books/opus5/html/page424.html) 가비지 컬렉터 (GC)를 사용하는데 두 단계를 거쳐 동작한다. 첫번째 단계인 (mark)에서는, 모든 객체를 섭렵하면서 아직 사용중인 것들은 \u0026quot;reachable\u0026quot;로 표시한다. 표시되지 않은 모든 객체는 두번째 단계인 (sweep)에서 제거된다. 그래서, 가비지 컬렉터는 전역 변수, 프로세서 레지스터, 스택 프레임, 그리고 이미 위치가 알려진 객체내 포인터들과 같이 잘 알려진 위치들내 도달할 수 있는(reachable) 객체를 찾아보면서 시작한다. 하지만 곰곰히 생각해 보면, 스택 프레임안에서 포인터를 찾아내는 것이 그렇게 쉽지는 않는 일이다. 그렇다면 런타임이 가비지 컬렉션을 실행할때 스택안에서 어떻게 포인터와 포인터가 아닌 타입의 변수들을 알아 내는 것일까? 바로 여기에서 *FuncData* 가 등장하는 것이다. 각 함수마다 컴파일러는 두개의 변수를 만든다. 하나는 스택 프레임의 인수들을 위한 비트맵 벡터를 담고 있다. 다른 하나는 나머지 프레임을 위한 비트맵으로 함수에 정의된 포인터 타입의 모든 지역 변수들을 포함한다. 이 변수들은 각자 가비지 컬렉터에게 스택 프레임안에 포인터들이 어디에 위치하는지 정확하게 알려주고 이는 가비지 컬렉터가 일을 하는 데 충분한 정보이다. *PCDATA* 와 같이 *FUNCDATA* 역시 의사-Go 어셈블리 명령(pseudo-Go assembly instruction)에 의해 발생된 것임을 언급할 가치가 있겠다: \u0026gt;``` 1 0x001a 00026 (test.go:3) FUNCDATA $0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB) 이 명령의 첫번째 인수는 이것이 인수들을 위한 함수 데이터인지 아니면 지역 변수 공간인지를 나타낸다. 두번째 인수는 실제로 GC 마스크를 담고 있는 숨겨진 변수에 대한 참조 값이다.\nGolang에 대해 더 알아보기 앞으로 나올 포스트에서는 Go 언어의 부트 스트랩 과정을 얘기하겠다. 런타임이 어떻게 작동하는지를 이해하는데 중요한 단서이다. 일주일 뒤에 보자.\n 원문: Golang Internals, Part 4: Object Files and Function Metadata 저자: Siarhei Matsiukevich 번역자: Jhonghee Park  "
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/taxonomy-basic/",
	"title": "시리즈 #4 - 분류(Taxonomy)기능 사용하기",
	"tags": ["Blog", "Hugo"],
	"description": "",
	"content": "분류(Taxonomy)기능 사용하기 사이트에 컨텐트가 많아 질 수록 고민이 생깁니다. 비숫한 주제의 컨텐트를 한 곳에 나열해 주는 페이지를 만들수는 없는가? 순진한 저자는 자기가 포스트한 내용을 모두 한 포스트에 링크할 지도 모릅니다. 주제 별로 나열해 주는 포스트를 만들어 새로운 포스트가 올라올 때 마다 링크를 걸어 줄 수도 있겠죠. 손이 많이 가고 더군다나 다른 저자들의 비슷한 포스트는 포함되지 못하는 일도 허다할 겁니다.\nHugo는 이런 문제를 분류(taxonomy)라는 기능으로 간단히 햬결해 드립니다.1기본적으로 Hugo에는 tags와 categories라는 분류변수를 지원합니다. 컨텐트 저자가 할 일은 단지 Front Matter에 명시해 주기만 하면 됩니다.\n+++ date = \u0026quot;2016-08-23T23:25:44-04:00\u0026quot; draft = false title = \u0026quot;시리즈 #4 - 분류(Taxonomy)기능 사용하기\u0026quot; tags = [\u0026quot;Blog\u0026quot;, \u0026quot;Hugo\u0026quot;] categories = [\u0026quot;How-to\u0026quot;] series = [\u0026quot;Hugo Introduction\u0026quot;] authors = [\u0026quot;Jhonghee Park\u0026quot;] toc = true +++ 예를 들어 How-to category의 경우 Hugo는 모든 컨텐트를 스캔하면서 해당 컨텐트들을 /categories/how-to/index.html로 나열해 줍니다. 다시 말하면 taxonomy기능이 컨텐트내에 사용되면 taxonomy에 지정된 template을 이용해 Hugo는 모든 taxonomy페이지를 자동으로 만들고 사용된 term과 각 term을 사용한 컨텐트를 나열합니다.\nTaxonomy 용어 정리  Taxonomy 같은 카테고리의 컨텐트를 분류하는 방식 (예: tag, category, author 등) Term taxonomy에 속하는 키워드 (author의 예를 들면 Jhonghee Park, Sangbae Yun, Kookheon Kwon) Value term이 사용된 컨텐트의 내용  Taxonomy Organization Taxonomy의 관점에서 본 Organization은 다음과 같습니다.\nauthor \u0026lt;-- Taxonomy Jhonghee Park \u0026lt;-- Term ReadMe First \u0026lt;-- Content 시리즈 #1 - Hugo 시작하기 \u0026lt;-- Content 시리즈 #2 - 컨텐츠 제작 기초 \u0026lt;-- Content ... Sangbae Yun \u0026lt;-- Term Go언어 시작하기 \u0026lt;-- Content Golang 프로젝트에 TDD 도입하기 \u0026lt;-- Content vim-go를 이용한 go 개발 환경 구축 \u0026lt;-- Content ... 컨텐트의 관점에서 본 Organization은 다음과 같습니다.\n시리즈 #1 - Hugo 시작하기 \u0026lt;-- Content author \u0026lt;-- Taxonomy Jhonghee Park \u0026lt;-- Term series \u0026lt;-- Taxonomy Hugo 입문 \u0026lt;-- Term Go언어 시작하기 \u0026lt;-- Content author \u0026lt;-- Taxonomy Sangbae Yun \u0026lt;-- Term series \u0026lt;-- Taxonomy Go 시작하기 \u0026lt;-- Term 분류변수(taxonomies)의 정의 분류변수는 사용하기 전에 사이트 configuration에 정의되어야 만 합니다. 단수형과 복수형을 사용해 다음과 같이 정의합니다.\n[taxonomies] author = \u0026quot;authors\u0026quot; category = \u0026quot;categories\u0026quot; tag = \u0026quot;tags\u0026quot; series = \u0026quot;series\u0026quot; 컨텐트에 분류변수 지정하기 일단 분류변수가 사이트 레벨에 정의된 후에는 컨텐트 타입과 section을 막론하고 어떤 컨텐트에도 사용 가능합니다. Front Matter에 복수형의 taxonomies를 써서 원하는 모든 Term을 나열하면 됩니다.\nTaxonomy 템플릿 Hugo는 일정한 규칙에 따라 Taxonomy 리스트 페이지를 만들어 냅니다. 주어진 Term의 모든 Taxonomy Value 리스트는 다음과 같은 URL 형식을 따릅니다.\n/{{복수형 Taxonomy 이름}}/{{Term}}/ 이때 Term은 다음과 같은 변환을 거칩니다\n hyphenated How to는 /categories/how-to lower-cased Jhonghee Park는 /authors/jhonghee-park normalized Gérard Depardieu는 /actors/gerard-depardieu2  Taxonomy 페이지를 렌더링하기 위해서는 해당 Taxonomy의 템플릿이 필요합니다. 템프릿의 위치는 다음의 규칙을 따릅니다.\n/layouts/taxonomy/{{단수형 Taxonomy 이름}} Taxonomy, authors의 경우, 템플릿은 /layouts/taxonomy/author.html에 위치하게 합니다.\n"
},
{
	"uri": "https://devbj.com/blog/",
	"title": "Blog",
	"tags": [],
	"description": "블로그 글 모음 - 기술, 생각",
	"content": "블로그 글 모음 글 목록  Thought  Chapter 1 나의생각 북마크 정리 [서버] postman tutorial 및 사.. : 네이버블로그 한글은 노토산스, 영문/숫자는 다른 폰트로 해주세요\u0026hellip;👀 (feat. unicode) | 필오의 개발일지\n   IPv6 WebServer example with WIZnet W6100 chip  (Modified) 2019-03-03 WebServer Example WebServer-Adafruit (https://github.com/WIZnet-ArduinoEthernet/WebServer-Adafruit) W6100의 IPv4, IPv6 Dual Stack을 이용한 WebServer Example 입니다. Browser로 접속하면 Host의 IPv4 또는 IPv6 주소가 Adafruit의 OLED SSD130\n   Embedded World 2019  (Modified) 2019-03-03 MCU 마이크로칩 클라우드 연동 모듈 신규 출시 30초만에 구성하는 클라우드 솔루션!! 이렇게 광고중 WiFi 모듈을 내장하고, 각 클라우드별 backend reference 를 기본 제공 쉽고 빠른\n   The real products based on Arduino-Ethernet  (Modified) 2019-01-21 Value Added Products based on Arduino Ethernet Shield Arduino Adafruit Industries Sfera Labs S.r.l. DFRobot Elektronik Hannes Jochriem Parallax Inc Electric Imp Controllino Industruino KMP Electronics Ltd mikroe Tindie Arduino Ethernet을 기반으로 한 실제 상용화된 제품들을 소개해 본다. Value Added Products based on Arduino Ethernet Shield\n   List of Arduino Ethernet Shield products  (Modified) 2019-01-15 W6100 W5500 W5100S W5100 W5200 Ethernet Shield List What is the \u0026ldquo;Ethernet Shield\u0026rdquo;? The Arduino Ethernet Shield connects your Arduino to the internet in mere minutes. Just plug this module onto your Arduino board, connect it to your network with an RJ45 cable (not included) and follow a few simple instructions to start controlling your world through the internet. from Ethernet Shield WIZnet - W5100, W5200, W5500, W5100S, W6100 W6100 Name Maker Chipset Product link W5500 Name Maker Chipset Product link ARDUINO MKR ETH SHIELD Arduino W5500 Product Link W5500 Ethernet Shield S(secure) EWBM W5500 Product Link Arduino Ethernet Shield 2 Arduino W5500 Product Link W5500 Ethernet Shield WIZnet W5500 Product Link SweetPea UnoNet+ : Ethernet and NFC in one board ElectronicSweetpeas W5500 Product Link POE W5500 Ethernet Shield Iteadstudio W5500 Product Link W5500 Ethernet Shield v1.\n   The state of Arduino Ethernet Library  (Modified) 2019-01-15 최근 Arduino Ethernet Library 업데이트 내용과 유용한 몇개의 라이브러리와 관련 예제를 정리해 본다. 라이브러리 정보 최근 업데이트 된 라이브러리 Arduino Ethernet Library v2.0 - Arduino official Runtime\n   드라마 - 미드  (수정시간) 2016-09-21 미드 House of cards - 하우스 오브 카드 Game of thrones - 왕좌의 게임 실리콘밸리 - Silicon Valley 슈츠 - Suits 지금까지 기억나는 추천 리스트 정리, 한편씩만 본 것들은 배제 미드 실\n   W5500 drivers  (수정시간) 2016-09-07 W5500 Driver open source projects - 오픈소스 AVR-ATmel LPC 시리즈 - NXP LPC11exxx \u0026hellip; W5500으로 이더넷 구현하기 (개발 환경 구축) STM32 시리즈 - ST Microelectronics PIC 시리즈 - Microchips PIC18, PIC24 \u0026hellip; PSoC 시리즈 - Cypress\n   추천 토렌트 사이트 - torrent, 자료  (수정시간) 2016-08-31 추천 토렌트 사이트 기타 회원가입 없고, 광고가 적은 것으로 추천 추천 토렌트 사이트 tvzil - https://tvzil.com 목록이 제일 잘 되어 있는 사이트 거의 완벽하다. 광고도 허용\n   영어 공부  (수정시간) 2016-09-21 영어학원 온라인영어 화상영어 블로그 만들면서 참고한 글을 정리해 본다. 영어학원 @수내역 랩스어학원 시간당 6만원 정도 물론 20시간씩 하면 15~20% 할\n   Makefile 분석  (수정시간) 2016-07-26 마크다운 연습도 할 겸 아래글 내용을 가져옵니다. 오래된 글이라 새로 적어두는 것도 의미가 있진 않을까요? 개인용 블로그이니 조금 이해해 주시길..\n   지킬 블로그 만들기 - jekyll, github, github pages  (수정시간) 2016-08-08 지킬 기반의 블로그 리소스 블로그 만들면서 참고한 글을 정리해 본다. 지킬 기반의 블로그 카카오 기술 블로그 - 베껴오고 있음. 개인적으로 css 이런것도\n   Button  Nice buttons on your page.\n   Expand  Displays an expandable/collapsible section of text on your page\n   Mermaid  Generation of diagram and flowchart from text in a similar manner as markdown\n   노션 페이지 복사하기  노션 페이지 복사하기\n   북마크 [서버] postman tutorial 및 사.. : 네이버블로그\n한글은 노토산스, 영문/숫자는 다른 폰트로 해주세요\u0026hellip;👀 (feat. unicode) | 필오의 개발일지\n"
},
{
	"uri": "https://devbj.com/blog/thought/",
	"title": "Thought",
	"tags": [],
	"description": "",
	"content": "Chapter 1 나의생각 북마크 정리 [서버] postman tutorial 및 사.. : 네이버블로그\n한글은 노토산스, 영문/숫자는 다른 폰트로 해주세요\u0026hellip;👀 (feat. unicode) | 필오의 개발일지\nWinner Micro W600 \u0026amp; W601 (Wi-Fi Chips) - CHIP.HAUS\n[최진석의 老莊的 생각] ⑮ 우물안 개구리 - Day \u0026amp; Night is\u0026hellip;\nWeekly Sync\n[](https://www.notion.so/5df3fabc31e14dfb9909046c90f5bbc4)\n[임진한의 베스트레슨] 스윙의 기본자세 - 임팩트 - YouTube\n4K Video Downloader | PС와 macOS, Linux용 무료 Video Downloader | 4K Download\nYouTube Favorites Back Up To Excel\n유튜브 재생목록 한 번에 다운로드받기(윈도우) : 네이버 블로그\n장은비 프로의 골프 기초레슨 NO.1 그립편!!! - YouTube\n[골프레슨] 스윙, 스텝 바이 스텝 드라이버 편 - YouTube\n[골짤강]스윙, 스텝 바이 스텝 총정리 - YouTube\n마이크로소프트(MS). 세계에서 가장 비싼 기업이 된 비결 - YouTube\n삼성전자 시스템 반도체에 133조원 투자! 무엇을 원하는가? - YouTube\n애플, 미디어 전쟁을 선포하다. 구글/아마존/애플의 新삼국지 - YouTube\nISM43340-M4G-L44 Serial-to-Wi-Fi Dual Band (2.4 \u0026amp; 5 GHz) \u0026amp; BLE Combo Module – Inventek Systems\nThe Kosmos IoT System + ESP32: Connected Products Made Easy\nNotion Contents\n루비 Downloads\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part5/",
	"title": "Golang의 내부, 5부: 런타임 부트스트랩",
	"tags": ["Golang", "Internals", "runtime", "bootstrap"],
	"description": "",
	"content": "부트스트래핑 과정은 Go의 런타임이 어떻게 작동하는지를 이해하는데 열쇠와 같은 구실을 한다. Go와 함께 앞으로 나아가고자 한다면 반드시 배워야한다. 그래서 Golang의 내부 시리즈의 다섯번째는 Go의 런타임, 특히 Go의 부트스트래핑 과정에 바치겠다. 이번에 독자가 배울 항목들은:\n Go 부트스트래핑 가변 스택 구현 TLS 내부 구현  이 포스트에 어셈블러 코드가 많이 포함되어 있는 점을 주목하라. 진행하기 위해 적어도 어셈블러의 기본 지식은 필요할 것이다. (속성 Go 어셈블러 가이드가 여기 있다.) 이제 시작해 보자!\n프로그램 시작점 찾기 우선, Go 프로그램이 시작된 후 즉시 실행되는 함수가 무엇인지 찾아보자. 그러기 위해, 간단한 Go 앱을 제작할 것이다:\n  1 package main 2 3 func main() { 4 print(123) 5 }\n 그런 다음 컴파일하고 링크 할 필요가 있다: \u0026gt;``` 1 go tool 6g test.go 2 go tool 6l test.6 이 과정을 통해 6.out 이라고 불리는 실행 파일이 현재 디렉토리에 만들어 진다. 다음 단계는 objdump 툴을 사용한다. 이 툴은 리눅스에만 해당되는 툴이어서 윈도우나 맥 사용자들은 유사한 툴을 찾던지 이 단계를 그냥 건너 뛰어야 한다. 이제 다음 명령을 실행하라:\n  1 objdump -f 6.out\n 이것을 통해 시작 주소를 담고 있는 출력을 얻을 것이다: \u0026gt;``` 1 6.out: file format elf64-x86-64 2 architecture: i386:x86-64, flags 0x00000112: 3 EXEC_P, HAS_SYMS, D_PAGED 4 start address 0x000000000042f160 다음은, 실행파일을 역어셈블하고 이 주소에 위치한 함수가 무엇인지 알아 낸다:\n  1 objdump -d 6.out \u0026gt; disassemble.txt\n 그런 다음 *disassemble.txt* 파일을 열어서 “*42f160*.”를 검색하여 다음과 같은 결과를 얻는다: \u0026gt;``` 1 000000000042f160 \u0026lt;_rt0_amd64_linux\u0026gt;: 2 42f160: 48 8d 74 24 08 lea 0x8(%rsp),%rsi 3 42f165: 48 8b 3c 24 mov (%rsp),%rdi 4 42f169: 48 8d 05 10 00 00 00 lea 0x10(%rip),%rax # 42f180 \u0026lt;main\u0026gt; 5 42f170: ff e0 jmpq *%rax 좋아! 찾았다! 저자의 OS와 아키텍쳐에 해당하는 시작점은 _rt0_amd64_linux 라는 함수이다.\n시작하는 순서 이제 이 함수를 Go 런타임 소스코드에서 찾을 필요가 있다. 위치한 곳은 rt0_linux_amd64.s 파일이다. Go runtime 패키지속을 들여다 보면, 많은 파일의 이름들이 OS와 아키텍쳐 이름에 연관된 어미들(postfixes)로 되어 있음을 발견할 수 있다. runtime 패키지가 빌드될 때, 현재 OS와 아키텍쳐에 상응하는 파일들만 선택되고 나머지는 건너뛴다. rt0_linux_amd64.s를 더 자세히 들여다 보자:\n  1 TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 2 LEAQ 8(SP), SI // argv 3 MOVQ 0(SP), DI // argc 4 MOVQ $main(SB), AX 5 JMP AX 6 7 TEXT main(SB),NOSPLIT,$-8 8 MOVQ $runtime·rt0_go(SB), AX 9 JMP AX\n *_rt0_amd64_linux* 함수는 매우 단순하다. main 함수를 부르고 인수값 (*argc* and *argv*) 을 레지스터 (*DI* and *SI*)에 저장한다. 인수들은 스택에 위치하고 *SP* (스택 포인터) 레지스터를 통해 접근할 수 있다. main 함수 역시 매우 간단하다. *runtime.rt0_go* 를 호출한다. *runtime.rt0_go* 함수는 좀 길고 더 복잡하다. 그래서 작은 부분들로 분해한 다음 하나씩 따로 설명할 것이다. 첫번째 섹션은 이러하다: \u0026gt;``` 1 MOVQ DI, AX // argc 2 MOVQ SI, BX // argv 3 SUBQ $(4*8+7), SP // 2args 2auto 4 ANDQ $~15, SP 5 MOVQ AX, 16(SP) 6 MOVQ BX, 24(SP) 이전에 저장해 두었던 코맨드라인 인수값을 AX 와 BX 에 두고 스택 포인터를 감소시킨다. 두개의 4 바이트 변수를 위한 공간을 추가하고 16 비트로 정렬되게 조정한다. 마지막으로 인수값은 다시 스택에 이동시킨다.\n  1 // create istack out of the given (operating system) stack. 2 // _cgo_init may update stackguard. 3 MOVQ $runtime·g0(SB), DI 4 LEAQ (-64*1024+104)(SP), BX 5 MOVQ BX, g_stackguard0(DI) 6 MOVQ BX, g_stackguard1(DI) 7 MOVQ BX, (g_stack+stack_lo)(DI) 8 MOVQ SP, (g_stack+stack_hi)(DI)\n 두번째 부분은 좀 더 까다롭다. 우선, 전역 변수 *runtime.g0* 의 주소를 DI 레지스터에 올린다. 이 변수는 [proc1.go](https://github.com/golang/go/blob/master/src/runtime/proc1.go) 파일에 정의되어 있고 *runtime,g* 타입에 속한다. 이 타입의 변수들은 시스템내 각 고루틴(goroutine)마다 만들어 진다. 독자가 추측할 수도 있듯이, *runtime.g0* 는 루트 고루틴(root goroutine)을 나타낸다. 그런 다음 이 루트 고루틴의 스택을 묘사하는 필드들을 초기화한다. *stack.lo* 와 *stack.hi* 가 뜻하는 바는 분명하다. 이것들은 현재 고루틴의 시작과 끝을 가리키는 포인터 들이다. 그런데 *stackguard0* 와 *stackguard1* 필드는 무엇일까? 이 것들을 이해하기 위해서는 *runtime.rt0_go* 함수를 분석하는 일을 잠시 접어 두고 Go 언어에서 스택 크기 변화에 대해 좀 더 자세히 알아 보아야 한다. # Go 언어에서 크기를 조정할 수 있는 스택의 구현 Go 언어는 크기를 조정할 수 있는 스택을 사용한다. 각 고루틴은 작은 스택으로 시작해서 한계치에 도달하면 크기를 바꾼다. 물론 이 한계치에 도달했는지를 알아보는 방법이 있다. 사실 각 함수는 시작할 때 스택이 한계에 도달했는지를 확인한다. 이것이 어떻게 작동하는지 알아보기 위해 샘플 프로그램을 *-S* 플래그를 이용해 다시 한번 컴파일 하자. 어셈블리 코드을 보게 될 것 이다. main 함수의 시작부분은 다음과 같다: \u0026gt;``` 1 \u0026quot;\u0026quot;.main t=1 size=48 value=0 args=0x0 locals=0x8 2 0x0000 00000 (test.go:3) TEXT \u0026quot;\u0026quot;.main+0(SB),$8-0 3 0x0000 00000 (test.go:3) MOVQ (TLS),CX 4 0x0009 00009 (test.go:3) CMPQ SP,16(CX) 5 0x000d 00013 (test.go:3) JHI ,22 6 0x000f 00015 (test.go:3) CALL ,runtime.morestack_noctxt(SB) 7 0x0014 00020 (test.go:3) JMP ,0 8 0x0016 00022 (test.go:3) SUBQ $8,SP 우선 쓰레드 로컬 스토리지 (TLS)에서 한 값을 CX 레지스터에 올린다(TLS가 무엇인지는 이전 포스트에서 이미 설명한 바 있다). 이 값은 항상 현재 고루틴에 상응하는 runtime.g 구조에 대한 포인터를 담고 있다. 그런 다음 스택포인터를 runtime.g 구조내 16 바이트의 오프셋에 위치한 값과 비교한다. 계산해 보면 이 값이 stackguard0 필드에 상응한다는 것을 쉽게 알 수 있다.\n바로 이것이 스택 한계치에 도달했는지를 확인하는 방식이다. 아직 도달하지 않았다면, 확인은 실패로 간주되어서 스택에 충분한 메모리가 할당될 때 까지 runtime.morestack_noctxt 함수를 반복적으로 호출한다. stackguard1 필드는 stackguard0 와 매우 유사하게 작동한다. 하지만 Go 대신 C 스택 성장 프롤로그 (C stack growth prologue)내에서 사용된다. runtime.morestack_noctxt 의 내부 작동 원리 또한 매우 흥미로운 주제이긴 하지만 나중에 논하기로 하겠다. 지금은 부트스트랩 과정으로 다시 돌아가기로 하자.\n계속되는 Go 부트스트래핑에 대한 조사 시작하는 순서에 대해 더 나아가기 위해서 runtime.rt0_go 함수내 다음 부분에 있는 코드를 살펴보기로 하자:\n  01 // find out information about the processor we\u0026rsquo;re on 02 MOVQ $0, AX 03 CPUID 04 CMPQ AX, $0 05 JE nocpuinfo 06 07 // Figure out how to serialize RDTSC. 08 // On Intel processors LFENCE is enough. AMD requires MFENCE. 09 // Don\u0026rsquo;t know about the rest, so let\u0026rsquo;s do MFENCE. 10 CMPL BX, $0x756E6547 // \u0026ldquo;Genu\u0026rdquo; 11 JNE notintel 12 CMPL DX, $0x49656E69 // \u0026ldquo;ineI\u0026rdquo; 13 JNE notintel 14 CMPL CX, $0x6C65746E // \u0026ldquo;ntel\u0026rdquo; 15 JNE notintel 16 MOVB $1, runtime·lfenceBeforeRdtsc(SB) 17 notintel: 18 19 MOVQ $1, AX 20 CPUID 21 MOVL CX, runtime·cpuid_ecx(SB) 22 MOVL DX, runtime·cpuid_edx(SB) 23 nocpuinfo:\n 이 부분은 Go의 주요한 컨셉트들을 이해하는데 반드시 알아야 할 필요는 없다. 그래서 짧게 보고 넘어 가겠다. 여기에서는 지금 사용되고 있는 프로세서가 무엇인지 알아내려는 시도가 있다. 만약 인텔이면 *runtime·lfenceBeforeRdtsc* 변수에 값을 매긴다. *runtime·cputicks* 메서드에만 사용된 변수이다. 이 메서드는 *runtime·lfenceBeforeRdtsc* 값에 의존하여 cpu 마다 다른 어셈블러 명령을 통해 tick을 알아낸다. 마지막으로 CPUID 어셈블러 명령을 호출하고, 실행하고, 결과를 *runtime·cpuid_ecx* 와 *runtime·cpuid_edx* 변수에 저장한다. 이 변수들은 [alg.go](https://github.com/golang/go/blob/master/src/runtime/alg.go) 파일에서 컴퓨터의 아키텍쳐에 따라 기본적으로 지원되는 적합한 헤쉬잉 알고리즘을 선택하는데 사용된다. 자, 다음 코드로 이동하자. \u0026gt;``` 01 // if there is an _cgo_init, call it. 02 MOVQ _cgo_init(SB), AX 03 TESTQ AX, AX 04 JZ needtls 05 // g0 already in DI 06 MOVQ DI, CX // Win64 uses CX for first parameter 07 MOVQ $setg_gcc\u0026lt;\u0026gt;(SB), SI 08 CALL AX 09 10 // update stackguard after _cgo_init 11 MOVQ $runtime·g0(SB), CX 12 MOVQ (g_stack+stack_lo)(CX), AX 13 ADDQ $const__StackGuard, AX 14 MOVQ AX, g_stackguard0(CX) 15 MOVQ AX, g_stackguard1(CX) 16 17 CMPL runtime·iswindows(SB), $0 18 JEQ ok 이 코드 조각은 cgo 가 활성화되어 있을 때 만 실행된다. cgo 는 따로 다루어야 할 주제이고 앞으로 나올 포스트에서 다룰지도 모르겠다. 지금 이 시점에서는 기본적인 부트스트랩 작업의 흐름만을 이해하고 자 하기 때문에, 건너 뛸 것이다.\n다음 코드 조각은 TLS를 설정하는 장본인이다:\n  01 needtls: 02 // skip TLS setup on Plan 9 03 CMPL runtime·isplan9(SB), $1 04 JEQ ok 05 // skip TLS setup on Solaris 06 CMPL runtime·issolaris(SB), $1 07 JEQ ok 08 09 LEAQ runtime·tls0(SB), DI 10 CALL runtime·settls(SB) 11 12 // store through it, to make sure it works 13 get_tls(BX) 14 MOVQ $0x123, g(BX) 15 MOVQ runtime·tls0(SB), AX 16 CMPQ AX, $0x123 17 JEQ 2(PC) 18 MOVL AX, 0 // abort\n TLS에 대해서는 이미 언급한 바 있고, 이제는 어떻게 구현되었는지를 알아보자. # TLS 내부 구현 이전 코드 조각을 자세히 들여다 보면, 실제로 작업을 하는 부분은 한 줄에 불과하다는 것을 쉽게 이해할 수 있다: \u0026gt;``` 1 LEAQ runtime·tls0(SB), DI 2 CALL runtime·settls(SB) 다른 부분들은 TLS가 os에서 지원되지 않을 때 건너 뛰거나 TLS가 정확하게 작동하는지 확인하는데 사용된다. 위의 두 줄은 runtime.tls0 변수의 주소를 DI 레지스터에 저장하고 runtime.settls 함수를 호출한다. 아래에서 이 함수의 코드를 살펴 보자:\n  01 // set tls base to DI 02 TEXT runtime·settls(SB),NOSPLIT,$32 03 ADDQ $8, DI // ELF wants to use -8(FS) 04 05 MOVQ DI, SI 06 MOVQ $0x1002, DI // ARCH_SET_FS 07 MOVQ $158, AX // arch_prctl 08 SYSCALL 09 CMPQ AX, $0xfffffffffffff001 10 JLS 2(PC) 11 MOVL $0xf1, 0xf1 // crash 12 RET\n 코멘트를 보면 이 함수가 *arch_prctl* 시스템 호출을 하며 *ARCH_SET_FS* 를 인수로 전달한다는 것을 알 수 있다. 또 이 시스템 호출이 *FS* 세그먼트 레지스터의 시작점(base)을 정하는 것을 볼 수 있다. 위의 경우, TLS는 *runtime.tls0* 변수를 가리킨다. main 함수의 어셈블러 코드의 시작부분에서 본 명령을 기억하는가? \u0026gt;``` 1 0x0000 00000 (test.go:3) MOVQ (TLS),CX 이전에 설명한 바 있듯이 이 명령은 runtime.g 구조체 인스턴스의 주소를 CX 레지스터에 올린다. 이 구조체는 현재 고루틴에 대한 서술이고 쓰레드 로컬 스토리지 (thread local storage)에 저장된다. 이제 이 명령이 어떻게 기계어로 번역되는지 밝혀내고 이해할 수 있다. 이전에 만든 disassembly.txt 파일을 열고 main.main 함수를 찾아보면, 첫번째 명령은 다음과 같이 생겼다:\n  1 400c00: 64 48 8b 0c 25 f0 ff mov %fs:0xfffffffffffffff0,%rcx\n (*%fs:0xfffffffffffffff0*) 명령의 콜론이 의미하는 바는 세그멘테이션의 주소화이다 (자세한 내용은 [여기](http://thestarman.pcministry.com/asm/debug/Segments.html)를 참조하라). # 시작하는 순서로 다시 돌아가서 마지막으로 *runtime.rt0_go* 함수의 마지막 두 부분을 살펴보자: \u0026gt;``` 01 ok: 02 // set the per-goroutine and per-mach \u0026quot;registers\u0026quot; 03 get_tls(BX) 04 LEAQ runtime·g0(SB), CX 05 MOVQ CX, g(BX) 06 LEAQ runtime·m0(SB), AX 07 08 // save m-\u0026gt;g0 = g0 09 MOVQ CX, m_g0(AX) 10 // save m0 to g0-\u0026gt;m 11 MOVQ AX, g_m(CX) TLS 주소를 BX 레지스터에 올리고 runtime·g0 변수의 주소를 TLS에 저장한다. runtime.m0 변수를 초기화한다. 만약 runtime.g0 가 루트 고루틴을 뜻하면 runtime.m0 는 이 고루틴을 실행하는 루트 오퍼레이팅 시스템 쓰레드에 상응한다. runtime.g0 와 runtime.m0 구조를 앞으로 나올 포스트에서 자세히 살펴볼지도 모르겠다.\n시작하는 순서의 마지막 부분은 인수를 초기화하고 여러 함수를 호출하는 것이다. 하지만 이 주제는 따로 다루어야 할 토론거리이다.\nGolang 에 대한 더 알아보기 이제 부트스트랩 과정의 내부 메커니즘에 대해 배웠고 어떻게 스택이 구현되었는지 알아 보았다. 계속 나아가기 위해서는 시작하는 순서의 마지막 부분에 대한 분석이 필요하다. 이것이 저자의 다음 포스트의 주제가 될 것이다. 언제 나올지 연락받고 싶은 독자는 밑의 subscribe 버튼을 누르던지 @altoros를 팔로우하기 바란다.\n 원문: Golang Internals, Part 5: the Runtime Bootstrap Process 저자: Siarhei Matsiukevich 번역자: Jhonghee Park  "
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/how-to-contribute-content/",
	"title": "시리즈 #5 - 사이트에 블로그 올리는 방법",
	"tags": ["Blog", "Hugo"],
	"description": "",
	"content": "사이트에 블로그 올리는 방법 Golang Korean Community 사이트는 깃헙의 golangkorea Organization의 웹사이트로 GitHub Pages를 이용해 제작되고 있습니다. 현존하는 Static Site Generator중 가장 빠른 Hugo를 엔진으로 사용하고 주로 Go언어에 관련된 포스트와 글로벌 기술 동향및 최신의 개발 기법등을 소개하는 포스트를 다루고 있습니다.\n참여자격 깃헙에 계정이 있는 개발자라면 누구나 제작에 참여하실 수 있습니다.\nFork it! Golang Korean Community 사이트는 다음과 같이 두개의 Repo를 가지고 개발됩니다.\n golangkorea-hugo Hugo로 제작하는 golangkorea.github.io의 소스 프로젝트입니다. golangkorea.github.io golangkorea-hugo의 submodule로 Hugo로 빌드된 웹사이트입니다. 직접 이 repo에서 작업하지는 않습니다.  포스트를 하기 위해서 우선 githubkorea-hugo를 fork하신다음 본인의 repo를 clone하십시요.\n$ git clone https://github.com/myaccount/golangkorea-hugo.git clone hugo-octopress 미래에는 어떻게 바뀔지 모르겠지만 현재 golangkorea.github.io는 hugo-octopress 테마를 사용하고 있습니다. themes 폴더에 clone하십시요.\n$ cd themes $ git clone https://github.com/parsiya/Hugo-Octopress.git $ cd .. Start Hugo 이제 로컬에서 사이트를 열어볼 차례입니다. 다음 명령을 사용해서 Hugo의 웹서버를 시작하십시요.\n$ hugo server http://localhost:1313를 브라우저에 열어서 사이트가 뜨는 걸 확인하십시요.\n첫번째 포스트 hugo new명령을 사용해서 포스트의 작성을 시작하십시요.\n$ hugo new post/my-frist-blog.md golangkorea.github.io는 authors taxonomy를 지원합니다. 포스트의 Front Matter에 다름과 같이 저자의 영어 이름을 입력해 주십시요.\n+++ date = \u0026quot;2016-08-28T23:01:25-04:00\u0026quot; draft = true title = \u0026quot;my first post\u0026quot; authors = [\u0026quot;Your Name\u0026quot;] +++ golangkorea.github.io는 저자의 소개 페이지를 지원합니다. 다름과 같이 본인의 이름을 hyphenated, lower-cased된 형태로 만들어 주십시요.\n$ hugo new author/your-name.md Pull Request하기 포스트의 작성이 끝나면 다음 과정을 거쳐 Pull Request해 주십시요.\n$ git add -A ... $ git commit -m\u0026quot;My first post\u0026quot; ... $ git push Pull Request에 대한 자세한 내용은 GitHub의 도움말을 참조 하세요.\n최신의 golankorea-hugo repo와 싱크하기 포스트를 한 지 좀 시간이 지나다 보면 그 사이에 사이트에 많은 변화가 있을 수 있습니다. 그때는 본인의 로컬 repo를 최신의 golangkorea-hugo와 싱크 시킬 필요가 생깁니다. 새로운 포스트를 시작하기 전에 우선 로컬의 repo에 golangkorea-hugo를 upstream remote repo로 만드시고 나머지 단계를 따라 싱크 시키십시요.\n# Add the remote, call it \u0026quot;upstream\u0026quot;: git remote add upstream https://github.com/golangkorea/golangkorea-hugo.git # Fetch all the branches of that remote into remote-tracking branches, # such as upstream/master: git fetch upstream # Make sure that you're on your master branch: git checkout master # Rewrite your master branch so that any commits of yours that # aren't already in upstream/master are replayed on top of that # other branch: git rebase upstream/master Merge를 하는 경우에는 rebase를 merge로 바꿔주시면 됩니다. 깃헙의 공식 도움말을 참조하십시요\n일단 싱크되면 본인의 forked repo에 다시 푸쉬하십시요.\ngit push -f origin master 이제 새로운 포스트를 작성하십시요.\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/pages/",
	"title": "Pages organization",
	"tags": [],
	"description": "",
	"content": "In Hugo, pages are the core of your site. Once it is configured, pages are definitely the added value to your documentation site.\nFolders Organize your site like any other Hugo project. Typically, you will have a content folder with all your pages.\ncontent ├── level-one │ ├── level-two │ │ ├── level-three │ │ │ ├── level-four │ │ │ │ ├── _index.md \u0026lt;-- /level-one/level-two/level-three/level-four │ │ │ │ ├── page-4-a.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-a │ │ │ │ ├── page-4-b.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-b │ │ │ │ └── page-4-c.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-c │ │ │ ├── _index.md \u0026lt;-- /level-one/level-two/level-three │ │ │ ├── page-3-a.md \u0026lt;-- /level-one/level-two/level-three/page-3-a │ │ │ ├── page-3-b.md \u0026lt;-- /level-one/level-two/level-three/page-3-b │ │ │ └── page-3-c.md \u0026lt;-- /level-one/level-two/level-three/page-3-c │ │ ├── _index.md \u0026lt;-- /level-one/level-two │ │ ├── page-2-a.md \u0026lt;-- /level-one/level-two/page-2-a │ │ ├── page-2-b.md \u0026lt;-- /level-one/level-two/page-2-b │ │ └── page-2-c.md \u0026lt;-- /level-one/level-two/page-2-c │ ├── _index.md \u0026lt;-- /level-one │ ├── page-1-a.md \u0026lt;-- /level-one/page-1-a │ ├── page-1-b.md \u0026lt;-- /level-one/page-1-b │ └── page-1-c.md \u0026lt;-- /level-one/page-1-c ├── _index.md \u0026lt;-- / └── page-top.md \u0026lt;-- /page-top  _index.md is required in each folder, it’s your “folder home page”\n Types Hugo-theme-learn defines two types of pages. Default and Chapter. Both can be used at any level of the documentation, the only difference being layout display.\nA Chapter displays a page meant to be used as introduction for a set of child pages. Commonly, it contains a simple title and a catch line to define content that can be found under it. You can define any HTML as prefix for the menu. In the example below, it\u0026rsquo;s just a number but that could be an icon.\n+++ title = \u0026#34;Basics\u0026#34; chapter = true weight = 5 pre = \u0026#34;\u0026lt;b\u0026gt;1. \u0026lt;/b\u0026gt;\u0026#34; +++ ### Chapter 1  # Basics Discover what this Hugo theme is all about and the core-concepts behind it. To tell Hugo-theme-learn to consider a page as a chapter, set chapter=true in the Front Matter of the page.\nA Default page is any other content page.\n+++ title = \u0026#34;Installation\u0026#34; weight = 15 +++ The following steps are here to help you initialize your new website. If you don\u0026rsquo;t know Hugo at all, we strongly suggest you to train by following this great documentation for beginners.\nCreate your project Hugo provides a new command to create a new website.\nhugo new site \u0026lt;new_project\u0026gt; Hugo-theme-learn provides archetypes to help you create this kind of pages.\nFront Matter configuration Each Hugo page has to define a Front Matter in yaml, toml or json.\nHugo-theme-learn uses the following parameters on top of Hugo ones :\n+++ # Table of content (toc) is enabled by default. Set this parameter to true to disable it. # Note: Toc is always disabled for chapter pages disableToc = \u0026#34;false\u0026#34; # If set, this will be used for the page\u0026#39;s menu entry (instead of the `title` attribute) menuTitle = \u0026#34;\u0026#34; # The title of the page in menu will be prefixed by this HTML content pre = \u0026#34;\u0026#34; # The title of the page in menu will be postfixed by this HTML content post = \u0026#34;\u0026#34; # Set the page as a chapter, changing the way it\u0026#39;s displayed chapter = false # Hide a menu entry by setting this to true hidden = false # Display name of this page modifier. If set, it will be displayed in the footer. LastModifierDisplayName = \u0026#34;\u0026#34; # Email of this page modifier. If set with LastModifierDisplayName, it will be displayed in the footer LastModifierEmail = \u0026#34;\u0026#34; +++ Add icon to a menu entry In the page frontmatter, add a pre param to insert any HTML code before the menu label. The example below uses the Github icon.\n+++ title = \u0026#34;Github repo\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-github\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; \u0026#34; +++ Ordering sibling menu/page entries Hugo provides a flexible way to handle order for your pages.\nThe simplest way is to set weight parameter to a number.\n+++ title = \u0026#34;My page\u0026#34; weight = 5 +++ Using a custom title for menu entries By default, Hugo-theme-learn will use a page\u0026rsquo;s title attribute for the menu item (or linkTitle if defined).\nBut a page\u0026rsquo;s title has to be descriptive on its own while the menu is a hierarchy. We\u0026rsquo;ve added the menuTitle parameter for that purpose:\nFor example (for a page named content/install/linux.md):\n+++ title = \u0026#34;Install on Linux\u0026#34; menuTitle = \u0026#34;Linux\u0026#34; +++ Homepage To configure your home page, you basically have three choices:\n Create an _index.md document in content folder and fill the file with Markdown content Create an index.html file in the static folder and fill the file with HTML content Configure your server to automatically redirect home page to one your documentation page  "
},
{
	"uri": "https://devbj.com/hugolearntheme/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n☕ [HTML5] span과 div의 차이  div 가로폭을 전부 차지함, span 태그 안의 내용만 차지함 div 폭과 넓이 지정가능, span 못함 div 필연적으로 줄 바꿈을 동반, span 줄 바꿈 없고 문장 중간에 들어갈 수 있음 table 태그 대신 div와 span 태그로 더욱 간결한 html을 구성할 수 있다.  [HTML5] span과 div의 차이\n"
},
{
	"uri": "https://devbj.com/wizfi360/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n원래 자동 해놨잖아..\n☕ [HTML5] span과 div의 차이  div 가로폭을 전부 차지함, span 태그 안의 내용만 차지함 div 폭과 넓이 지정가능, span 못함 div 필연적으로 줄 바꿈을 동반, span 줄 바꿈 없고 문장 중간에 들어갈 수 있음 table 태그 대신 div와 span 태그로 더욱 간결한 html을 구성할 수 있다.  [HTML5] span과 div의 차이\n"
},
{
	"uri": "https://devbj.com/wizfi360/w600/",
	"title": "W600",
	"tags": [],
	"description": "",
	"content": "W600-SDK Overview WizFi360 is based on the W600 chip which features ARM Cortex-M3 with 1MB on-chip flash and freeRTOS kernel. This page includes the software development kit (SDK) files, documents, and usage method. This SDK has integrated WizFi360 hardware driver (BSP), RTOS, TCP/IP protocol, Wi-Fi Protocol and other public function modules.\n Software SDK  Official SDK from chip vendor  Download link - WizFi360 Chip SDK (wm_sdk_w60x_g3.02.00_190729.zip)     Software SDK User Manual Basic  SDK User Manual V1.1 : Describes the functions and usage of W600 SDK. SDK DEMO User Guide V0.5 : Describes the demo code of SDK for developers. SDK GCC Compiling Guide V1.2 : Describes building in linux environment AT Command V1.0.3 : Describes the WM\u0026rsquo;s AT instruction communication protocol.  Advanced  Firmware Generation Guide V1.2 : Describes the firmware\u0026rsquo;s format, storage address and image generation. Firmware Update Guide V1.2 : Describes how to update the firmware. QFLASH Management Guide V1.2 : Describes the management of QFLASH intergrated in chip. Parameter Space Guide V1.2 : Describes how to deal with QFLASH management, key parameter space, system parameter space and user parameter space. SECBOOT Function Guide V1.1 : Describes SECBOOT functions and usages for designer and developer. SWD Debugging Guide V1.4 : Describes chip on-line debug configuration under KEIL IDE.  Chip vendor original page  All materials from WinnerMicro W600 product page  "
},
{
	"uri": "https://devbj.com/wizfi360/",
	"title": "WizFi360",
	"tags": [],
	"description": "",
	"content": "Chapter 1 WizFi360 Discover what this Hugo theme is all about and the core-concepts behind it.\n☕ 배워봐 제발!!  div 가로폭을 전부 차지함, span 태그 안의 내용만 차지함 div 폭과 넓이 지정가능, span 못함 div 필연적으로 줄 바꿈을 동반, span 줄 바꿈 없고 문장 중간에 들어갈 수 있음 table 태그 대신 div와 span 태그로 더욱 간결한 html을 구성할 수 있다.  위즈위키 방문하기\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/part6/",
	"title": "Golang의 내부, 6부: 부트스트래핑과 메모리 할당자",
	"tags": ["Golang", "Internals", "runtime", "bootstrap", "memory", "allocator"],
	"description": "",
	"content": "이 포스트는 Golang 내부 시리즈의 연속이다. Go 런타임을 자세히 이해하는데 열쇠와 같은 부트스트랩 과정을 살펴볼 것이다. 이번에는 시작하는 순서의 두번째 부분을 섭렵해서 어떻게 인수들이 초기화되고, 어떤 함수들이 호출되는지 등을 배우겠다.\n시작하는 순서 지난 번에 얘기하다가 만 runtime.rt0_go 함수를 다시 다루어야 겠다. 아직 이 함수에서 살펴보지 않은 부분이 여전히 있다.\n  01 CLD // convention is D is always left cleared 02 CALL runtime·check(SB) 03 04 MOVL 16(SP), AX // copy argc 05 MOVL AX, 0(SP) 06 MOVQ 24(SP), AX // copy argv 07 MOVQ AX, 8(SP) 08 CALL runtime·args(SB) 09 CALL runtime·osinit(SB) 10 CALL runtime·schedinit(SB)\n 첫번째 명령 (CLD)는 *FLAGS* 레지스터의 [direction](https://en.wikipedia.org/wiki/Direction_flag) 프래그를 지운다. 이 플래그는 문자열 처리 방향에 영향을 준다. 다음 함수는 *runtime.check* 함수를 호출하는데, 그 또한 이 문서의 목적에 비추어 그리 중요하지는 않다. 런타임은 모든 내장 타입의 인스턴스들을 만들고, 타입의 크기와 파라미터들을 확인하는 정도의 일을 한다. 그리고 만약 작업중 문제가 생기면 *panic* 한다. [function](https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L136)를 통해 쉽게 알아볼 수 있다. # 인수 분석하기 그 다음 함수 [runtime.Args](https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L48) 는 좀 더 흥미롭다. The next function, 리눅스 시스템에서 (*argc* 와 *argv*) 인수를 정적 변수속에 저장하는 것말고도 이 함수는 ELF 보조 벡터를 분석하며 *syscall* 주소를 초기화한다. 설명이 좀 더 필요하겠다. 운영체계가 프로그램을 메모리에 올릴때, 그 프로그램의 초기 스택을 미리 정해진 포맷의 어떤 데이타로 초기화한다. 스택의 꼭대기에는 환경 변수들의 포인터인 인수들이 깔린다. 스택의 바닥에는 \u0026quot;ELF 보조 벡터\u0026quot;를 볼 수 인데, 실제로 이 것은 어떤 유용한 정보를 담고 있는 기록의 배열들이다. 예를 들면, 프로그램 헤더의 수와 크기들이다. 여기 이 [문서](http://articles.manugarg.com/aboutelfauxiliaryvectors)를 통해 ELF 보조 벡터 포맷에 대해 좀 자세히 알아 보라. *runtime.Args* 함수는 벡터를 파싱하는 책임이 있다. 런타임은 벡터에 담고 있는 모든 정보들 중에 단지 *startupRandomData* 만을 사용하는데, 주로 헤싱 함수(hashing functions)들과 어떤 syscall들의 위치를 가리키는 포인터들을 초기화하는데 주로 사용된다. 다음에 나오는 변수들을 초기화한다: \u0026gt;``` 1 __vdso_time_sym 2 __vdso_gettimeofday_sym 3 __vdso_clock_gettime_sym 이 것들은 여러 함수들내 현재 시간을 획득하는데 사용된다. 이 모든 변수들은 기본값을 가진다. 이렇게 함으로써 Golang에서 상응하는 함수들을 호출하기 위해 vsyscall 메카니즘의 사용이 허용된다.\nruntime.osinit 함수의 내부 시작 순서에서 그 다음으로 호출되는 함수는 runtime.osinit 이다. 리눅스 시스템에서 단 한가지 하는 일이 있는데 그것은 시스템내 CPU 숫자를 가지고 있는 ncpu 변수를 한 syscall을 통해 초기화하는 것이다.\nruntime.schedinit 함수의 내부 시작 순서에서 다음 함수인 runtime.schedinit 는 더 흥미롭다. 현재의 고루틴을 얻는 것으로 시작하는데, 사실 이 것은 g 구조의 포인터이다. 이미 이 포인터가 어떻게 저장되는 지는 TLS 구현을 논할 때 얘기한 바있다. 다음은 runtime.raceinit 를 호출한다. runtime.raceinit에 대한 토론은 넘어가겠다. 왜냐하면 이 함수는 race 조건이 활성화되지 않은 경우는 보통 호출되지 않기 때문이다. 그 다음에는 몇몇 다른 초기화 함수들이 호출된다.\n하나씩 살펴보자.\ntraceback 초기화 runtime.tracebackinit 함수는 traceback을 초기화하는 일을 한다. Traceback이라는 것은 현재의 실행지점에 오기까지 호출된 함수들의 스택을 말한다. 예를 들어, panic이 일어날 때마다 볼 수 있다. Traceback은 주어진 프로그램 카운터로 runtime.gentraceback 함수를 호출함으로써 얻어진다. 이 함수가 동작하려면, 몇몇 내장함수들의 주소를 알 필요가 있는데, 그 이유는 traceback에 이 함수들이 나타나는 것을 원하지 않기 때문이다. 이 주소들은 runtime.tracebackinit 을 통해 초기화된다.\n링커 심볼들 검사하기 링커 심볼들은 링커가 실행파일과 오브젝트 파일에 뿜어내는 데이터를 말한다. 대부분의 내용은 Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치에서 논했다. runtime 패키지에서 링커 심볼들은 moduledata 구조체에 맵핑되어 있다. runtime.moduledataverify 함수를 통해 이 데이타에 대한 확인이 이루어지고 오염여부와 구조가 바른지를 검사한다.\n스택 풀 초기화하기 다음 초기화 단계를 이해하기 위해서는 Go 언어에서 스택이 어떻게 자라는지를 대한 지식이 조금 필요하다. 새로운 고루팅이 만들어 지면 작고 크기가 고정된 스택이 할당된다. 스택이 어떤 한계치에 도달하면, 크기가 두배가 되고 스택은 다른 장소로 복사된다.\n아직 살펴보아야 할 자세한 내용들로 어떻게 한계치에 도달했는지를 결정하는지, Go가 어떻게 스택내 포인터들을 조정하는지가 남아 있다. 이전 포스트에서 stackguard0 필드와 함수 메타데이더를 얘기할 때 이런 주제에 대해 약간 다루기도 했다. 이 주제에 대해 유용한 정보는 이 문서를 통해 찾을 수 있다.\nGo는 현재 이용되지 않은 스택들을 저장하기 위해 스택 풀을 이용한다. 스택 풀은 runtime.stackinit 함수내 초기화된 배열이다. 이 배열안의 각 아이템은 같은 크기를 갖는 스택들의 linked list 구조를 담고 있다.\n이 단계에 초기화되는 또 다른 변수로 runtime.stackFreeQueue 가 있다. 이것 역시 스택들로 이루어진 linked list를 담고 있지만, 가비지 컬렉션중에 리스트에 추가되며 끝나면 지워진다. 2 KB, 4 KB, 8 KB 그리고 16 KB 크기의 스택만이 저장되고 그 보다 큰 것들은 직접 할당되는 점을 주목하라.\n메모리 할당자 초기화하기 메모리 할당 과정은 이 소스 코드 커밋에 서술되어 있다. 메모리 할당이 어떻게 작동하는지를 이해하고자 한다면 꼭 읽어 보길 권장한다. 이 주제는 앞으로 나올 포스트에서 더 자세히 다루도록 하겠다. 메모리 할당자의 초기화는 runtime.mallocinit 함수내 자리잡고 있다. 가까이 들여다 보자.\n사이즈 클래스들(size classes)를 초기화하기 여기에 처음 볼 수 있는 것은 runtime.mallocinit 가 또 다른 함수-initSizes 를 호출하는 것이다. 이 함수는 사이즈 클래스들를 계산하는 일을 한다. 하지만 클래스의 크기를 어떻게 결정하는가? (32 KB 가 안되는) 작은 객체를 할당할 때, Go 런타임은 처음 미리 정해둔 클래스 크기로 객체의 크기를 반올림한다. 그래서 할당된 메모리 블록은 실제 필요한 객체 크기보 보통 좀 더 큰, 미리 정해진 크기들중에 하나를 선택할 수 밖에 없다. 이로 인해 메모리가 조금 낭비되긴 하지만 이 방법을 통해서 다른 객체에 이미 할당된 메모리를 재사용하는 것이 용이해 진다.\ninitSizes 함수는 이런 클래스를 계산하는 일을 한다. 함수 꼭대기에서 다음 코드를 볼 수 있다:\n  01 align := 8 02 for size := align; size \u0026lt;= _MaxSmallSize; size += align { 03 if size\u0026amp;(size-1) == 0 { 04 if size \u0026gt;= 2048 { 05 align = 256 06 } else if size \u0026gt;= 128 { 07 align = size / 8 08 } else if size \u0026gt;= 16 { 09 align = 16 10 … 11 } 12 }\n 보다시피 가장 작은 사이즈 클래스들은 8과 16 바이트이다. 그 다음 클래스는 128 바이트까지 16 바이트가 올라갈 때마다 위치해 있다. 128부터 2,048 바이트까지는 size/8 바이트마다 클래스가 위치해 있다. 2,048 바이트 이후에는 256 바이트마다 사이즈 클래스가 위치해 있다. *initSizes* 메서드는 *[class_to_size](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L49)* 배열을 초기화한다. 이 배열은 하나의 클래스(여기에서 크기라 함은 클래스 리스트내 서열을 의미한다)를 그 크기로 변환한다. 이 함수는 또 *[class_to_allocnpages](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L50)* 배열을 초기화하는데 이 배열은 주어진 클래스의 객체를 채우기 위해 OS로 부터 얼마나 많은 메모리 페이지를 받아내야 하는가에 대한 데이터를 저장한다. 이외 배열을 두개 더-*[size_to_class8](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L53)* 와 *[size_to_class128](https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L54)* 를 초기화한다. 이 두 배열은 객체 크기로 부터 상응하는 클래스 서열로 변환하는데 사용되는데 첫번째 것은 1 KB 보다 작은 객체의 크기를 변환하고, 두번째는 1-32 KB 크기의 객체에 대한 변환을 맡는다. # 가상 메모리 예약하기 *mallocinit* 함수가 다음으로 하는 일은 미래에 있을 할당들을 위해 가상 메모리를 예약하는 것이다. x64 아키텍쳐에서 이것이 어떻게 구현되었는지 알아보자. 무엇보다도 우선 다음 변수들을 초기화해야 한다: \u0026gt;``` 1 arenaSize := round(_MaxMem, _PageSize) 2 bitmapSize = arenaSize / (ptrSize * 8 / 4) 3 spansSize = arenaSize / _PageSize * ptrSize 4 spansSize = round(spansSize, _PageSize)  arenaSize 은 객체 할당의 예약에 사용될 수 있는 가상 메모리의 최대치이다. 64비트 아키텍쳐에서는 512 GB에 해당한다. bitmapSize 는 가비지 컬렉션 (GC) 비트맵을 위해 예약될 수 있는 메모리의 양에 상응한다. GC 비트맵은 특별한 메모리 타입으로 메모리에서 포인터들이 정확히 어디에 위치하는지를 보여주는데 사용되고 이 포인터들이 가리키는 객체들이 GC에 의해 표시(mark)될 것인지의 여부를 결정하는데 사용된다. spansSize 는 모든 메모리 스팬(memory span)들을 가리키는 포인터들의 배열을 저장하기 위해 얼마나 많은 메모리를 예약되었는지를 나타낸다. 메모리 스팬은 객체 할당을 위해 사용된 메모리 블록를 둘러 싸는 구조이다.  이 변수들이 모두 계산되면, 실제 예약이 끝나는 것이다:\n  1 pSize = bitmapSize + spansSize + arenaSize + _PageSize 2 p = uintptr(sysReserve(unsafe.Pointer(p), pSize, \u0026amp;reserved))\n 마침내, 모든 메모리에 상관된 객체들을 위한 중앙 저장소로 사용될 *[mheap](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L65)* 전역 변수를 초기화 할 수 있다. \u0026gt;``` 1 p1 := round(p, _PageSize) 2 3 mheap_.spans = (**mspan)(unsafe.Pointer(p1)) 4 mheap_.bitmap = p1 + spansSize 5 mheap_.arena_start = p1 + (spansSize + bitmapSize) 6 mheap_.arena_used = mheap_.arena_start 7 mheap_.arena_end = p + pSize 8 mheap_.arena_reserved = reserved 처음부터, *mheap_.arena_used* 가 *mheap_.arena_start* 와 동일한 주소를 가지고 초기화되었음을 주목하라. 이유는 아직 아무 것도 할당되지 않았기 때문이다.\n힢(Heap) 초기화 다음으로 mHeap_Init 함수가 호출된다. 할당자의 초기화가 제일 먼저 진행되었다.\n  1 fixAlloc_Init(\u0026amp;h.spanalloc, unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), \u0026amp;memstats.mspan_sys) 2 fixAlloc_Init(\u0026amp;h.cachealloc, unsafe.Sizeof(mcache{}), nil, nil, \u0026amp;memstats.mcache_sys) 3 fixAlloc_Init(\u0026amp;h.specialfinalizeralloc, unsafe.Sizeof(specialfinalizer{}), nil, nil, \u0026amp;memstats.other_sys) 4 fixAlloc_Init(\u0026amp;h.specialprofilealloc, unsafe.Sizeof(specialprofile{}), nil, nil, \u0026amp;memstats.other_sys)\n 할당자가 무엇인가를 더 잘 이해하기 위해서, 우선 어떻게 사용되는지 살펴보자. 모든 할당자는 *[fixAlloc_Alloc](https://github.com/golang/go/blob/go1.5.1/src/runtime/mfixalloc.go#L54)* 함수 내에서 운영된다. 이 함수는 다음과 같은 구조체의 새로운 할당이 필요할때 호출된다 - *[mspan](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L101)*, *[mcache](https://github.com/golang/go/blob/go1.5.1/src/runtime/mcache.go#L11)*, *[specialfinalizer](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1009)*, 그리고 *[specialprofile](https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1050)*. 이 함수의 주요한 부분은: \u0026gt;``` 1 if uintptr(f.nchunk) \u0026lt; f.size { 2 f.chunk = (*uint8)(persistentalloc(_FixAllocChunk, 0, f.stat)) 3 f.nchunk = _FixAllocChunk 4 } 이 부분은 메모리를 할당하지만 구조체의 실제 크기인 f.size 바이트를 할당하는 대신 (현재는 16 KB)인 _FixAllocChunk 바이트를 따로 떼어 놓은다. 나머지 사용가능한 공간은 할당자내 저장된다. 다음번에 같은 타입의 구조체를 할당할 필요가 있으면 시간을 많이 소비하는 persistentalloc를 호출할 필요가 없게 된다.\npersistentalloc 함수는 가비지 컬렉트되어서는 않되는 메모리를 할당하는 일을 한다. 이 함수의 웍플로우는 다음과 같다:\n 만약 할당된 블록이 64 KB보다 크면 OS 메모리로 부터 직접 할당된다. 그렇기 않은 경우는, 우선 지속성 할당자(persistent allocator)를 찾을 필요가 있다.  지속성 할당자는 각 프로세서에 부착되어 있다. 이유는 하나만 가지고 작업할 경우 locks을 사용해야 함을 피하기 위해서이다. 그래서 현재 프로세서에 부착된 지속성 할당자를 사용하고자 하는 것이다. 만약 현재 프로세서의 정보를 얻을 수 없는 경우는, 전역 할당자 (global allocator)가 사용된다.   만약 할당자가 캐쉬에 사용가능한 메모리가 충분치 않을 경우는 OS로 부터 메모리를 더 가지고 온다. 필요한 만큼의 메모리가 할당자의 캐쉬에서 반환된다.  persistentalloc 과 fixAlloc_Alloc 함수는 비슷하게 작동한다. 이 함수들은 두가지 레벨의 캐쉬를 구현하고 있다고 말할 수 있겠다. persistentalloc 는 fixAlloc_Alloc 에만 사용되는 것이 아니라 지속성 메모리(persistent memory)를 할당할 필요가 있는 여러 군데에서 사용되고 있다는 것을 숙지하여야 한다.\nmHeap_Init 함수로 다시 돌아가자. 답을 해야할 중요한 질문이 하나 더 있는데, 그것은 이 함수의 시작부분에서 할당자가 초기화되는 목적이었더 네개의 구조가 어떻게 사용되는지에 대한 것이다:\n mspan 는 가비지 컬렉트되어야 하는 메모리 블록을 감싸는 것이다. 사이즈 클래스들(size classes)을 논할 때 얘기했었다. 특정한 사이즈 클라스의 새로운 객체를 할당할 필요가 생겼을때 새로운 mspan이 만들어진다. mcache 는 각 프로세서에 부착된 구조체이다. 메모리 스팬을 캐취에 저장하는 일을 한다. 프로세스마다 따로 캐쉬를 갖는 이유는 locking을 피하기 위해서 이다. specialfinalizeralloc 는 runtime.SetFinalizer 함수가 호출될 때 할당되는 구조체이다. 객체가 제거되면서 정리정돈(cleanup)하는 코드를 실행시키길 원한다면 이 구조체를 만들어야 할 것이다. 좋은 예제로 새로운 파일마다 finalizer를 연계시키는 os.NewFile 함수이다. 이 finalizer가 OS 파일 설명자(file descriptor)를 닫아야 한다. specialprofilealloc 는 메모리 프로파일러에 사용되는 구조체이다.  메모리 할당자들을 초기화하고 난 후, mHeap_Init 함수는 mSpanList_Init 을 호출함으로서 리스트들을 초기화 한다. 간단한 일로 linked 리스트를 위한 첫번째 입력을 초기화하는 것이다. mheap 구조체는 그러한 linked 리스트를 몇개 가지고 있다.\n mheap.free 와 mheap.busy 는 free 와 busy 리스트를 담고 있는 배열들로 대형(32 KB보다 크고, 1 MB보다 작은) 객체들을 위한 메모리 스팬을 갖고 있다. 각 배열은 가능한 크기의 아이템을 가지고 있다. 여기서 크기들은 페이지로 측정된다. 한 페이지는 32 KB에 해당한다. 첫번째 아이템은 32 KB 스팬을 가지는 리스트를 담고 있고, 두번째는 64 KB 스팬을 가지는 리스트를 담고 있는 그런 식이다. mheap.freelarge 와 mheap.busylarge 는 1 MB이상의 객체들을 위한 free 와 busy 리스트들이다.  다음 단계는 mheap.central 를 초기화하는 것인데, (32 KB 보다 작은) 소형 객체들을 위한 스팬들을 저장한다. mheap.central 안에서는 리스트가 사이즈 클래스에 맞게 그룹을 형성한다. 초기화는 이제까지 우리가 본 것들과 유사하다. 단순히 각 free 리스트에 대한 linked 리스트를 초기화 하는 것이다.\n캐쉬의 초기화 이제 메모리 할당자 초기화에 대한 얘기가 거의 끝나간다. mallocinit 함수내 마지막으로 남은 것은 mcache 초기화이다:\n  1 g := getg() 2 g.m.mcache = allocmcache()\n 여기를 보면, 우선 현재의 고루틴을 얻는다. 각 고루틴은 *m* 구조체로 연결된 링크를 담고 있다. 이 구조체는 시스템 쓰레드를 감싸는 구조이다. 이 구조체의 내부에는 *mcache* 라는 필드가 있는데 위에보면 초기화되고 있다. *allocmcache* 함수는 *fixAlloc_Alloc* 을 호출하여 새로운 *mcache* 구조체를 초기화한다. 이미 어떻게 할당이 되었는지 이 구조체의 의미는 무엇인지에 대해서 논한 바 있다 (상위의 내용을 살펴보라). 조심스런 독자는 저자가 *mcache* 가 프로세스마다 부착되어 있다고 얘기한 걸 기억할 것이다. 그런데 이제 보니 프로세서(processor)가 아닌 OS 프로세스(process)에 상응하는 *m* 구조체에 부착되어 있는 것이었다. 그게 맞는 말이다-mcache는 현재 실행중인 쓰레드에 대해서만 초기화되며 프로세스가 바뀔때(process switch) 마다 또 다른 쓰레드로 재배치된다. # 곧 추가될 Go 부트스트래핑에 대한 포스트 다음 포스트에서는 어떻게 가비지 컬랙터가 초기화되는지 긔고 어떻게 main 고루틴이 시작되는지를 살펴보며 부트스트랩 과정을 더 논하겠다. 그때까지 아래 코멘트란에 독자의 생각이나 의견을 공유하는데 주저하지 말라. * 원문: [Golang Internals, Part 6: Bootstrapping and Memory Allocator Initialization](http://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html) * 저자: Siarhei Matsiukevich * 번역자: Jhonghee Park "
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/",
	"title": "Content",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Content Find out how to create and organize your content quickly and intuitively.\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/archetypes/",
	"title": "Archetypes",
	"tags": [],
	"description": "",
	"content": "Using the command: hugo new [relative new content path], you can start a content file with the date and title automatically set. While this is a welcome feature, active writers need more : archetypes.\nIt is pre-configured skeleton pages with default front matter. Please refer to the documentation for types of page to understand the differences.\nChapter To create a Chapter page, run the following commands\nhugo new --kind chapter \u0026lt;name\u0026gt;/_index.md It will create a page with predefined Front-Matter:\n+++ title = \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date = {{ .Date }} weight = 5 chapter = true pre = \u0026#34;\u0026lt;b\u0026gt;X. \u0026lt;/b\u0026gt;\u0026#34; +++ ### Chapter X  # Some Chapter title Lorem Ipsum. Default To create a default page, run either one of the following commands\n# Either hugo new \u0026lt;chapter\u0026gt;/\u0026lt;name\u0026gt;/_index.md # Or hugo new \u0026lt;chapter\u0026gt;/\u0026lt;name\u0026gt;.md It will create a page with predefined Front-Matter:\n+++ title = \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date = {{ .Date }} weight = 5 +++ Lorem Ipsum. "
},
{
	"uri": "https://devbj.com/hugolearntheme/basics/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": "Thanks to the simplicity of Hugo, this page is as empty as this theme needs requirements.\nJust download latest version of Hugo binary (\u0026gt; 0.25) for your OS (Windows, Linux, Mac) : it\u0026rsquo;s that simple.\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/markdown/",
	"title": "Markdown syntax",
	"tags": [],
	"description": "",
	"content": " This page is a shameful copy of the great Grav original page. Only difference is information about image customization (resizing, add CSS classes\u0026hellip;)\n Let\u0026rsquo;s face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages.\nMarkdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it.\nSome of the key benefits are:\n Markdown is simple to learn, with minimal extra characters so it\u0026rsquo;s also quicker to write content. Less chance of errors when writing in markdown. Produces valid XHTML output. Keeps the content and the visual display separate, so you cannot mess up the look of your site. Write in any text editor or Markdown application you like. Markdown is a joy to use!  John Gruber, the author of Markdown, puts it like this:\n The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email. \u0026ndash; John Gruber Grav ships with built-in support for Markdown and Markdown Extra. You must enable Markdown Extra in your system.yaml configuration file\nWithout further delay, let us go over the main elements of Markdown and what the resulting HTML looks like:\nBookmark this page for easy future reference!\n Headings Headings from h1 through h6 are constructed with a # for each level:\n# h1 Heading ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading Renders to:\nh1 Heading h2 Heading h3 Heading h4 Heading h5 Heading h6 Heading HTML:\n\u0026lt;h1\u0026gt;h1 Heading\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;h2 Heading\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;h3 Heading\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;h4 Heading\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;h5 Heading\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;h6 Heading\u0026lt;/h6\u0026gt; Comments Comments should be HTML compatible\n\u0026lt;!--This is a comment --\u0026gt; Comment below should NOT be seen:\nHorizontal Rules The HTML \u0026lt;hr\u0026gt; element is for creating a \u0026ldquo;thematic break\u0026rdquo; between paragraph-level elements. In markdown, you can create a \u0026lt;hr\u0026gt; with any of the following:\n ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks  renders to:\n   Body Copy Body copy written as normal, plain text will be wrapped with \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; tags in the rendered HTML.\nSo this body copy:\nLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. renders to this HTML:\n\u0026lt;p\u0026gt;Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u0026lt;/p\u0026gt; Emphasis Bold For emphasizing a snippet of text with a heavier font-weight.\nThe following snippet of text is rendered as bold text.\n**rendered as bold text** renders to:\nrendered as bold text\nand this HTML\n\u0026lt;strong\u0026gt;rendered as bold text\u0026lt;/strong\u0026gt; Italics For emphasizing a snippet of text with italics.\nThe following snippet of text is rendered as italicized text.\n_rendered as italicized text_ renders to:\nrendered as italicized text\nand this HTML:\n\u0026lt;em\u0026gt;rendered as italicized text\u0026lt;/em\u0026gt; strikethrough In GFM (GitHub flavored Markdown) you can do strikethroughs.\n~~Strike through this text.~~ Which renders to:\nStrike through this text.\nHTML:\n\u0026lt;del\u0026gt;Strike through this text.\u0026lt;/del\u0026gt; Blockquotes For quoting blocks of content from another source within your document.\nAdd \u0026gt; before any text you want to quote.\n\u0026gt; **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. Renders to:\n Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\n and this HTML:\n\u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Fusion Drive\u0026lt;/strong\u0026gt; combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt; Blockquotes can also be nested:\n\u0026gt; Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u0026gt; \u0026gt; \u0026gt; Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. \u0026gt; \u0026gt; Mauris sit amet ligula egestas, feugiat metus tincidunt, luctus libero. Donec congue finibus tempor. Vestibulum aliquet sollicitudin erat, ut aliquet purus posuere luctus. Renders to:\n Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi.\n Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.\n Mauris sit amet ligula egestas, feugiat metus tincidunt, luctus libero. Donec congue finibus tempor. Vestibulum aliquet sollicitudin erat, ut aliquet purus posuere luctus.\n Notices The old mechanism for notices overriding the block quote syntax (\u0026gt;\u0026gt;\u0026gt;) has been deprecated. Notices are now handled via a dedicated plugin called Markdown Notices\n Lists Unordered A list of items in which the order of the items does not explicitly matter.\nYou may use any of the following symbols to denote bullets for each list item:\n* valid bullet - valid bullet + valid bullet For example\n+ Lorem ipsum dolor sit amet + Consectetur adipiscing elit + Integer molestie lorem at massa + Facilisis in pretium nisl aliquet + Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at + Faucibus porta lacus fringilla vel + Aenean sit amet erat nunc + Eget porttitor lorem Renders to:\n Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit  Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at   Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem  And this HTML\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem ipsum dolor sit amet\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consectetur adipiscing elit\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Integer molestie lorem at massa\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Facilisis in pretium nisl aliquet\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Nulla volutpat aliquam velit \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Phasellus iaculis neque\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Purus sodales ultricies\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Vestibulum laoreet porttitor sem\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Ac tristique libero volutpat at\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Faucibus porta lacus fringilla vel\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aenean sit amet erat nunc\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Eget porttitor lorem\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Ordered A list of items in which the order of items does explicitly matter.\n1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem Renders to:\n Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem  And this HTML:\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Lorem ipsum dolor sit amet\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consectetur adipiscing elit\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Integer molestie lorem at massa\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Facilisis in pretium nisl aliquet\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Nulla volutpat aliquam velit\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Faucibus porta lacus fringilla vel\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aenean sit amet erat nunc\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Eget porttitor lorem\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; TIP: If you just use 1. for each number, Markdown will automatically number each item. For example:\n1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem Renders to:\n Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem  Code Inline code Wrap inline snippets of code with `.\nIn this example, `\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;` should be wrapped as **code**. Renders to:\nIn this example, \u0026lt;section\u0026gt;\u0026lt;/section\u0026gt; should be wrapped as code.\nHTML:\n\u0026lt;p\u0026gt;In this example, \u0026lt;code\u0026gt;\u0026amp;lt;section\u0026amp;gt;\u0026amp;lt;/section\u0026amp;gt;\u0026lt;/code\u0026gt; should be wrapped as \u0026lt;strong\u0026gt;code\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt; Indented code Or indent several lines of code by at least four spaces, as in:\nRenders to:\n// Some comments line 1 of code line 2 of code line 3 of code  HTML:\n\u0026lt;pre\u0026gt; \u0026lt;code\u0026gt; // Some comments line 1 of code line 2 of code line 3 of code \u0026lt;/code\u0026gt; \u0026lt;/pre\u0026gt; Block code \u0026ldquo;fences\u0026rdquo; Use \u0026ldquo;fences\u0026rdquo; ``` to block in multiple lines of code.\nSample text here... HTML:\n\u0026lt;pre\u0026gt; \u0026lt;code\u0026gt;Sample text here...\u0026lt;/code\u0026gt; \u0026lt;/pre\u0026gt; Syntax highlighting GFM, or \u0026ldquo;GitHub Flavored Markdown\u0026rdquo; also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code \u0026ldquo;fence\u0026rdquo;, ```js, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code:\nRenders to:\ngrunt.initConfig({ assemble: { options: { assets: \u0026#39;docs/assets\u0026#39;, data: \u0026#39;src/data/*.{json,yml}\u0026#39;, helpers: \u0026#39;src/custom-helpers.js\u0026#39;, partials: [\u0026#39;src/partials/**/*.{hbs,md}\u0026#39;] }, pages: { options: { layout: \u0026#39;default.hbs\u0026#39; }, files: { \u0026#39;./\u0026#39;: [\u0026#39;src/templates/pages/index.hbs\u0026#39;] } } } }; Tables Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned.\n| Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | Renders to:\n   Option Description     data path to data files to supply the data that will be passed into templates.   engine engine to be used for processing templates. Handlebars is the default.   ext extension to be used for dest files.    And this HTML:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Option\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;data\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;path to data files to supply the data that will be passed into templates.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;engine\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;engine to be used for processing templates. Handlebars is the default.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;ext\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;extension to be used for dest files.\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Right aligned text Adding a colon on the right side of the dashes below any heading will right align text for that column.\n| Option | Description | | ------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. |    Option Description     data path to data files to supply the data that will be passed into templates.   engine engine to be used for processing templates. Handlebars is the default.   ext extension to be used for dest files.    Links Basic link [Assemble](http://assemble.io) Renders to (hover over the link, there is no tooltip):\nAssemble\nHTML:\n\u0026lt;a href=\u0026#34;http://assemble.io\u0026#34;\u0026gt;Assemble\u0026lt;/a\u0026gt; Add a title [Upstage](https://github.com/upstage/ \u0026#34;Visit Upstage!\u0026#34;) Renders to (hover over the link, there should be a tooltip):\nUpstage\nHTML:\n\u0026lt;a href=\u0026#34;https://github.com/upstage/\u0026#34; title=\u0026#34;Visit Upstage!\u0026#34;\u0026gt;Upstage\u0026lt;/a\u0026gt; Named Anchors Named anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters:\n# Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) will jump to these sections:\n## Chapter 1 \u0026lt;a id=\u0026#34;chapter-1\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; Content for chapter one. ## Chapter 2 \u0026lt;a id=\u0026#34;chapter-2\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; Content for chapter one. ## Chapter 3 \u0026lt;a id=\u0026#34;chapter-3\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; Content for chapter one. NOTE that specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works.\nImages Images have a similar syntax to links but include a preceding exclamation point.\n![Minion](https://octodex.github.com/images/minion.png) or\n![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \u0026#34;The Stormtroopocat\u0026#34;) Like links, Images also have a footnote style syntax\nAlternative usage : note images ![Alt text][id] With a reference later in the document defining the URL location:\n[id]: https://octodex.github.com/images/dojocat.jpg \u0026quot;The Dojocat\u0026quot;  Resizing image Add HTTP parameters width and/or height to the link image to resize the image. Values are CSS values (default is auto).\n![Minion](https://octodex.github.com/images/minion.png?width=20pc) ![Minion](https://octodex.github.com/images/minion.png?height=50px) ![Minion](https://octodex.github.com/images/minion.png?height=50px\u0026amp;width=300px) Add CSS classes Add a HTTP classes parameter to the link image to add CSS classes. shadowand border are available but you could define other ones.\n![stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg?classes=shadow) ![stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg?classes=border) ![stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg?classes=border,shadow) Lightbox Add a HTTP featherlight parameter to the link image to disable lightbox. By default lightbox is enabled using the featherlight.js plugin. You can disable this by defining featherlight to false.\n![Minion](https://octodex.github.com/images/minion.png?featherlight=false) "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/",
	"title": "Shortcodes",
	"tags": [],
	"description": "",
	"content": "Hugo uses Markdown for its simple content format. However, there are a lot of things that Markdown doesn’t support well. You could use pure HTML to expand possibilities.\nBut this happens to be a bad idea. Everyone uses Markdown because it\u0026rsquo;s pure and simple to read even non-rendered. You should avoid HTML to keep it as simple as possible.\nTo avoid this limitations, Hugo created shortcodes. A shortcode is a simple snippet inside a page.\nHugo-theme-learn provides multiple shortcodes on top of existing ones.\n Attachments  The Attachments shortcode displays a list of files attached to a page.\n Button  Nice buttons on your page.\n Children  List the child pages of a page\n Expand  Displays an expandable/collapsible section of text on your page\n Mermaid  Generation of diagram and flowchart from text in a similar manner as markdown\n Notice  Disclaimers to help you structure your page\n Site param  Get value of site params variables in your page.\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/basics/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "The following steps are here to help you initialize your new website. If you don\u0026rsquo;t know Hugo at all, we strongly suggest you learn more about it by following this great documentation for beginners.\nCreate your project Hugo provides a new command to create a new website.\nhugo new site \u0026lt;new_project\u0026gt; Install the theme Install the Hugo-theme-learn theme by following this documentation\nThis theme\u0026rsquo;s repository is: https://github.com/matcornic/hugo-theme-learn.git\nAlternatively, you can download the theme as .zip file and extract it in the themes directory\nBasic configuration When building the website, you can set a theme by using --theme option. However, we suggest you modify the configuration file (config.toml) and set the theme as the default. You can also add the [outputs] section to enable the search functionality.\n# Change the default theme to be use when building the site with Hugo theme = \u0026#34;hugo-theme-learn\u0026#34; # For search functionality [outputs] home = [ \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] Create your first chapter page Chapters are pages that contain other child pages. It has a special layout style and usually just contains a chapter name, the title and a brief abstract of the section.\n### Chapter 1 # Basics Discover what this Hugo theme is all about and the core concepts behind it. renders as\nHugo-theme-learn provides archetypes to create skeletons for your website. Begin by creating your first chapter page with the following command\nhugo new --kind chapter basics/_index.md By opening the given file, you should see the property chapter=true on top, meaning this page is a chapter.\nBy default all chapters and pages are created as a draft. If you want to render these pages, remove the property draft: true from the metadata.\nCreate your first content pages Then, create content pages inside the previously created chapter. Here are two ways to create content in the chapter:\nhugo new basics/first-content.md hugo new basics/second-content/_index.md Feel free to edit thoses files by adding some sample content and replacing the title value in the beginning of the files.\nLaunching the website locally Launch by using the following command:\nhugo serve Go to http://localhost:1313\nYou should notice three things:\n You have a left-side Basics menu, containing two submenus with names equal to the title properties in the previously created files. The home page explains how to customize it by following the instructions. When you run hugo serve, when the contents of the files change, the page automatically refreshes with the changes. Neat!  Build the website When your site is ready to deploy, run the following command:\nhugo A public folder will be generated, containing all static content and assets for your website. It can now be deployed on any web server.\nThis website can be automatically published and hosted with Netlify (Read more about Automated HUGO deployments with Netlify). Alternatively, you can use Github pages\n "
},
{
	"uri": "https://devbj.com/golangkorea/go-walkthrough/",
	"title": "Go 둘러보기",
	"tags": ["Golang", "Internals", "Compiler", "Structure"],
	"description": "",
	"content": "Go 둘러보기\n페이지 리스트  Go 둘러보기 - bytes \u0026#43; strings 패키지  Go Walkthrough 시리즈의 Go Walkthrough: bytes + strings packages를 번역한 글입니다. 우린 지난번 포스트에서 바이트 스트림을 다뤄봤는데 가끔은 제한적인 범위에서, 인메모리 바이트 슬\n Go 둘러보기 - encoding/json 패키지  Go Walkthrough 시리즈의 Go Walkthrough: encoding/json package를 번역한 글입니다. 좋든 나쁘든, JSON은 인터넷의 인코딩이다. 이것의 공식적인 정의는 냅킨 뒷면에 쓸 수 있을 정도로 간단\n Go 둘러보기 - encoding 패키지  Go Walkthrough 시리즈의 Go Walkthrough: encoding package를 번역한 글입니다. 우리는 이제까지 로우(raw) 바이트 스트림과 제한된 바이트 슬라이스를 다뤄봤지만 단순히 바이트만을\n Go 둘러보기 - io 패키지  Go Walkthrough 시리즈의 Go Walkthrough: io package를 번역한 글입니다. Go는 바이트(bytes)를 사용하여 작업하기 위해 만들어진 프로그래밍 언어이다. 바이트의 리스트\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/basics/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "Global site parameters On top of Hugo global configuration, Hugo-theme-learn lets you define the following parameters in your config.toml (here, values are default).\nNote that some of these parameters are explained in details in other sections of this documentation.\n[params] # Prefix URL to edit current page. Will display an \u0026#34;Edit this page\u0026#34; button on top right hand corner of every page.  # Useful to give opportunity to people to create merge request for your doc. # See the config.toml file from this documentation site to have an example. editURL = \u0026#34;\u0026#34; # Author of the site, will be used in meta information author = \u0026#34;\u0026#34; # Description of the site, will be used in meta information description = \u0026#34;\u0026#34; # Shows a checkmark for visited pages on the menu showVisitedLinks = false # Disable search function. It will hide search bar disableSearch = false # Javascript and CSS cache are automatically busted when new version of site is generated.  # Set this to true to disable this behavior (some proxies don\u0026#39;t handle well this optimization) disableAssetsBusting = false # Set this to true to disable copy-to-clipboard button for inline code. disableInlineCopyToClipBoard = false # A title for shortcuts in menu is set by default. Set this to true to disable it.  disableShortcutsTitle = false # When using mulitlingual website, disable the switch language button. disableLanguageSwitchingButton = false # Hide breadcrumbs in the header and only show the current page title disableBreadcrumb = true # Hide Next and Previous page buttons normally displayed full height beside content disableNextPrev = true # Order sections in menu by \u0026#34;weight\u0026#34; or \u0026#34;title\u0026#34;. Default to \u0026#34;weight\u0026#34; ordersectionsby = \u0026#34;weight\u0026#34; # Change default color scheme with a variant one. Can be \u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;. themeVariant = \u0026#34;\u0026#34; Activate search If not already present, add the follow lines in the same config.toml file.\n[outputs] home = [ \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] Learn theme uses the last improvement available in hugo version 20+ to generate a json index file ready to be consumed by lunr.js javascript search engine.\n Hugo generate lunrjs index.json at the root of public folder. When you build the site with hugo server, hugo generates it internally and of course it doesn’t show up in the filesystem\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/menushortcuts/",
	"title": "Menu extra shortcuts",
	"tags": [],
	"description": "",
	"content": "You can define additional menu entries or shortcuts in the navigation menu without any link to content.\nBasic configuration Edit the website configuration config.toml and add a [[menu.shortcuts]] entry for each link your want to add.\nExample from the current website:\n[[menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fab fa-github'\u0026gt;\u0026lt;/i\u0026gt; Github repo\u0026quot; identifier = \u0026quot;ds\u0026quot; url = \u0026quot;https://github.com/matcornic/hugo-theme-learn\u0026quot; weight = 10 [[menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-camera'\u0026gt;\u0026lt;/i\u0026gt; Showcases\u0026quot; url = \u0026quot;/showcase\u0026quot; weight = 11 [[menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bookmark'\u0026gt;\u0026lt;/i\u0026gt; Hugo Documentation\u0026quot; identifier = \u0026quot;hugodoc\u0026quot; url = \u0026quot;https://gohugo.io/\u0026quot; weight = 20 [[menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bullhorn'\u0026gt;\u0026lt;/i\u0026gt; Credits\u0026quot; url = \u0026quot;/credits\u0026quot; weight = 30  By default, shortcuts are preceded by a title. This title can be disabled by setting disableShortcutsTitle=true. However, if you want to keep the title but change its value, it can be overriden by changing your local i18n translation string configuration.\nFor example, in your local i18n/en.toml file, add the following content\n[Shortcuts-Title] other = \u0026quot;\u0026lt;Your value\u0026gt;\u0026quot;  Read more about hugo menu and hugo i18n translation strings\nConfiguration for Multilingual mode When using a multilingual website, you can set different menus for each language. In the config.toml file, prefix your menu configuration by Languages.\u0026lt;language-id\u0026gt;.\nExample from the current website:\n[Languages] [Languages.en] title = \u0026quot;Documentation for Hugo Learn Theme\u0026quot; weight = 1 languageName = \u0026quot;English\u0026quot; [[Languages.en.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fab fa-github'\u0026gt;\u0026lt;/i\u0026gt; Github repo\u0026quot; identifier = \u0026quot;ds\u0026quot; url = \u0026quot;https://github.com/matcornic/hugo-theme-learn\u0026quot; weight = 10 [[Languages.en.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-camera'\u0026gt;\u0026lt;/i\u0026gt; Showcases\u0026quot; url = \u0026quot;/showcase\u0026quot; weight = 11 [[Languages.en.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bookmark'\u0026gt;\u0026lt;/i\u0026gt; Hugo Documentation\u0026quot; identifier = \u0026quot;hugodoc\u0026quot; url = \u0026quot;https://gohugo.io/\u0026quot; weight = 20 [[Languages.en.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bullhorn'\u0026gt;\u0026lt;/i\u0026gt; Credits\u0026quot; url = \u0026quot;/credits\u0026quot; weight = 30 [Languages.fr] title = \u0026quot;Documentation du thème Hugo Learn\u0026quot; weight = 2 languageName = \u0026quot;Français\u0026quot; [[Languages.fr.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fab fa-github'\u0026gt;\u0026lt;/i\u0026gt; Repo Github\u0026quot; identifier = \u0026quot;ds\u0026quot; url = \u0026quot;https://github.com/matcornic/hugo-theme-learn\u0026quot; weight = 10 [[Languages.fr.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-camera'\u0026gt;\u0026lt;/i\u0026gt; Vitrine\u0026quot; url = \u0026quot;/showcase\u0026quot; weight = 11 [[Languages.fr.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bookmark'\u0026gt;\u0026lt;/i\u0026gt; Documentation Hugo\u0026quot; identifier = \u0026quot;hugodoc\u0026quot; url = \u0026quot;https://gohugo.io/\u0026quot; weight = 20 [[Languages.fr.menu.shortcuts]] name = \u0026quot;\u0026lt;i class='fas fa-bullhorn'\u0026gt;\u0026lt;/i\u0026gt; Crédits\u0026quot; url = \u0026quot;/credits\u0026quot; weight = 30  Read more about hugo menu and hugo multilingual menus\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/basics/style-customization/",
	"title": "Style customization",
	"tags": [],
	"description": "",
	"content": "Hugo-theme-learn has been built to be as configurable as possible by defining multiple partials\nIn themes/hugo-theme-learn/layouts/partials/, you will find all the partials defined for this theme. If you need to overwrite something, don\u0026rsquo;t change the code directly. Instead follow this page. You\u0026rsquo;d create a new partial in the layouts/partials folder of your local project. This partial will have the priority.\nThis theme defines the following partials :\n header: the header of the content page (contains the breadcrumbs). Not meant to be overwritten custom-header: custom headers in page. Meant to be overwritten when adding CSS imports. Don\u0026rsquo;t forget to include style HTML tag directive in your file footer: the footer of the content page (contains the arrows). Not meant to be overwritten custom-footer: custom footer in page. Meant to be overwritten when adding Javacript. Don\u0026rsquo;t forget to include javascript HTML tag directive in your file favicon: the favicon logo: the logo, on top left hand corner. meta: HTML meta tags, if you want to change default behavior menu: left menu. Not meant to be overwritten menu-footer: footer of the the left menu search: search box toc: table of contents  Change the logo Create a new file in layouts/partials/ named logo.html. Then write any HTML you want. You could use an img HTML tag and reference an image created under the static folder, or you could paste a SVG definition !\nThe size of the logo will adapt automatically\n Change the favicon If your favicon is a png, just drop off your image in your local static/images/ folder and name it favicon.png\nIf you need to change this default behavior, create a new file in layouts/partials/ named favicon.html. Then write something like this:\n\u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/images/favicon.png\u0026#34; type=\u0026#34;image/x-icon\u0026#34; /\u0026gt; Change default colors Hugo Learn theme let you choose between 3 native color scheme variants, but feel free to add one yourself ! Default color scheme is based on Grav Learn Theme.\nRed variant [params] # Change default color scheme with a variant one. Can be \u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;. themeVariant = \u0026#34;red\u0026#34; Blue variant [params] # Change default color scheme with a variant one. Can be \u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;. themeVariant = \u0026#34;blue\u0026#34; Green variant [params] # Change default color scheme with a variant one. Can be \u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;. themeVariant = \u0026#34;green\u0026#34; \u0026lsquo;Yours‘ variant First, create a new CSS file in your local static/css folder prefixed by theme (e.g. with mine theme static/css/theme-mine.css). Copy the following content and modify colors in CSS variables.\n:root{ --MAIN-TEXT-color:#323232; /* Color of text by default */ --MAIN-TITLES-TEXT-color: #5e5e5e; /* Color of titles h2-h3-h4-h5 */ --MAIN-LINK-color:#1C90F3; /* Color of links */ --MAIN-LINK-HOVER-color:#167ad0; /* Color of hovered links */ --MAIN-ANCHOR-color: #1C90F3; /* color of anchors on titles */ --MENU-HEADER-BG-color:#1C90F3; /* Background color of menu header */ --MENU-HEADER-BORDER-color:#33a1ff; /*Color of menu header border */ --MENU-SEARCH-BG-color:#167ad0; /* Search field background color (by default borders + icons) */ --MENU-SEARCH-BOX-color: #33a1ff; /* Override search field border color */ --MENU-SEARCH-BOX-ICONS-color: #a1d2fd; /* Override search field icons color */ --MENU-SECTIONS-ACTIVE-BG-color:#20272b; /* Background color of the active section and its childs */ --MENU-SECTIONS-BG-color:#252c31; /* Background color of other sections */ --MENU-SECTIONS-LINK-color: #ccc; /* Color of links in menu */ --MENU-SECTIONS-LINK-HOVER-color: #e6e6e6; /* Color of links in menu, when hovered */ --MENU-SECTION-ACTIVE-CATEGORY-color: #777; /* Color of active category text */ --MENU-SECTION-ACTIVE-CATEGORY-BG-color: #fff; /* Color of background for the active category (only) */ --MENU-VISITED-color: #33a1ff; /* Color of \u0026#39;page visited\u0026#39; icons in menu */ --MENU-SECTION-HR-color: #20272b; /* Color of \u0026lt;hr\u0026gt; separator in menu */ } body { color: var(--MAIN-TEXT-color) !important; } textarea:focus, input[type=\u0026#34;email\u0026#34;]:focus, input[type=\u0026#34;number\u0026#34;]:focus, input[type=\u0026#34;password\u0026#34;]:focus, input[type=\u0026#34;search\u0026#34;]:focus, input[type=\u0026#34;tel\u0026#34;]:focus, input[type=\u0026#34;text\u0026#34;]:focus, input[type=\u0026#34;url\u0026#34;]:focus, input[type=\u0026#34;color\u0026#34;]:focus, input[type=\u0026#34;date\u0026#34;]:focus, input[type=\u0026#34;datetime\u0026#34;]:focus, input[type=\u0026#34;datetime-local\u0026#34;]:focus, input[type=\u0026#34;month\u0026#34;]:focus, input[type=\u0026#34;time\u0026#34;]:focus, input[type=\u0026#34;week\u0026#34;]:focus, select[multiple=multiple]:focus { border-color: none; box-shadow: none; } h2, h3, h4, h5 { color: var(--MAIN-TITLES-TEXT-color) !important; } a { color: var(--MAIN-LINK-color); } .anchor { color: var(--MAIN-ANCHOR-color); } a:hover { color: var(--MAIN-LINK-HOVER-color); } #sidebar ul li.visited \u0026gt; a .read-icon { color: var(--MENU-VISITED-color); } #body a.highlight:after { display: block; content: \u0026#34;\u0026#34;; height: 1px; width: 0%; -webkit-transition: width 0.5s ease; -moz-transition: width 0.5s ease; -ms-transition: width 0.5s ease; transition: width 0.5s ease; background-color: var(--MAIN-LINK-HOVER-color); } #sidebar { background-color: var(--MENU-SECTIONS-BG-color); } #sidebar #header-wrapper { background: var(--MENU-HEADER-BG-color); color: var(--MENU-SEARCH-BOX-color); border-color: var(--MENU-HEADER-BORDER-color); } #sidebar .searchbox { border-color: var(--MENU-SEARCH-BOX-color); background: var(--MENU-SEARCH-BG-color); } #sidebar ul.topics \u0026gt; li.parent, #sidebar ul.topics \u0026gt; li.active { background: var(--MENU-SECTIONS-ACTIVE-BG-color); } #sidebar .searchbox * { color: var(--MENU-SEARCH-BOX-ICONS-color); } #sidebar a { color: var(--MENU-SECTIONS-LINK-color); } #sidebar a:hover { color: var(--MENU-SECTIONS-LINK-HOVER-color); } #sidebar ul li.active \u0026gt; a { background: var(--MENU-SECTION-ACTIVE-CATEGORY-BG-color); color: var(--MENU-SECTION-ACTIVE-CATEGORY-color) !important; } #sidebar hr { border-color: var(--MENU-SECTION-HR-color); } Then, set the themeVariant value with the name of your custom theme file. That\u0026rsquo;s it !\n[params] # Change default color scheme with a variant one. Can be \u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;. themeVariant = \u0026#34;mine\u0026#34; "
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/icons/",
	"title": "Icons and logos",
	"tags": [],
	"description": "",
	"content": "The Learn theme for Hugo loads the Font Awesome library, allowing you to easily display any icon or logo available in the Font Awesome free collection.\nFinding an icon Browse through the available icons in the Font Awesome Gallery. Notice that the free filter is enabled, as only the free icons are available by default.\nOnce on the Font Awesome page for a specific icon, for example the page for the heart, copy the HTML reference and paste into the markdown content.\nThe HTML to include the heart icon is:\n\u0026lt;i class=\u0026quot;fas fa-heart\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Including in markdown Paste the \u0026lt;i\u0026gt; HTML into markup and Font Awesome will load the relevant icon.\nBuilt with \u0026lt;i class=\u0026quot;fas fa-heart\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; from Grav and Hugo Which appears as\nBuilt with from Grav and Hugo\nCustomising icons Font Awesome provides many ways to modify the icon\n Change colour (by default the icon will inherit the parent colour) Increase or decrease size Rotate Combine with other icons  Check the full documentation on web fonts with CSS for more.\n"
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/",
	"title": "Golang의 내부",
	"tags": ["Golang", "Internals", "Compiler", "Structure"],
	"description": "",
	"content": "Go 언어 내부\n페이지 리스트  Golang의 내부, 1부: 주요 컨셉트와 프로젝트 구조  이 블로그 시리즈는 기본적인 Go 언어특성에 이미 익숙하며 좀 더 심도있게 내부구조를 알고자 하는 독자들을 위해 쓰여졌다. 이 포스트는 Go언어의 소스코드의 구조와 Go\n Golang의 내부, 2부: Go 컴파일러 들여다 보기  독자는 인터페이스 레퍼런스를 통해 변수를 사용할 경우 Go 런타임내에서 어떤 일이 있는지 정확하게 알고 있는가? 이 질문에 쉽게 답할 수 없는 이유는 어떤 인터페이스를 구\n Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치  오늘은 Go 링커와 오브젝트 파일, 그리고 재배치(relocations)에 대해 얘기해 보자. 이런 것들이 독자들과 무슨 상관이 있을까? 만약 독자가 어떤 대형 프\n Golang의 내부, 4부: 오브젝트 파일, 그리고 함수 메타데이터  오늘은, Func 구조에 대해 좀 더 자세히 들여다 보고 어떻게 가비지 컬렉션이 작동하는지 몇가지 자세한 내용을 논하겠다. 이 포스트는 Golang의 내부, 3부: 링커,\n Golang의 내부, 5부: 런타임 부트스트랩  부트스트래핑 과정은 Go의 런타임이 어떻게 작동하는지를 이해하는데 열쇠와 같은 구실을 한다. Go와 함께 앞으로 나아가고자 한다면 반드시 배워야한다. 그래서 G\n Golang의 내부, 6부: 부트스트래핑과 메모리 할당자  이 포스트는 Golang 내부 시리즈의 연속이다. Go 런타임을 자세히 이해하는데 열쇠와 같은 부트스트랩 과정을 살펴볼 것이다. 이번에는 시작하는 순서의 두번째 부분을 섭렵해\n Golang의 내부, 0부: 부록  Go 언어의 최신 컴파일러에 대한 내용 GopherCon 2016: Rob Pike - The Design of the Go Assembler Video Slides GopherCon 2014 Go from C to Go by Russ Cox Video Slides GopherFest 2015: Rob Pike on the move from C to Go in the toolchain Video Slides Go의 어셈블러 A Quick Guide to Go\u0026rsquo;s Assembler\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/i18n/",
	"title": "Multilingual and i18n",
	"tags": [],
	"description": "",
	"content": "Learn theme is fully compatible with Hugo multilingual mode.\nIt provides:\n Translation strings for default values (English and French). Feel free to contribute ! Automatic menu generation from multilingual content In-browser language switching  Basic configuration After learning how Hugo handle multilingual websites, define your languages in your config.toml file.\nFor example with current French and English website.\n# English is the default language defaultContentLanguage = \u0026#34;en\u0026#34; # Force to have /en/my-page and /fr/my-page routes, even for default language. defaultContentLanguageInSubdir= true [Languages] [Languages.en] title = \u0026#34;Documentation for Hugo Learn Theme\u0026#34; weight = 1 languageName = \u0026#34;English\u0026#34; [Languages.fr] title = \u0026#34;Documentation du thème Hugo Learn\u0026#34; weight = 2 languageName = \u0026#34;Français\u0026#34; Then, for each new page, append the id of the language to the file.\n Single file my-page.md is split in two files:  in English: my-page.en.md in French: my-page.fr.md   Single file _index.md is split in two files:  in English: _index.en.md in French: _index.fr.md    Be aware that only translated pages are displayed in menu. It\u0026rsquo;s not replaced with default language content.\n Use slug Front Matter parameter to translate urls too.\n Overwrite translation strings Translations strings are used for common default values used in the theme (Edit this page button, Search placeholder and so on). Translations are available in french and english but you may use another language or want to override default values.\nTo override these values, create a new file in your local i18n folder i18n/\u0026lt;idlanguage\u0026gt;.toml and inspire yourself from the theme themes/hugo-theme-learn/i18n/en.toml\nBy the way, as these translations could be used by other people, please take the time to propose a translation by making a PR to the theme !\nDisable language switching Switching the language in the browser is a great feature, but for some reasons you may want to disable it.\nJust set disableLanguageSwitchingButton=true in your config.toml\n[params] # When using mulitlingual website, disable the switch language button. disableLanguageSwitchingButton = true "
},
{
	"uri": "https://devbj.com/hugolearntheme/cont/tags/",
	"title": "Tags",
	"tags": ["documentation", "tutorial"],
	"description": "",
	"content": "Learn theme support one default taxonomy of gohugo: the tag feature.\nConfiguration Just add tags to any page:\n--- date: 2018-11-29T08:41:44+01:00 title: Theme tutorial weight: 15 tags: [\u0026#34;tutorial\u0026#34;, \u0026#34;theme\u0026#34;] --- Behavior The tags are displayed at the top of the page, in their insertion order.\nEach tag is a link to a Taxonomy page displaying all the articles with the given tag.\nList all the tags In the config.toml file you can add a shortcut to display all the tags\n[[menu.shortcuts]] name = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-tags\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; Tags\u0026#34; url = \u0026#34;/tags\u0026#34; weight = 30 "
},
{
	"uri": "https://devbj.com/golangkorea/hugo-intro/",
	"title": "Hugo 입문 - 개요",
	"tags": ["Blog", "Hugo"],
	"description": "",
	"content": "Hugo는 현존하는 가장 빠른 정적 사이트 제너레이터(Static Site Generator)로 알려져 있습니다. 기능적인 측면에서도 여타 동적 사이트 제너레이터(Static Site Generator)에 비해 손색이 없을 뿐더러 설치가 간편하고 Go언어에 친숙한 개발자들에게는 최고의 컨텐츠 제작 환경을 제공한다고 생각합니다. Golang Korean Community 사이트도 Hugo로 제작되고 있습니다. Hugo 입문 시리즈를 통해 이 사이트에 기여하시고자 하는 분들에게 가이드라인을 제공할 뿐만 아니라 자신만의 블로그 사이트를 쉽게 제작하고자 하는 분들에게도 도움이 되길 기원하는 마음으로 시리즈를 준비했습니다.\n Hugo 시작하기 컨텐츠 제작 기초 사이트 테마 커스터마이징 하기 분류(Taxonomy)기능 사용하기 사이트에 블로그 올리는 방법  "
},
{
	"uri": "https://devbj.com/golangkorea/golang-internals/resources/",
	"title": "Golang의 내부, 0부: 부록",
	"tags": ["Golang", "Internals", "Compiler", "Assembler", "linker"],
	"description": "",
	"content": "Go 언어의 최신 컴파일러에 대한 내용  GopherCon 2016: Rob Pike - The Design of the Go Assembler  Video Slides   GopherCon 2014 Go from C to Go by Russ Cox  Video Slides   GopherFest 2015: Rob Pike on the move from C to Go in the toolchain  Video Slides    Go의 어셈블러  A Quick Guide to Go\u0026rsquo;s Assembler  "
},
{
	"uri": "https://devbj.com/hugolearntheme/",
	"title": "Learn Theme for Hugo",
	"tags": [],
	"description": "",
	"content": "Hugo learn theme Hugo-theme-learn is a theme for Hugo, a fast and modern static website engine written in Go. Where Hugo is often used for blogs, this multilingual-ready theme is fully designed for documentation.\nThis theme is a partial porting of the Learn theme of Grav, a modern flat-file CMS written in PHP.\nLearn theme works with a page tree structure to organize content : All contents are pages, which belong to other pages. read more about this\n Main features  Automatic Search Multilingual mode Unlimited menu levels Automatic next/prev buttons to navigate through menu entries Image resizing, shadow\u0026hellip; Attachments files List child pages Mermaid diagram (flowchart, sequence, gantt) Customizable look and feel and themes variants Buttons, Tip/Note/Info/Warning boxes, Expand  Contribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it\nYour modification will be deployed automatically when merged.\n Documentation website This current documentation has been statically generated with Hugo with a simple command : hugo -t hugo-theme-learn \u0026ndash; source code is available here at GitHub\nAutomatically published and hosted thanks to Netlify. Read more about Automated HUGO deployments with Netlify\n "
},
{
	"uri": "https://devbj.com/tags/arduino/",
	"title": "Arduino",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "Home 🔧🕯 현재, 공사중입니다. 휴고를 지원하는 블로그 플랫폼을 변경중입니다. 문서를 깔끔하게 보여주는 테마를 괜히 선정해서, 고생중에 있습니다. 마크다운으로 작성된 글을 최대한 편하게 보일 수 있도록 테마도 약간씩 수정중이어서, 홈페이지가 지저분 할 예정입니다.\n 페이지 리스트  Blog  블로그 글 모음 - 기술, 생각\n WizFi360  Chapter 1 WizFi360 Discover what this Hugo theme is all about and the core-concepts behind it. ☕ 배워봐 제발!! div 가로폭을 전부 차지함, span 태그 안의 내용만 차지함 div 폭과 넓이 지정가능, span 못함 div 필연적으로 줄 바꿈을 동\n Learn Theme for Hugo  Hugo learn theme Hugo-theme-learn is a theme for Hugo, a fast and modern static website engine written in Go. Where Hugo is often used for blogs, this multilingual-ready theme is fully designed for documentation. This theme is a partial porting of the Learn theme of Grav, a modern flat-file CMS written in PHP. Learn theme works with a page tree structure to organize content : All contents are pages, which belong to other pages.\n GoLang Korea  The Slow Hunch Where Good Ideas Come From: The Natural History of Innovation의 저자 Steven B. Johnson에 따르면 인류의 역사를 바꾼 혁신들은 번뜩이는 아이디어에서 시작된 경우가 매우 드물\n "
},
{
	"uri": "https://devbj.com/tags/ipv6/",
	"title": "IPv6",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2019-03-05-webserver-adafruit/",
	"title": "IPv6 WebServer example with WIZnet W6100 chip",
	"tags": ["arduino", "WIZnet", "W6100", "IPv6"],
	"description": "",
	"content": "(Modified) 2019-03-03\nWebServer Example WebServer-Adafruit (https://github.com/WIZnet-ArduinoEthernet/WebServer-Adafruit) W6100의 IPv4, IPv6 Dual Stack을 이용한 WebServer Example 입니다. Browser로 접속하면 Host의 IPv4 또는 IPv6 주소가 Adafruit의 OLED SSD1306에 출력됩니다. WIZnet Ethernet Library IPv6 Github WIZnet Arduino Ethernet Library (https://github.com/Wiznet/Ethernet)\nIPv6 Branch를 선택합니다.\nArduino IDE를 Default로 설치하면 Library Manager를 통해 Download한 Library는\n\u0026lsquo;C:\\Users\\Your ID\\Documents\\Arduino\\libraries'에 위치 합니다.\nDownload한 WIZnet Arduino Ethernet Library가 아래와 같은 경로를 갖도록 합니다.\nC:\\Users\\Your ID\\Documents\\Arduino\\libraries\\Ethernet Adafruit GFX Library Adafruit GFX Library (https://github.com/adafruit/Adafruit-GFX-Library)\nVersion 1.4.2로 Test 하였습니다.\nLibrary Manager를 통해 Download 합니다.\nAdafruit SSD1306 Library Adafruit SSD1306 Library (https://github.com/adafruit/Adafruit_SSD1306)\nVersion 1.2.9로 Test 하였습니다.\nLibrary Manager를 통해 Download 합니다.\nWebServer-Adafruit WebServer-Adafruit Download하고, 실행하여 WebServer를 실행합니다. WebServer-Adafruit는 Web Browser로 접속하면 Host의 IPv4 또는 IPv6 주소를 Adafruit의 OLED SSD1306에 출력합니다. 그리고 Message를 전송할 수도 있습니다.\nIPv4 Test IPv6 LLA Bug 발견 버그가 발견되었다. 이젠 직접 본격적으로 라이브러리나 예제를 개선해 볼까나~~ 메시지를 출력하는 과정에서 메시지 이외의 패킷 내용이 표기되어 이를 수정하고자 한다. 일단, 이 예제를 Clone 하여 자신의 로컬 PC에 개발 환경을 구축하고, 문제가 있는 부분을 빨리 수정한다. (남들이 하기전에 82828282) 다행이 아주 간단하게 해결 할 수 있었다. 메시지의 끝을 체크하는 코드를 추가하여 테스트 해보자..우선 컴파일 다운로드 후 실행..다시 해볼까? 결과는 아래와 같이 동작이 잘 되었다. 그럼 이제 GitHub 저장소를 업데이트 해보자.\nReusable Library Update Clone 되어 있는 환경에서 일단 “hotfix” 라는 브랜치를 만들어, 로컬에서 테스트 한 코드를 수정해서 commit 을 진행한다. 이미 테스트해서 검증한 소스이므로, 검증 과정은 생략하고 (원래는 이 부분이 가장 중요하다) 이제 master branch로 pull request를 진행해 본다. 메뉴에서 간단하게 선택하면 된다. 이 과정에서 “hotfix” 브랜치로 작업을 진행했고, 저장소에는 이 브랜치가 없으므로 이 정보를 먼저 업데이트 한다는 메시지가 뜬다. 그냥 “Publish” 하고 진행하면 된다. 이 과정이 종료되면, 브라우저가 GitHub 사이트를 띄우면서 Pull request 과정을 진행하게 된다. Pull request 를 보내면, 아래 그림처럼 Pull request 를 처리해서 “Merge” 할지 말지 처리하는 버튼이 아래와 같이 등장하게 된다. 관리자는 코드 리뷰를 먼저하고, 이 코드를 수용할 지 아닌지 결정하면 된다. 해당 코드는 일단 검증이 된 관계로 바로 “Merge” 과정을 진행해 보자.\n아래와 같이 “Merge” 버튼을 누르면 아래와 같이 2가지 중에 하나를 선택해야 한다. 개발 브랜치의 Commit 내용을 전부 가지고 Merge를 할 것이냐, 아니면 1개의 commit 으로 생략해서 Merge를 할 것이냐 선택을 하는 것이다.\n우리는 Merge comment 를 추가로 입력할 수 있으므로, 일반적으로 “2번”을 선택하도록 한다. (중요한 commit 이 남아야 한다면 반드시 “1번”을 선택하도록!!!)\n자 그럼, Merge comment를 추가하고 아래와 같이 버튼을 눌러 master 브랜치를 업데이트 해보자. 그럼 성공되었다는 메시지와 함께 요청한 Pull request 는 자동으로 close 된다. 여기서 잠깐!! 작업한 “hotfix” 브랜치는 더이상 필요가 없으므로 위의 그림의 “Delete branch”를 눌러 삭제하는 것이 좋다.\n이 삭제 과정은 로컬에서 아래 그림과 같이 수행해도 된다. 당연히 GitHub 저장소에 있는 브랜치도 같이 삭제하는 것이 좋겠죠 ^^. 이제 아주 깨끗해진 저장소를 볼 수 있다. 이상, GitHub 저장소에 오픈된 라이브러리의 활용법과 기여를 하는 방법에 대해 모든 과정을 살펴보았다. 이젠 자신있게 똘똘한 자식들을 많이 만들어 보자. 보물 찾으러 고고!!\n"
},
{
	"uri": "https://devbj.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/w6100/",
	"title": "W6100",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/wiznet/",
	"title": "WIZnet",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2019-03-03-embeddedworld2019/",
	"title": "Embedded World 2019",
	"tags": ["EW19", "Arduino", "Ethernet", "WIZnet", "W5500", "W5100"],
	"description": "",
	"content": "(Modified) 2019-03-03\nMCU  마이크로칩    클라우드 연동 모듈 신규 출시\n  30초만에 구성하는 클라우드 솔루션!! 이렇게 광고중\n  WiFi 모듈을 내장하고, 각 클라우드별 backend reference 를 기본 제공\n  쉽고 빠른 솔루션이 강점* 데모 구성 박스 태블릿을 활용해서 Dash board 까지 간단하게 동작을 전부 보여 줄 수 있도록 꾸며둠  AVR-IoT 모듈 출시에 맞춰 다양한 무선 솔루션들을 한꺼번에 준비해 두었다.  기가비트 PHY 솔루션 모습들. End-node 뿐 아니라 middle 스위치 솔루션도 준비되어 있다.  Infineon    산업계 특수분야에 집중되어 있던 인피니온도 #Maker 를 위한 다양한 Evaluation board 를 선보이며, Maker 시장에도 관심을 보이고 있다.  자신들의 강점인 #센서 #아날로그 칩셋을 중심으로 경쟁력있는 사이즈의 모듈을 선보이고 있다.\n  메이커의 유입을 위해 #M5stack 에 장착되는 센서모듈을 소개해 주고 있다.  TI   TI는 반도체업계의 전통적인 강자로 #EW19에서는 #Industrial 4.0과 관련된 통신 #IO-Link, #Gigabit #TSN 솔루션을 중심으로 전시를 꾸며 두었다.  Nordic   블루투스 강자답게 #Bluetooth5 등 무선 통신 솔루션( #LTE-M #NBIoT #Thread #ZigBee ) 중심으로 전시  NXP    EW19가 유럽 전시회라 그런지 자동차용 반도체 시장에 기회를 보고, 관련 기술 소개를 하는 업체가 많았다. 사실 규모가 조금이라도 큰 업체는 전부 “자동차 반도체” 를 강조하고 있었다.  AI, Machine Learning 도 마찬가지로 거의 전 MCU 업체들이 자신의 기술을 소개하고 있다.\n  구글 ML 기술과 협업하여 IoT 디바이스와 연동하는 데모를 보여 주고 있다.  클라우드 연결에서는 IOT 보안 이슈도 절대 빠질 수 없는 테마이다. 외부 공격에도 정상 동작하는 장면을 시연하고 있다.  STM    거대한 #Ecosystem 자랑하는 공간, 제품군이 많기도 하다.  역시 없는게 없다!! ST 무선 통신 솔루션  여전한 강세를 보여주는 STM의 #lowend MCU 시리즈  Industrial 4.0 시장을 위한 #IO-link 제품과 #POE 제품 소개  여타 기업과 마찬가지로, 자동차 반도체 솔루션 데모가 큰 부분을 차지하고 있다.  Cypress   자동차 솔루션, 계기판, CAN 뿐만 아니라 주변 센서 솔루션과 Vision 을 연계한 자동 운전과 관련된 솔루션 소개도 많이 되고 있었다. 소규모 업체는 General purpose 쪽으로 나서기보다 전략적으로 집중하는 듯한 느낌  Renesas    자동차, 센서에서 클라우드 까지 너무 컨셉들이 차이가 없죠 ^^;;;  르네사스의 전략은 개별 개발자를 위한 전시공간이라기 보다는 기업들을 상대로 솔루션 중심의 판매를 하는 형태인 것으로 보인다.  Silicon Lab   저가용 MCU를 그나마 많이 파는 곳이라서 ST와 유사하게 여러가지 Evaluation board, 개발환경 등을 강조하면서 임베디드 개발자의 유입을 기대하고 있는 모습!  FPGA Trenz    컴팩트 사이즈 #FPGA 모듈을 전문으로 파는 독일 업체, TOE를 위한 위즈네트 맞춤형 모듈 개발에 대한 논의를 시작하게 되어 기대가 된다.  우리가 동양인들이라 그런지 CTO가 슬쩍 와서 소개해 준 모듈 - 중국 FPGA #GOWIN 을 사용한 모듈로 처음 봤다. 중국 FPGA 칩!!!!  Xilinx    ARM Design Start program, 직접 시연을 볼 수 있어 만족!!\n  ARM Cortex-M1, M3를 FPGA에 Prototype을 만들어 자신만의 SoC를 만들어 보거나 AMBA 호환 Peripheral 테스트하기에 좋음  AI, ML 솔루션 -\u0026gt; 너무 다들 동일한 솔루션을 소개하고 있어 되려 아무런 특징을 느낄 수 없었다.  Lattice   역시 사물인식 데모가!! 그러나 여기는 Low Power 가 강조되긴 했네. 차별성을 Low Power 에 둔 것 같다. 알다시피 FPGA에서는 비주류에 속하기 때문에 차별성을 이 부분으로 가져가고 있음을 볼 수 있었다.  마이크로칩 – Microsemi    Xilinx, Intel에 이은 3위 업체 정도로 볼 수 있고, 차별성은 보안에 두고 있다.\n  별도의 보안 칩 없이 FPGA 내부에 IP 보안기능이 내장되어 있는 것이 장점이다.* Trenz 와 협업이 예상되는 모듈에 사용될 칩셋!!  Xilinx를 제외하고는 ARM core 대신에 RISC-V Core를 권장하고 있다. 이미 ASIC으로 제작한 업체들이 자기 솔루션들을 소개하고 있다.  VAR  Controllio, Seeed, Particle, Mikroe   산업용 IoT 시장의 진입을 위해 유달리 #TSN 과 #보안 공부가 필요!!   "
},
{
	"uri": "https://devbj.com/tags/ethernet/",
	"title": "Ethernet",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/ew19/",
	"title": "EW19",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2019-01-21-arduino-ethernet-products/",
	"title": "The real products based on Arduino-Ethernet",
	"tags": ["Arduino", "Ethernet", "WIZnet", "W5500", "W5100"],
	"description": "",
	"content": "(Modified) 2019-01-21\n Value Added Products based on Arduino Ethernet Shield  Arduino Adafruit Industries Sfera Labs S.r.l. DFRobot Elektronik Hannes Jochriem Parallax Inc Electric Imp Controllino Industruino KMP Electronics Ltd mikroe Tindie    Arduino Ethernet을 기반으로 한 실제 상용화된 제품들을 소개해 본다.\nValue Added Products based on Arduino Ethernet Shield Arduino   Arduino MKR ETH Shield - https://store.arduino.cc/usa/arduino-mkr-eth-shield\n MKR 시리즈에 맞는 Ethernet Shield 제품이 출시되어 있다. 아직 크게 반응이 오는 제품은 아닌듯 W5500 을 기반으로 하고 있어, W5100 기반 제품보다 빠른 SPI 속도 지원이 가능하다.     Arduino Leonardo ETH 2 with PoE - https://store.arduino.cc/usa/arduino-ethernet-2-with-poe\n Ethernet Shiled 제품의 기본, 많은 것들 중에 소개하는 이유는 W5500을 사용하고 있고 POE 기능이 들어 있는 부분 때문이다.    Adafruit Industries   Adafruit Ethernet FeatherWing - https://www.adafruit.com/product/3201\n Adafruit에서 사용하는 플랫폼에 맞는 이더넷 모듈    Particle Ethernet FeatherWing - https://www.adafruit.com/product/4003\n  Sfera Labs S.r.l.  Iono Arduino (Industrial Arduino PLC) - Relays I/O RS485 Modbus https://www.sferalabs.cc/iono-arduino/  DFRobot   W5500 Ethernet with POE IOT Board (Arduino Compatible) – https://www.dfrobot.com/product-1286.html\n  XBoard V2 - A Bridge Between Home And Internet (Arduino Compatible) https://www.dfrobot.com/product-564.html\n  Xboard Relay - An Ethernet Controllered Relay https://www.dfrobot.com/product-837.html\n  Elektronik Hannes Jochriem  Ethernet-Shield WIZnet W5500 - https://www.ehajo.de/boards/96/ethernet-shield-wiznet-w5500  Parallax Inc  Spinneret Web Server - https://www.parallax.com/product/32203  Electric Imp  impAccelerator Fieldbus Gateway - https://developer.electricimp.com/hardware/resources/reference-designs/fieldbusgateway  Controllino  Controllino MAXI \u0026amp; MAXIpure - https://www.controllino.biz/controllino-maxi/maxi-and-maxi-pure/  Industruino  Ethernet expansion module - https://industruino.com/shop/product/ethernet-expansion-module-10  KMP Electronics Ltd  ProDino MKR Zero Ethernet V1 - https://kmpelectronics.eu/products/prodino-mkr-zero-ethernet-v1/ ProDino MKR GSM Ethernet V1 - https://kmpelectronics.eu/products/prodino-mkr-gsm-ethernet-v1/  mikroe  ETH WIZ click - ETH Wiz click with Wiznet\u0026rsquo;s W5500 ethernet controller  Tindie  EletroShields (Ethernet Nanoshield) - Ethernet Nanoshield with Wiznet W5500  "
},
{
	"uri": "https://devbj.com/tags/w5100/",
	"title": "W5100",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/w5500/",
	"title": "W5500",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2019-01-15-arduino-ethernet-shield-list/",
	"title": "List of Arduino Ethernet Shield products",
	"tags": ["Arduino", "Ethernet", "WIZnet", "W5500", "W5100", "W5100S", "W6100"],
	"description": "",
	"content": "(Modified) 2019-01-15\n W6100 W5500 W5100S W5100 W5200  Ethernet Shield List What is the \u0026ldquo;Ethernet Shield\u0026rdquo;?  The Arduino Ethernet Shield connects your Arduino to the internet in mere minutes. Just plug this module onto your Arduino board, connect it to your network with an RJ45 cable (not included) and follow a few simple instructions to start controlling your world through the internet. from Ethernet Shield\n WIZnet - W5100, W5200, W5500, W5100S, W6100 W6100    Name Maker Chipset Product link    W5500    Name Maker Chipset Product link     ARDUINO MKR ETH SHIELD Arduino W5500 Product Link   W5500 Ethernet Shield S(secure) EWBM W5500 Product Link   Arduino Ethernet Shield 2 Arduino W5500 Product Link   W5500 Ethernet Shield WIZnet W5500 Product Link   SweetPea UnoNet+ : Ethernet and NFC in one board ElectronicSweetpeas W5500 Product Link   POE W5500 Ethernet Shield Iteadstudio W5500 Product Link   W5500 Ethernet Shield v1.0 Seeed Studio W5500 Product Link   Arduino W5500 shield swbee W5500 Product Link   SweetPea NetFox : Ethernet and NFC in one board ElectronicSweetpeas W5500 Product Link    W5100S    Name Maker Chipset Product link     W5100S MKR-Ethernet Shield WIZnet W5100S Product Link   W5100S Ethernet Shield WIZnet W5100S Product Link    W5100    Name Maker Chipset Product link     Ethernet Shield Adafruit W5100 Product Link   Ethernet Microcontroller (No PoE) (am-2287) Andy Mark W5100 Product Link   Arduino Ethernet Arduino W5100 Product Link   Arduino Ethernet Shield R3.0 Arduino W5100 Product Link   Arduino Ethernet Shield R2.0 Arduino W5100 Product Link   Arduino Ethernet Shield Arduino W5100 Product Link   Ethernet Shield W5100 with Micro SD card Aura W5100 Product Link   Electronics DIY Arduino Ethernet Shield W5100 DFRobot W5100 Product Link   DFRduino Ethernet Shield V2.1 (Support Mega and Micro SD) DFRobot W5100 Product Link   Ethernet Shield W5100 DFRobot W5100 Product Link   XBoard V2-A bridge between home and internet DFRobot W5100 Product Link   W5100 Ethernet Shield e-Gizmo W5100 Product Link   Arduino Ethernet Shield ELEC House W5100 Product Link   Ethernet Shield Elecfreaks W5100 Product Link   Ethernet Shield - W5100 Elecfreaks W5100 Product Link   NX Bridge include Bee adapter Elecfreaks W5100 Product Link   Freeduino Ethernet Module E-Shield v2 Freeduino W5100 Product Link   Ethernet Shield Freetronics W5100 Product Link   EtherMega Freetronics W5100 Product Link   EtherTen Freetronics W5100 Product Link   EtherDue Freetronics W5100 Product Link   FEZ Connect Shield GHI W5100 Product Link   Ethernet w/ MicroSD add-on for Arduino Nano Gravitech W5100 Product Link   ICStation Ethernet Shield Compatible Arduino Ethernet Shield icstation W5100 Product Link   Ethernet Shield W5100 Network Module For Arduino icstation W5100 Product Link   ITEAD W5100 Ethernet shield * Iteadstudio W5100 Product Link   W5100 Ethernet Module With POE/Xbee/SD Slot Iboard For Arduino Iteadstudio W5100 Product Link   IBoard Ex Iteadstudio W5100 Product Link   IBoard Pro Iteadstudio W5100 Product Link   Korduino Ethernet Shield JK W5100 Product Link   Ethernet Shield linksprite W5100 Product Link   Ethernet W5100 R3 Shield Network Board Lseeduino W5100 Product Link   Ethernet Shield NKC Electronics W5100 Product Link   Zduino Ethernet OpenJumper W5100 Product Link   Ethernet Shield W5100 Sainsmart W5100 Product Link   WIZnet Ethernet Shield Seeed Studio W5100 Product Link   Seeeduino Ethernet Seeed Studio W5100 Product Link   PoEthernet Shield Sparkfun W5100 Product Link   Ethernet Pro Sparkfun W5100 Product Link   Ethernet Shield Tinker.it W5100 Product Link   Tronixlabs W5100 Ethernet shield microSD Tronixlabs W5100 Product Link   Arduino Ethernet Shield R3 Optimized Version Unknown W5100 Product Link    W5200    Name Maker Chipset Product link     Ethernet Shield W5200 DF-DFR0272 DFRobot W5200 Product Link   W5200 DFRduino Ethernet Expansion Board DFRobot W5200 Product Link   W5200 Ethernet Shield Elecrow W5200 Product Link   W5200 Ethernet Shield for Arduino Maker Studio W5200 Product Link   W5200 Ethernet Shield v2 Seeed Studio W5200 Product Link   WIZnet W5200 Ethernet shield WIZnet W5200 Product Link   ioShield-A WIZnet W5500 Product Link    Others    Name Maker Chipset Product link     Ethernet Shield Adafruit Xport lantronix - Product Link   Ethernet Shield ENC28J60 for Arduino Nano Aura ENC28j60 Product Link   ENC28J60 Ethernet Module (Shield) e-Gizmo ENC28j60 Product Link   Arduino Ethernet Shield V1.0 ELEC House ENC28J60 Product Link   ETHERNET SHIELD CON ENC28J60 Futura Electronics ENC28J60 Product Link   Ethernet Shield Hackaday ENC28j60 Product Link   ITEAD IE shield Iteadstudio ENC28j60 Product Link   Netduino Plus Netduino DM9161AEP Product Link   Netduino Plus 2 Netduino ENC28j60 Product Link   Ethernet Shield Nu Electronics ENC28j60 Product Link   InduinoX Ethernet Simple Lab\u0026rsquo;s ENC28j60 Product Link   ETHERNET SHIELD FOR ARDUINO Velleman, Inc. ENC28j60 Product Link    "
},
{
	"uri": "https://devbj.com/blog/2019-01-15-arduino-ethernet/",
	"title": "The state of Arduino Ethernet Library",
	"tags": ["Arduino", "Ethernet", "WIZnet", "W5500", "W5100"],
	"description": "",
	"content": "(Modified) 2019-01-15\n최근 Arduino Ethernet Library 업데이트 내용과 유용한 몇개의 라이브러리와 관련 예제를 정리해 본다.\n라이브러리 정보 최근 업데이트 된 라이브러리  Arduino Ethernet Library v2.0 - Arduino official  Runtime에 자동으로 연결되어 있는 칩셋을 알아내고, 알맞는 드라이버를 자동으로 선택하도록 개선되었다. W5100, W5200, W5500 어떤 칩을 사용하는 하드웨어를 연결하더라도 드라이버에서 자동으로 제어할 수 있다.  즉, 칩셋을 변경하기 위해 소스코드를 수정할 필요가 없다!!   최근에 출시된 Arduino MKR ETH shield 제품을 사용한다면 필수!!    WIZnet fork version - supports W5100S \u0026amp; W6100  WIZnet version, W5100S와 W6100등의 최신 칩셋을 지원하기 위해 WIZnet 에서 개발중인 드라이버 버전 Arduino MKR zero 보드를 이용한 응용 예제      Mobile app 으로 제어하기 ; Arduino Ethernet Library v2.0을 이용한 예제 구현 및 Blogging, WIZnet IoT Tool을 이용하여 Mobile device 에서 간단하게 아두이노 보드를 다룰 수 있다.  스마트폰으로 간단하게 Arduino 제어하기 (1) - Arduino MKR ETH + Arduino MKR Zero platform 스마트폰으로 간단하게 Arduino 제어하기 (2) - WIZnet IoT Tool app 스마트폰으로 간단하게 Arduino 제어하기 (3) - Simple remote display function with WIZnet IoT Tool        과거 Reference   Arduino Ethernet Library 2.0.0 - PJRC - 사실 Arduino Ethenret library v2.0의 원조 라이브러리, 이 저자가 최근 official version 릴리즈를 담당해주었다.\n Benchmarks \u0026amp; Test Results 를 포함하고 있다. 이 페이지는 필독!!!! SPI 속도로 인해 W5100 보다 W5200/W5500 이 나은 속도를 보이고 있음을 알 수 있다. (숫자는 Byte/sec)     Adafruit Ethernet2\n Adafruit에서 만든 W5500을 지원하기 위해 만들어진 라이브러리 업데이트 중단 선언! 최근 릴리즈된 Arduino Ethernet library v2.0 를 쓸 것을 권고 Adafruit Ethernet FeatherWing to Ubidots over HTTP  아주 작은 모듈로 제작된 FeatherWing과 대표적인 IoT Cloud 솔루션인 Ubidots 와 연결하는 예제 소스코드와 구현 결과물은 링크페이지에 자세히 나와 있다. {: width=\u0026quot;480\u0026rdquo;}   Arduino Ethernet + SD Card  대표적인 웹서버 예제로 Arduino Ethernet shield에 있는 SD 카드의 파일정보를 읽어 제공하는 tutorial이다. 소스코드와 구현방법을 순차적으로 아주 잘 정리해 두어 초보자가 아주 쉽게 따라할 수 있다.  Github source      WIZ_Ethernet_Library-IDE1.6.x-master.zip\n  W5500 을 지원하기 위해 Seeed Studio 에서 수정한 라이브러리\n  WIZnet 에서 제공하고 있는 WIZ_Ethernet_Library for IDE1.5.x 소스와 유사하다.\n  Arduino IDE1.6.x 이하 버전에서만 사용해야 하며, compile-time 에 반드시 chipset 을 선택해야 한다. 아래 코드 참조\n Select device: W5100, W5200 or W5500  // In the W5100.h file(\\libraries\\Ethernet\\utility\\w5100.h), uncomment the device(shield) you want to use. #ifndef\tW5100_H_INCLUDED#define\tW5100_H_INCLUDED #include \u0026lt;avr/pgmspace.h\u0026gt;#include \u0026lt;SPI.h\u0026gt; typedef uint8_t SOCKET; //#define W5100_ETHERNET_SHIELD //#define W5200_ETHERNET_SHIELD #define W5500_ETHERNET_SHIELD in Main .ino file  // By default, \u0026#34;WIZ550io_WITH_MACADDRESS\u0026#34; is commented and if you uncomment it, you can use the MAC address stored in the WIZ550io. #if defined(W5500_ETHERNET_SHIELD)//#define WIZ550io_WITH_MACADDRESS // Use assigned MAC address of WIZ550io #include \u0026#34;w5500.h\u0026#34;#endif  W5500 Ethernet Shield v1.0 Webserver\n 가장 기본적인 온도와 습도값을 보여주는 웹서버 기능을 잘 구현한 예제로 초보자가 쉽게 따라할 수 있도록 구성되어 있다. 소스코드는 물론 하드웨어 연결구조 및 설명이 자세히 되어 있다.       Seeed Studio Ethernet Shield V2.0 Library\n W5200 Shield 제품 출시와 함께 만들어서 배포 W5200 Shield 제품을 사용하고 있다면 아직도 유용한 라이브러리 Webserver Example  웹서버를 이용한 I/O 제어를 하는 간단하고 명쾌한 예제의 소스코드와 설명이 잘 정리되어 있다.       "
},
{
	"uri": "https://devbj.com/tags/w5100s/",
	"title": "W5100S",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/documentation/",
	"title": "documentation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/tutorial/",
	"title": "tutorial",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/%EB%93%9C%EB%9D%BC%EB%A7%88/",
	"title": "드라마",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2016-08-05-drama/",
	"title": "드라마 - 미드",
	"tags": ["미드", "영화", "드라마"],
	"description": "",
	"content": "(수정시간) 2016-09-21\n 미드  House of cards - 하우스 오브 카드 Game of thrones - 왕좌의 게임 실리콘밸리 - Silicon Valley 슈츠 - Suits    지금까지 기억나는 추천 리스트 정리, 한편씩만 본 것들은 배제\n미드 실리콘밸리 - Silicon Valley 요것도 강추, IT 맨이라면 필수적으로 보자. 대화에 대부분이 욕설인데, 원래 우리도 이렇게 하는 것 아닌가? 실생활 문장들.\n   Season 4 - 보고싶다.\n 일단 시즌 종료인지 확인해 보자. 자막도 확인    Season 3 - 2016.06 막 종료.\n 헐, 왕좌의 게임 과 같이 끝나는 운명. 쯧 일단 회사 말아먹고, 다시 시작 기술력이 결국 경쟁력이 아니라는 과정을 시즌 3까지 보면서 느낌 운과 멍청한 자본가가 필요하다는 사실. 자본은 영리하지 않고, 돈이 돈을 부르는 세상에서 살고있음 실력은 머 개뿔. 세상의 흐름에 영향을 그닥 주지 않음. 실력자가 너문 많음 바글거리는 SCV 들\u0026hellip;    House of cards - 하우스 오브 카드 강추~~ 미국 정치 드라마, 대통령이 되기 위한 무수한 암수들\n 키 포인트 어랏~ 중심인물이 한순간에 사라지네.  계약과 관련이 많이 있다고 하네요.      Season 4 종료,  케빈 스페이시가 이젠 정식 대통령이 되어야 할 텐데    Game of thrones - 왕좌의 게임 왠 어린이 드라마인가 하고 보다. 노출 장면에 눈이 가고, 전투씬이 죽이고 이제 어마무시한 스토리로 잡아먹고 있다. 다음 시즌 기대\n  Season 6 아쉽게 종료, 존 스노우가 부활, 용어머니 부활 정도 빼곤 스토리가 너무 나열되고 있음  시즌 6 주요장면 - 네이버 TV캐스트    슈츠 - Suits 한국에서 리메이크 한다고 하니 기대가 되는 작품. 한국형으로 어떻게 바뀔까. 시즌제가 아니니 먼가 결론이 나는 드라마가 될터인데 걍 해피엔딩이겠지만..몇년후 잘 살았다 머 이런..혹은 아이돌 몇명이 나와 연예하는 드라마로 변질될 우려도 ^^;;;\n  Season 6 진행중 - 교도소와 로펌의 부활에 대한 이야기 진행중  #4 검사의 딜을 받아들이기로. 여친이 세상에서 제일 좋은 듯 아무것도 중요한 것이 없어 나머지는 ㅋㅋ #7 어려움이 있어야지.딜이 잘안되는 상황. 어떻게 극복하려나? 어렵게 찾은 증인이 마이크의 공이 아니니 ^^;; #10 마이크는 어찌저찌 석방. 다 잘 해결. 마지막에 제시카의 은퇴선언. 초심을 찾았다나 머라나.   Season 5 - 결국 가짜 변호사 들통나면서 마무리 Season 4 그닥 기억이 없음 Season 1~3 재미있음. 줄거리가 좋으니 사기 천재 변호사..  "
},
{
	"uri": "https://devbj.com/tags/%EB%AF%B8%EB%93%9C/",
	"title": "미드",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/%EC%98%81%ED%99%94/",
	"title": "영화",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/encoding/",
	"title": "Encoding",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/encoding/",
	"title": "Encoding",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/golang/",
	"title": "Golang",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/%EB%B2%88%EC%97%AD/",
	"title": "번역",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/bytes/",
	"title": "Bytes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/bytes/",
	"title": "Bytes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/package/",
	"title": "Package",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/strings/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/strings/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/io/",
	"title": "IO",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/io/",
	"title": "IO",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/golangkorea/structuring-applications-in-go/",
	"title": "Go에서 애플리케이션 설계하기",
	"tags": ["번역", "아키텍쳐"],
	"description": "",
	"content": " Structuring Applications in Go을 번역한 글입니다.\n 개요 Go를 배울 때 가장 어려웠던 부분은 애플리케이션을 어떻게 설계하는가였다. Go 이전에, 나는 Rails 애플리케이션을 만들었었는데 Rails는 애플리케이션을 특정한 방식으로 설계하도록 한다. \u0026ldquo;설정보다는 컨벤션\u0026quot;이라는게 그들의 모토였다. 그러나 Go는 그 어떤 프로젝트 구조나 애플리케이션 설계방식을 규정짓고 있지 않으며 Go의 컨벤션은 대개 제각각이다.\n나는 Go 애플리케이션의 아키텍쳐를 구성하면서 발견한 정말 많은 도움이 되었던 4가지 패턴을 여러분에게 알려주려고한다. 이들은 공식적인 규칙은 아니며 누군가는 다른 의견을 가질 수 있다고 생각한다. 나는 그런 의견들을 듣고싶다! 제안할만한게 있다면 댓글로 달아줬으면 좋겠다.\n1. 전역 변수를 사용하지 말라 내가 읽었던 Go의 net/http 예시들은 다음과 같이 항상 함수들을 http.HandleFunc를 사용하여 등록한다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/hello\u0026#34;, hello) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;hi!\u0026#34;) } 이 예제는 net/http를 사용하기 위한 쉬운 방법을 제공하지만 이는 나쁜 습관을 가르친다. 함수 핸들러를 사용하게되면, 애플리케이션 상태에 접근하는 유일한 방법은 전역 변수를 사용하는 것이다. 이 때문에, 우리는 전역 데이터베이스 커넥션 또는 전역 설정 변수를 추가할수도 있다. 그러나 유닛 테스트를 작성할 때 이 글로벌 변수들을 사용한다는건 악몽이다.\n더 나은 방법은 핸들러에 대해 특정한 타입을 만들어 필요한 변수들을 가질 수 있게 만드는 것이다.\ntype HelloHandler struct { db *sql.DB } func (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { var name string // 쿼리 실행.  row := h.db.QueryRow(\u0026#34;SELECT myname FROM mytable\u0026#34;) if err := row.Scan(\u0026amp;name); err != nil { http.Error(w, err.Error(), 500) return } // 클라이언트에 전송.  fmt.Fprintf(w, \u0026#34;hi %s\\n\u0026#34;, name) } 이제 우리는 데이터베이스를 초기화할 수 있으며 글로벌 변수 없이 핸들러를 등록할 수 있다.\nfunc main() { // 데이터베이스 커넥션을 연다.  db, err := sql.Open(\u0026#34;postgres\u0026#34;, \u0026#34;...\u0026#34;) if err != nil { log.Fatal(err) } // 핸들러 등록.  http.Handle(\u0026#34;/hello\u0026#34;, \u0026amp;HelloHandler{db: db} http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 이 접근법은 또한 핸들러 유닛 테스팅을 자체적으로 할 수 있다는 이점을 가지며 심지어 HTTP 서버도 필요하지않다.\nfunc TestHelloHandler_ServeHTTP(t *testing.T) { // 커넥션을 열고 핸들러를 설정한다.  db, _ := sql.Open(\u0026#34;postgres\u0026#34;, \u0026#34;...\u0026#34;) defer db.Close() h := HelloHandler{db: db} // 간단한 버퍼를 가지고 핸들러를 실행.  rec := httptest.NewRecorder() rec.Body = bytes.NewBuffer() } UPDATE: Tomás Senart와 Peter Bourgon의 트위터 멘션에서 언급된 클로저를 사용한 핸들러 래핑으로 이를 좀 더 간단히 할 수 있다. 이는 핸들러를 쉽게 구성할 수 있게 해준다.\n2. 애플리케이션에서 바이너리를 분리하라 나는 누군가 \u0026ldquo;go get\u0026quot;을 실행하면 내 애플리케이션이 자동으로 설치될 수 있도록 main.go 파일을 프로젝트 루트에 넣어 사용한다. 그러나, main.go 파일과 애플리케이션 로직을 같은 패키지로 합치게되면 다음의 두 가지 결과를 갖게된다.\n 애플리케이션을 라이브러리로써 재사용할 수가 없다. 오직 하나의 애플리케이션 바이너리만을 가질 수 있다.  이 문제를 해결하기위해 발견한 가장 좋은 방법은 단순히 프로젝트내에서 각 서브 디렉토리가 하나의 애플리케이션 바이너리인 \u0026ldquo;cmd\u0026rdquo; 디렉토리를 사용하는 것이다. 나는 이 접근법을 여러 개의 애플리케이션 바이너리를 사용하는 Brad Fitzpatrick의 Camilstore 프로젝트에서 처음으로 발견했다.\ncamlistore/ cmd/ camget/ main.go cammount/ main.go camput/ main.go camtool/ main.go Camilstore가 설치될 때 빌드되는 4개의 분리된 애플리케이션 바이너리(camget, cammount, camput, camtool)가 있다.\n라이브러리 주도 개발 (Library driven development) main.go 파일을 루트 밖으로 옮기는 것은 애플리케이션을 라이브러리의 관점에서 구현할 수 있게 해준다. 애플리케이션 바이너리는 단순히 애플리케이션 라이브러리의 클라이언트이다. 나는 이것이 나의 핵심 로직 코드(라이브러리)가 무엇이고 애플리케이션 실행 코드(애플리케이션 바이너리)가 무엇인지에 대한 추상화를 명확히 하도록 도와준다는걸 알 수 있다.\n애플리케이션 바이너리는 정말 단순히 사용자가 로직과 상호작용하는 방식에 대한 인터페이스이다. 때때로 당신은 유저가 여러 방법으로 상호작용할 수 있도록 여러개의 바이너리를 생성한다. 예를 들어, 두 수를 더하는 \u0026ldquo;adder\u0026quot;라는 패키지가 있을 때, 커맨드 라인 버전뿐만 아니라 웹 버전을 배포하고 싶을 수도 있다. 프로젝트를 다음과 같이 구성하면 이를 쉽게 만들 수 있다.\nadder/ adder.go cmd/ adder/ main.go adder-server/ main.go 유저는 생략 부호(\u0026quot;\u0026hellip;\u0026quot;)를 사용하여 \u0026ldquo;go get\u0026quot;으로 \u0026ldquo;adder\u0026rdquo; 애플리케이션 바이너리를 설치할 수 있다.\n$ go get github.com/benbjohnson/adder/... 짜잔, 사용자는 설치된 \u0026ldquo;adder\u0026rdquo; 와 \u0026ldquo;adder-server\u0026rdquo; 를 갖게되었다!\n3. 애플리케이션별 컨텍스트를 위한 타입 래핑 내가 발견한 특히 유용한 한 트릭은 애플리케이션 수준의 컨텍스트를 제공하기위해 몇가지 제너릭 타입을 래핑하는 것이다. 한 가지 훌륭한 예는 DB와 Tx (transaction) 타입을 래핑하는것이다. 이 타입들은 database/sql 패키지나 Bolt같은 다른 데이터베이스 라이브러리에서 찾을 수 있다.\n우리는 이 타입들을 다음과 같이 래핑하면서 시작할 수 있다:\npackage myapp import ( \u0026#34;database/sql\u0026#34; ) type DB struct { *sql.DB } type Tx struct { *sql.Tx } 이제 우리의 데이터베이스와 트랜젝션을 위해 초기화 함수를 래핑하자:\n// Open은 데이터 소스를 위한 DB 레퍼런스를 반환한다. func Open(dataSourceName string) (*DB, error) { db, err := sql.Open(\u0026#34;postgres\u0026#34;, dataSourceName) if err != nil { return nil, err } return \u0026amp;DB{db}, nil } // Begin은 새로운 트랜젝션을 반환하기 시작한다. func (db *DB) Begin() (*Tx, error) { tx, err := db.DB.Begin() if err != nil { reutnr nil, err } return \u0026amp;Tx{tx}, nil } 예를 들어, 만약 사용자가 생성하기 전에 다른 시스템에 대한 검증이 필요하다거나 다른 테이블들의 업데이트가 필요할 때 이 함수는 더 복잡한 일을 할 수 있다.\n트랜잭션 구성 이 함수들을 Tx 에 추가하는 것의 또 다른 이점은 하나의 트랜잭션에서 여러개의 액션을 구성할 수있다는 것이다. 사용자를 추가해야 하는가? 그냥 Tx.CreateUser() 를 한 번 호출하면 된다:\ntx, _ := db.Begin() tx.CreateUser(\u0026amp;User{Name:\u0026#34;susy\u0026#34;}) tx.Commit() 기본 데이터 스토어를 추상화 하는것은 새 데이터베이스로 교환하거나 다수의 데이터베이스의 사용을 쉽게 만들어준다. 그들은 애플리케이션의 DB \u0026amp; Tx 타입을 호출하는 코드로부터 모두 감춰져있다.\n4. 서브패키지로 골머리를 앓지 말라 대다수의 언어는 패키지 구조를 원하는대로 구성할 수 있도록 한다. 나는 모든 클래스들이 다른 패키지에 채워지고 이 패키지들은 서로를 모두 포함하고 있는 Java 코드베이스를 가지고 근무했던적이 있다. 정말 엉망이었다!\nGo는 패키지를 위한 요구조건이 딱 한가지 있는데, 순환 의존(cyclic dependencies)을 가질 수 없다는 것이다. 처음엔 이 순환 의존 규칙이 조금 이상하게 느껴졌다. 나는 원래 프로젝트를 각 파일은 하나의 타입을 가지고 패키지에는 파일들이 여러개 있도록 구성하며 새로운 서브패키지를 만들려고 했었다. 그러나 이 서브패키지들은 패키지 \u0026ldquo;A\u0026quot;를 포함하는 패키지 \u0026ldquo;C\u0026quot;를 포함하는 패키지 \u0026ldquo;B\u0026quot;를 포함하는 패키지 \u0026ldquo;A\u0026quot;를 찾을 수 없었기에 점점 관리하기가 어려워졌다. 이는 순환 의존이 될 것이다. 나는 \u0026ldquo;너무 많은 파일들\u0026quot;을 갖게 되는것에 대해서는 제외하고 패키지들을 분리시킬만한 이유가 없다는 걸 깨달았다.\n최근 나는 오직 하나의 루트 패키지를 사용하는 방법을 택했다. 보통 내 프로젝트의 타입들은 모두 매우 연관이 많기 때문에 이는 사용성이나 API 관점에서 더 잘 맞았다. 이 타입들은 또한 API를 작고 명확하게 유지하는 사이에 노출되지 않은것들을 호출하는 장점을 가질 수 있다.\n여기에 내가 찾아낸 큰 패키지를 만드는데 도움이 되는 몇가지 팁이 있다.\n 각 파일에 관련있는 타입과 코드를 함께 그룹핑하라. 타입과 함수들이 잘 구성되어 있다면 그 파일은 200에서 500줄의 소스코드를 가지는 경향이 있다는걸 발견했다. 이는 많은 것처럼 들릴 수도 있지만 이는 탐색하기가 쉽다는걸 알아냈다. 나의 경우 보통 한 파일의 대한 상한은 1000줄이다. 가장 중요한 타입은 파일의 맨 위에 놓고 밑으로 갈수록 중요성이 낮아지는 순서대로 타입을 추가하라. 애플리케이션이 10,000라인을 넘어가기 시작하면 이 프로젝트를 더 작은 프로젝트들로 나눌 순 없는지를 심각하게 고민해보라.  Bolt는 이에 대한 좋은 예제이다. 각 파일은 하나의 Bolt 구조체와 관련 있는 타입들로 그룹핑된다:\nbucket.go cursor.go db.go freelist.go node.go page.go tx.go 결론 코드 구성은 소프트웨어 개발에 있어 가장 어려운 주제중 하나이며 이것이 가져오는 가치에 초점을 맞추는 일은 드물다. 전역 변수를 적게 사용하고, 애플리케이션 바이너리 코드를 패키지로 옮기고, 애플리케이션별 컨텍스트를 위해 타입을 래핑하고, 서브패키지는 제한하라. 이들은 단지 Go 코드를 쉽게 작성하고 더 나은 유지보수가 가능하도록 도와주는 몇가지 트릭들이다.\nGo 프로젝트를 Ruby, Java 또는 Node.js 프로젝트와 같은 방식으로 작성하게되면 아마 언어와 싸우게 될 것이다.\n"
},
{
	"uri": "https://devbj.com/tags/%EB%B2%88%EC%97%AD/",
	"title": "번역",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/",
	"title": "아키텍처",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90/",
	"title": "아키텍쳐",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/how-to/",
	"title": "How-to",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/object-oriented/",
	"title": "Object Oriented",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/struct/",
	"title": "struct",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/allocator/",
	"title": "allocator",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/bootstrap/",
	"title": "bootstrap",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/internals/",
	"title": "Internals",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/memory/",
	"title": "memory",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/runtime/",
	"title": "runtime",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/%ED%95%B5%ED%82%B9/",
	"title": "핵킹",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/linker/",
	"title": "linker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/metadata/",
	"title": "metadata",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/object-file/",
	"title": "object file",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/relocations/",
	"title": "relocations",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/compiler/",
	"title": "Compiler",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/structure/",
	"title": "Structure",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/assembler/",
	"title": "Assembler",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/beginning/",
	"title": "beginning",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/avr/",
	"title": "AVR",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/develop/",
	"title": "develop",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/driver/",
	"title": "driver",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/embedded/",
	"title": "embedded",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/f/w/",
	"title": "F/W",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/iot/",
	"title": "IoT",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/it/",
	"title": "IT",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/mbed/",
	"title": "mbed",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/s/w/",
	"title": "S/W",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2016-09-07-w5500-drivers/",
	"title": "W5500 drivers",
	"tags": ["W5500", "IoT", "driver", "S/W", "F/W", "develop", "embedded", "IT", "mbed", "Ethernet", "W5100", "Arduino", "AVR"],
	"description": "",
	"content": "(수정시간) 2016-09-07\n W5500 Driver open source projects - 오픈소스  AVR-ATmel LPC 시리즈 - NXP LPC11exxx \u0026hellip;  W5500으로 이더넷 구현하기 (개발 환경 구축)   STM32 시리즈 - ST Microelectronics PIC 시리즈 - Microchips PIC18, PIC24 \u0026hellip; PSoC 시리즈 - Cypress    W5500 Driver open source projects - 오픈소스 이전에 PSoC W5500 Driver 에 관련된 글을 작성했었다.  W5500 Ethernet driver for PSoC - FreeRTOS\n 이외에 많은 대중적인 MCU 들이 많이 있는데 관련해서 드라이버 소스들을 정리해 보고자 한다.\n일단, 공식적으로 WIZnet에서 제공하고 있는 통합 라이브러리는 아래와 같다.\n https://github.com/Wiznet/ioLibrary_Driver ; SOCKET APIs like BSD \u0026amp; WIZCHIP(W5500 / W5300 / W5200 / W5100) Driver\n AVR-ATmel  일단 아두이노 소스를 모두 활용할 수 있다.  Arduino Ethernet Github site\nhttps://github.com/arduino/Arduino/tree/master/libraries/Ethernet\n 또다른 아두이노 진영인 arduino.org 의 최신 소스코드 - 여기가 좀 더 W5500 테스트가 많이 되어 있는 것 같다.  https://github.com/arduino-org/Arduino/tree/ide-org-1.6.1.x/libraries/Ethernet2\n보드에 같이 올라가 있는 상품도 있고. http://www.arduino.org/products/boards/4-arduino-boards/arduino-leonardo-eth\n 칩 제작사인 위즈네트에서 제공하는 통합 라이브러리  https://github.com/Wiznet/WIZ_Ethernet_Library\n 통합 라이브러리 이전에 먼저 개발하고 테스트한 공신할 수 있는 embeddist 님께서 작성해 주신,    WIZ Ethernet Library for Arduino IDE-1.6.4 WIZ Ethernet Library for Arduino IDE-1.5.(https://github.com/embeddist/WIZ_Ethernet_Library-IDE1.5.x) WIZ Ethernet Library for Arduino IDE-1.0.5   호주의 뛰어난 개발자 이신 Phillip Stevens 가 만드신 freeRTOS \u0026amp; libraries for AVR ATmega 프로젝트 소스, FreeRTOS 포트 정보를 찾는다면 단언코 이 프로젝트가 레퍼런스 1순위. Goldilocks Analogue 라는 ADC 기능이 기본적으로 탑재되어 있는 Arduino 호환 보드를 개발해서 사업을 하고 있기도 하다.      https://github.com/feilipu/avrfreertos\n  https://github.com/feilipu/avrfreertos/tree/master/freeRTOS82x/lib_iinchip\n  https://sourceforge.net/projects/avrfreertos/\n   ehajo 라는 독일업체에서 만든 보드와 예제 코드.   http://www.ehajo.de/en/boards/ethernet-shield-wiznet-w5500.html https://github.com/ehajo/wiznet   기타 제작자들의 작품들.   https://github.com/dansut/Cosa/tree/W5100-W5500/libraries/W5100 (통합드라이버) https://github.com/oltzen/W5500Example ; 블로그의 위치는 http://www.oltzen.de/w5500.html (독일어, 구글 번역하면 볼 만 함)  LPC 시리즈 - NXP LPC11exxx \u0026hellip;  위즈네트에서 개발된 W5500 용 EVB, 메인 칩셋으로 NXP사의 LPC 시리즈를 이용하고 있다.  https://github.com/Wiznet/W5500_EVB\n개발 환경의 구축에 관련된 내용은 위즈네트 아카데미(http://wiznetacademy.com) 에서 강의를 들어 볼 수 있으며,\n강의노트 - WIZnet Academy (http://wiznetacademy.com/wp/wp-content/uploads/2015/02/WIZnet-Academy-W5500-WebServer.pdf)\n또한 아래 글을 참고해도 된다.\nW5500으로 이더넷 구현하기 (개발 환경 구축)  W5500 EVB로 IoT 개발하기 - Echo Server 2015.01.06 W5500 EVB로 IoT 개발하기 - W5500 Driver porting 2015.01.06 W5500 EVB로 IoT 개발하기 - 툴 설치편 2015.01.06   ARM 사의 오픈소스개발환경인 http://mbed.com 을 통해서도 많은 예제와 소스코드를 찾을 수 있다.  먼저 하드웨어는 W5500 Ethernet Kit for IoT (https://developer.mbed.org/components/W5500-Ethernet-Kit-for-IoT/) 을 사용하면 된다.\nARM mbed 환경에서는 Cortex-M 시리즈의 칩셋을 기본적으로 제공하고 있으므로 NXP 뿐 아니라 STM32 코드로도 활용이 가능하다.\nSTM32 시리즈 - ST Microelectronics  먼저 WIZnet(http://wiznet.co.kr) 에서 제공하고 있는 Web module 의 소스코드를 가장 먼저 레퍼런스 할 수 있다.  https://github.com/Wiznet/WIZ550web\nhttps://github.com/Wiznet/WIZ550Web_STM32F103RB_CoIDE ; 무료 컴파일러 Coocox 버전 (http://www1.coocox.org/CooCox_CoIDE.htm)\n Arduino for STM32 Project (https://github.com/rogerclarkmelbourne/Arduino_STM32) 의 일부 프로젝트로 진행된 라이브러리.  Vassilis Serasidis 님이 개인적으로 코드사이즈, DHCP 라이브러리를 직접 테스트 하며 완성된 통합 라이브러리 버전이다. 짝짝~~\nhttps://github.com/Serasidis/Ethernet_STM ; WIZnet W5500, W5200, W5100 ethernet library for 8-bit, 32-bit Arduino and STM32F1 (STM32F103) micro-controllers\n성공스토리는 이 포럼글에서 확인해 볼 수 있다. : \u0026ldquo;W5500 library is (finally) ported\u0026rdquo;\n참고로 Arduino STM 프로젝트는 이전에 Maple Project (http://www.leaflabs.com/about-maple/)에서 생성된 것으로 아두이노 IDE를 ARM 계열에서도 사용해 보자고 하는 운동에서 시작되었다.\n- 국내 개발자, w5500 모듈을 가지고 기본 라이브러리를 활용하여 TCP/IP 서버와 클라이언트를 구현한 KEIL 프로젝트로 아래 링크에서 소스코드를 다운로드 받을 수 있다.\nwiznet ethernet controller w5500 with STM32F10\nPIC 시리즈 - Microchips PIC18, PIC24 \u0026hellip;  유럽에서 진행되고 있는 통합 EVB 같은 ETH WIZ click  본 모듈은 http://www.mikroe.com/ 이라는 곳에서 기본 보드와 아주 다양한 기능별 모듈을 제공하여 Prototype 설계를 가능하게 해 준다.\n그림처럼 아주 깔끔한 형태의 보드를 제공하고 있고, 물론 예제 라이브러리도 아주 고급지게 제공된다.\n물론 아래와 같이 PIC 시리즈를 포함하여 AVR, ARM 소스도 같이 제공하고 있어 다양한 활용이 가능하다.\nhttp://libstock.mikroe.com/projects/view/1314/eth-wiz-click-board-example\nExamples are written for :\n EasyPIC v7 - PIC18F45K22 EasyPIC v7 for dsPIC30 - dsPIC30F4013 EasyPIC Fusion v7 - PIC32MX795F512L EasyAVR v7 - ATmega32 EasyMX PRO v7 STM32 - STM32F107VC EasyFT90x v7 - FT900    약간 특이하게 아래와 같이 아두이노 호환형태의 보드와 Basic 형태의 코드와 라이브러리를 배포하고 있는 Firewing Project 도 PIC 시리즈를 이용하시는 분들은 참고할 만 하다.  단, 컴파일러/IDE의 지원이 이곳(http://www.firewing.info/pmwiki.php?n=Main.HomePage)에서 유료로? 무료로 받는지는 확인해보고 사용해 보시길.\nW5500 Dirver 페이지는 http://www.firewing.info/pmwiki.php?n=FirewingUser.W5500 - https://github.com/FeezingCode/pic18_W5500\nPSoC 시리즈 - Cypress - W5500 Ethernet driver for PSoC - FreeRTOS 여기에 정리를 해 두었다. 그래도 간략하게, 해당 링크는  http://www.e2forlife.com/2015/09/its-been-a-while/\n 이 페이지에는 W5500 드라이버는 물론이고, FreeRTOS 사용자들을 위해 porting 작업이 완료되어 있는 소스를 공개하고 있다.\n해당 소스의 위치는  Check out the “example” project at https://github.com/e2forlife/PSoC-W5500-Example.git\n 아직 FreeRTOS 전체적인 프로젝트가 종료되지 않아서 최종 릴리즈 버전은 없지만 개발 버전은 자신의 Github을 통해 공유하고 있다. 소스의 위치는 아래 링크를 참고하기 바란다.\n 프로젝트 페이지 https://github.com/e2forlife/PSoC-FreeRTOS\n개발 버전 공개페이지 : https://github.com/e2forlife/PSoC-FreeRTOS/tree/Implement-PSoC5\n "
},
{
	"uri": "https://devbj.com/tags/drama/",
	"title": "drama",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/movie/",
	"title": "movie",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/tool/",
	"title": "tool",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/torrent/",
	"title": "torrent",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/util/",
	"title": "util",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2016-08-31-torrent/",
	"title": "추천 토렌트 사이트 - torrent, 자료",
	"tags": ["torrent", "drama", "util", "tool", "movie", "토렌트", "영화", "드라마", "미드"],
	"description": "",
	"content": "(수정시간) 2016-08-31\n 추천 토렌트 사이트 기타  회원가입 없고, 광고가 적은 것으로 추천\n추천 토렌트 사이트   tvzil - https://tvzil.com\n 목록이 제일 잘 되어 있는 사이트 거의 완벽하다. 광고도 허용할 수준    토사랑 - https://tosarang.net\n 자료의 양이 제일 많은 것 같다. 리스트의 형태가 tvzil 보다는 텍스트 기반으로 되어 있어 조금 불편할 뿐 자료가 더 많아서 찾기는 수월 사실 모든 한글 사이트는 자료의 양이 거의 동일하다.    토렌트하자 - https://torrenthaja.com/\n 엄청 잘 되어 있긴하다. 리스트의 형태도 괜찮고 단, 조금 느리고 최신 자료는 대부분 다 있다. 광고가 좀 보기 민망하다. 그래도 다 그러니 혹시 위 2 사이트에 없으면 한 번 뒤져보자.    기타  현재자료없음.  "
},
{
	"uri": "https://devbj.com/tags/%ED%86%A0%EB%A0%8C%ED%8A%B8/",
	"title": "토렌트",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/install/",
	"title": "install",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/blog/",
	"title": "blog",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/development/",
	"title": "development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/vim/",
	"title": "vim",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/vim/",
	"title": "vim",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/golangkorea/vim-go/",
	"title": "vim-go를 이용한 go 개발 환경 구축",
	"tags": ["Development", "vim"],
	"description": "",
	"content": "Vim Vim은 Emacs와 함께 (적어도 리눅스에서는) 가장 널리 사용하는 에디터일 것이다. 가볍고 빠르며, 어디에서나 실행되기 때문에 그 단순함에도 불구하고 여전히 사랑받고 있다. GUI 환경에서 사용하는 IDE에 익숙한 개발자라면 \u0026ldquo;요즘 같은 시대에 왠 구닥다리 터미널 기반 에디터냐\u0026quot;라고 생각할 지도 모르겠다. 아래 그래프를 보자.\nGo언어를 대상으로 조사한 결과인데, Vim이 거의 40% 정도를 차지하고 있다. Emacs까지 하면 터미널 기반 에디터를 사용하는 개발자가 절반이 넘는다. 물론 Go 언어가 시스템과 네트워크 분야의 백앤드 프로그램의 개발에 특화된 측면을 고려해야 겠지만 말이다.\nVim-go Vim은 다양한 플러그인을 제공한다. Vim-go는 Go 개발환경을 지원하는 플러그인이다. 지원하는 기능은 아래와 같다.\n 함수, 오퍼레이터, 메서드들에 대한 Syntax highlighting gocode를 이용한 자동완성 :GoDef를 이용해서 메서드, 변수들의 선언 위치를 네비게이션 할 수 있다. :GoImport를 이용한 패키지 임포트 :GoTest와 :GoTestFunc를 이용한 유닛 테스트 테스트 커버리지를 위한 :GoCoverage :GoBuild, :GoInstall을 이용한 패키지 컴파일과 설치 :GoRun을 이용한 빠른 실행 소스 분석을 위한 :GoImplements, :GoCallee, :GoReferrer Lint툴 :GoLint :GoPlay로 코드를 play.golang.org 로 공유 등 개발 환경을 만들기 위한 거의 모든 기능들을 제공한다. 여기에 파일 네비게이션 플러그인, 자동완성 플러그인들을 추가로 설치하면, IDE 부럽지 않은 개발 환경을 만들 수 있다.  Vim-go 설치 Vim의 플러그인들을 편리하게 관리하기 위해서 몇 가지 패키지 매니저들이 있다. 보통 Vundle 이나 pathogen을 사용한다. 나는 pathogen을 사용하고 있다. 아래와 같이 설치하자.\n# mkdir -p ~/.vim/autoload ~ /.vim/bundle # cd ~/.vim/autoload # curl -LSso pathogen.vim https://tpo.pe/pathogen.vim .vimrc 파일을 수정한다.\ncat ~/.vimrc execute pathogen#infect() syntax on filetype plugin indent on 이제 vim-go를 설치하자.\n# cd ~/.vim/bundle # git clone https://github.com/fatih/vim-go.git Go 개발을 위한 환경 설정은 다음과 같다.\n# export GOPATH=$HOME/golang # export PATH=$PATH:$GOPATH/bin # mkdir $HOME/golang # echo $GOPATH /home/yundream/golang # echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/yundream/golang/bin.... vim-go 프로젝트는 구글의 mercurial에서 관리하고 있다. mercurial도 설치해야 vim-go를 빌드 할 수 있다.\n# apt-get install mercurial vim을 실행 한후 명령모드에서 :GoInstallBinaries를 수행하면, 자동으로 vim-go를 빌드해서 설치해준다.\n# vim ~ ~ :GoInstallBinaries vim-go: gocode not found. Installing github.com/nsf/gocode to folder /home/yundream/.vim-go/ vim-go: goimports not found. Installing code.google.com/p/go.tools/cmd/goimports to folder /home/yundream/.vim-go/ vim-go: godef not found. Installing code.google.com/p/rog-go/exp/cmd/godef to folder /home/yundream/.vim-go/ vim-go: oracle not found. Installing code.google.com/p/go.tools/cmd/oracle to folder /home/yundream/.vim-go/ vim-go: golint not found. Installing github.com/golang/lint/golint to folder /home/yundream/.vim-go/ vim-go: errcheck not found. Installing github.com/kisielk/errcheck to folder /home/yundream/.vim-go/ vim-go: gotags not found. Installing github.com/jstemmer/gotags to folder /home/yundream/.vim-go/ 계속하려면 엔터 혹은 명령을 입력하십시오 Vim-go 기능 빠르게 살펴보기 Go 코드의 실행\n:GoRun 빌드\n:make :GoBuild 에러체크\n:GoErrCheck 패키지 임포트\n:GoImport fmt 심볼에 대한 정의로 이동. 해동 심볼에서 :GoDef\n:GoDef 대략 이런 식이다. 나머지 명령들은 직접 실행해 보자.\n자동완성 자동완성은 IDE의 가장 쓸만한 기능 중 하나일 것이다. vim의 **YCM(YouCompleteMe)**를 이용해서 자동완성 기능을 추가 할 수 있다. 컴파일을 하기 때문에 python-dev와 cmake 패키지를 미리 설치해야 한다.\n# cd ~/.vim/bundle # git clone https://github.com/Valloric/YouCompleteMe.git # cd YouCompleteMe # ./install.sh 이제 자동완성 기능을 사용 할 수 있다. 아래 화면을 보자.\nYCM은 C, C++, Python, Java 등에도 사용 할 수 있다.\nTagBar 설치 ctags는 코드에 포함된 패키지, struct, 메서드의 목록을 한눈에 보여주는 애플리케이션이다. ctags를 설치하자. tagbar는 ctags를 기반으로 작동하는 플러그인이다.\n# apt-get install ctags tagbar 플러그인을 설치한다.\n# cd ~/.vim/bundle # git clone https://github.com/majutsushi/tagbar.git 이제 :TagbarToggle 명령으로 tagbar 네비게이션 창을 열고 닫을 수 있다.\n명령어를 입력하기 귀찮다면, 단축 키를 만들자.\n# cat .vimrc ...... map \u0026lt;F8\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt; NerdTree 설치 NerdTree는 파일 네비게이션을 만들어주는 플러그인다.\n# cd ~/.vim/bundle # git clone https://github.com/scrooloose/nerdtree.git NerdTree와 TagBar를 적용한 화면이다.\n명령을 일일이 입력하기가 귀찮아서 단축키를 등록했다.\n# cat ~/.vimrc set ts=4 map \u0026lt;F8\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; map \u0026lt;F2\u0026gt; :GoDef\u0026lt;CR\u0026gt; map \u0026lt;F4\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt; "
},
{
	"uri": "https://devbj.com/golangkorea/",
	"title": "GoLang Korea",
	"tags": ["Community", "Blog", "Hugo"],
	"description": "",
	"content": "The Slow Hunch Where Good Ideas Come From: The Natural History of Innovation의 저자 Steven B. Johnson에 따르면 인류의 역사를 바꾼 혁신들은 번뜩이는 아이디어에서 시작된 경우가 매우 드물다고 합니다. 대개는 개개인의 작은 아이디어들이 오랜 시간에 걸쳐 다른 사람이 갖고 있는 비슷하거나 전혀 다른 아이디어들과 충돌하고 결합하면서 커뮤니티의 지능으로 진화하고 어느 순간 돌이킬 수 없는 변화의 모멘텀을 형성하며 세상을 바꿉니다. 커뮤니티내에 공유되고 있는 지능이 다시 역으로 개개인에게 영감과 비젼을 제시하는 상호작용을 일으키게 되는데 그런 과정은 통해 아이디어의 생산을 가능케하는 현상을 slow hunch라고 부릅니다.\n새로 시작하는 Golang Korean 커뮤니티 웹사이트(이하 GoSudaWeb)은 프로그래밍 언어인 Go와 퉅들, 글로벌 개발자 커뮤니티내의 트랜드와 최선의 개발방식에 대한 소개를 블로그와 뉴스레터의 형식을 통해 공유하고자 첫발을 내딛었습니다. 지속적인 지식의 축적과 폭 넗은 공유가 이루어지는 웹사이트로 성장하여 미래의 킬러앱과 킬러 아이디어를 만들어내는 slow hunch에 기여할 수 있기를 기대해 봅니다. 많은 성원 부탁드립니다.\n콘텐트 제작 및 웹사이트 개발 참여 신청 GosudaWeb은 Github Page로 제작되고 모든 소스와 제작과정이 공개로 이루어 집니다: https://github.com/golangkorea.\n사이트에 포스트하기를 원하시는 분들은 사이트에 블로그 올리는 방법을 참조하시길 바랍니다.\nHugo를 이용해 사이트 개발에 참여하거나 golangkorea Organization에 오픈소스 프로젝트를 시작하시고 싶으신 분들은 멤버 신청을 하실 수 있습니다. 멤버 신청은 golanginkorea@gmail.com 이나 Golang Korean Community / Lobby로 해 주시면 됩니다. 일단 멤버로 등록되면 golangkorea-website team을 통해 개발에 참여하실 수 있습니다.\n토론방 golangkorea.github.io 개발, 유지 보수 및 지원에 대한 토론은 Gitter Room을 통해 하고 있으니 많은 동참 바라겠습니다.\n"
},
{
	"uri": "https://devbj.com/golangkorea/tdd-with-golang/",
	"title": "Golang 프로젝트에 TDD 도입하기",
	"tags": ["Development", "UnitTest", "TDD"],
	"description": "",
	"content": "여기에서 사용한 테스트 코드는 Bitbucket 에서 다운로드 할 수 있다.\nTDD 클라우드와 MSA와 REST의 등장으로 TDD가 재조명 받고 있다. TDD를 제대로 적용하려면 상당히 많은 시간과 노력이 필요하다. 특히 여기 저기 연동되는 라이브러리나 소프트웨어가 많은 경우 테스트가 굉장히 복잡해지는데, 복잡해지는 만큼 테스트의 신뢰성도 함께 떨어진다.\nTDD는 유닛 테스트를 기본으로 하는데, 애플리케이션이 복잡해지면 유닛테스트에 간섭하는 객체들이 많아진다. 이렇게 늘어난 객체들에 대해서 테스트를 진행하다 보면 테스트를 위한 설계로 변질되는 경우가 있다.\n데이터베이스, 소켓, UI가 서로 엉켜있는 소프트웨어를 테스트 한다고 생각해보라. 머리 좀 아플 것이다. 물론 TDD가 테스트를 쉽게 할 수 있는 설계를 지향하긴 하지만, 테스트를 쉽게 할 수 있는 설계와 테스트를 위한 설계는 엄연히 다른 것이다.\nTDD의 단점은 아래와 같이 정리 할 수 있다.\n 개발 기간이 늘어난다. TDD에 익숙해졌다고 가정 할 경우 약 20% 정도 구현시간이 늘어난다. 복잡한 소프트웨어의 경우 더 구현시간은 더 늘어날 것이다. 복잡성 증가. 테스트시나리오가 길어질 경우, 시나리오 자체를 관리하는 것도 작업이 된다. 디자인 변경. 종종 TDD에 어울리지 않는 디자인의 소프트웨어를 개발 해야 하는 경우도 있다. TDD는 좋은 코드는 테스트하기 좋은 코드다라고 주장한다. 하지만 항상 그런건 아니다. TDD에 맞추다 보니 디자인이 이상해지는 경우가 종종 생긴다.  요약하자면 실행관점에서 TDD를 위한 기본 요소는 유닛 테스트인데, 소프트웨어가 복잡해지면 굉장히 힘들어 지는게 TDD의 문제다.\n달리 생각하면 소프트웨어가 단순해지면 TDD를 하기 좋은 환경이 된다는 이야기가 되겠다.MSA와 REST 바로 그런 환경이다.\nMSA는 작업 서비스(애플리케이션)들을 결합해서 하나의 큰 서비스를 만드는 서비스 디자인 스타일이다. 각 MSA 서비스들은 다른 서비스들과 독립적으로 구성되고 단순한 기능을 가지도록 설계되기 때문에 유닛 테스트가 큰 효과를 발휘 할 수 있다.\nGo언어는 범용 시스템언어로 개발이 됐지만 net/http와 gorilla를 비롯해서 MSA+REST(이하 MSA) 스타일의 웹 애플리케이션을 효과적으로 만들 수 있도록 지원하고 있다. 나는 Go 언어에서 MSA 애플리케이션을 TDD로 개발하고 테스트 하는 방법을 정리 하려 한다. 이 문서에서 다룰 내용은 아래와 같다.\n Go 언어에서 제공하는 유닛테스트 프레임워크를 살펴본다. HTTP 핸들러 테스트 : HTTP 웹 서버 핸들러를 테스트하려면, 서버가 실행 중이어야 하기 때문에 메서드 단위의 유닛 테스트로는 테스트가 어렵다. net/http/httptest패키지를 이용해서 HTTP 핸들러를 테스트할 수 있다. TDD는 유닛테스만 의미하지 않는다. 개발 에서 배포까지의 전 과정을 테스트를 기반으로 통합하는 일련의 과정들이다. 젠킨스(Jenkins)를 이용해서 TDD를 완성해 본다. 테스트 커버리지는 유닛테스트가 얼마나 잘 이루어졌는지를 측정하기 위해서 사용한다. 테스트 커버리지를 계산하고 그 결과를 문서로 출력한다. 이 문서를 젠킨스와 통합해보자.  Go 유닛 테스트 개요 Go 는 테스트 프레임워크를 내장(build-in)하고 있다. testing페키지를 이용해서 유닛 테스트 코드를 만들고 go test명령으로 테스트를 수행하면 된다. 유닛 테스트를 위한 간단한 예제 코드를 만들었다. 코드의 이름은 math.go 다.\npackage math import ( \u0026#34;errors\u0026#34; ) // 값들을 모두 더한다. func Sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } // a를 b로 나눈다. func Div(a float64, b float64) (float64, error) { if b == 0 { return 0.0, errors.New(\u0026#34;Can\u0026#39;t divide by zero\u0026#34;) } return a / b, nil } // 문자열을 count만큼 반복하고 결과를 반화한다. func StrRept(s string, count int) string { b := make([]byte, len(s)*count) bp := copy(b, s) for bp \u0026lt; len(b) { copy(b[bp:], b[bp:]) bp *= 2 } return string(b) } 유닛 테스트 파일을 만든다. 파일의 이름은 math_test.go다. 참고로 유닛 테스트 파일의 이름은 반드시 _test.go로 끝나야 한다.\npackage math import ( \u0026#34;testing\u0026#34; ) func Test_Sum(t *testing.T) { v0 := Sum(1, 2, 3) if v0 != 6 { t.Fatal(\u0026#34;1+2+3 == 6\u0026#34;) } v1 := Sum(6, 5) if v1 != 11 { t.Fatal(\u0026#34;6+5 == 11 \u0026#34;) } } func Test_Div(t *testing.T) { v2, _ := Div(0, 2) t.Log(\u0026#34;0/2 =\u0026#34;,v2) } func Test_StrRept(t *testing.T) { str := StrRept(\u0026#34;a\u0026#34;, 3) if len(str) != 3 { t.Fatal(\u0026#34;Repeat fail\u0026#34;) } } go test를 실행해보자.\n# go test PASS ok _/home/yundream/workspace/golang/unitTest\t0.001s -v 옵션을 주면 자세한 테스트 정보를 확인 할 수 있다. 로그(t.Log) 정보도 함께 출력한다.\n# go test -v === RUN Test_Sum --- PASS: Test_Sum (0.00s) === RUN Test_Div --- PASS: Test_Div (0.00s) math_test.go:21: 0/2 = 0 === RUN Test_StrRept --- PASS: Test_StrRept (0.00s) PASS ok _/home/yundream/workspace/golang/unittest\t0.002s Test_StrRept테스트를 아래와 같이 수정 한 다음에 테스트해보자.\nfunc Test_StrRept(t *testing.T) { str := StrRept(\u0026#34;ab\u0026#34;, 3) if len(str) != 3 { t.Fatal(\u0026#34;Repeat fail\u0026#34;) } } 테스트 조건을 바꿨는데, 실수로 예상 결과를 수정하지 않았다.\n# go test -v === RUN Test_Sum --- PASS: Test_Sum (0.00s) === RUN Test_Div --- PASS: Test_Div (0.00s) math_test.go:21: 0/2 = 0 === RUN Test_StrRept --- FAIL: Test_StrRept (0.00s) math_test.go:27: Repeat fail FAIL exit status 1 FAIL\t_/home/yundream/workspace/golang/unittest\t0.002s 테스트 실패를 확인 할 수 있다.\ntesting 패키지 함수가 실행 된 결과가 예측한 결과와 맞아 떨어지는 지를 검사하는 방식으로 테스트를 진행 한다. t.Fatal(), **t.Fail()**등을 이용해서 테스트를 제어 할 수 있다.\n **FailNow()**이 호출되면, 테스트 함수를 즉시 종료하고 다음 테스트 함수를 실행한다. **Fatal()**는 로그를 출력하는 걸 제외하고 FailNow 메서드와 같은 일을 한다. **Fail()**이 호출되면, 테스트가 실패하더라도 함수를 종료하지 않고 다음 코드를 계속 실행한다. **Error()**는 로그를 출력하는 걸 제외하고 Fail 메서드와 같은 일을 한다. Errorf() 형식화된 로그를 출력한다. Fila 메서드와 같은 일을 한다. Log() 테스트 로그를 출력한다. Logf() 형식화된 테스트 로그를 출력한다. Failed() 실패하더라도 레포트하지 않는다.  Assertion 테스트 코드를 만들다 보면 if 문이 코드의 절반 이상을 차지하는 걸 보게될 것이다. 비교대상도 가지각색이라서 가독성이 떨어진다. assert 함수가 필요하다. 직접 만들어 보고 싶겠지만 그냥 잘 만들어져 있는 테스트 패키지 가져다가 쓰자. 내가 요즘 쓰고 있는 테스트 패키지는 github.com/stretchr/testify/assert이다. 패키지를 설치 한 후 아래 코드를 테스트 했다.\npackage yours import ( \u0026quot;github.com/stretchr/testify/assert\u0026quot; \u0026quot;testing\u0026quot; ) func TestSomething(t *testing.T) { // assert equality assert.Equal(t, 123, 125, \u0026quot;they should be equal\u0026quot;) // assert inequality assert.NotEqual(t, 123, 456, \u0026quot;they should not be equal\u0026quot;) } }}} 테스트를 돌려보자. {{{#!plain # go test --- FAIL: TestSomething (0.00s) Error Trace: yours_test.go:11 Error:\tNot equal: 123 (expected) != 125 (actual) Messages:\tthey should be equal FAIL exit status 1 FAIL\t_/home/yundream/workspace/golang/mytest\t0.003s 테스트 코드와 테스트 결과의 가독성 모두 좋아졌다. 이 패키지는 assert외에도 mock, http 테스트, suite등 테스트를 위한 다양한 툴들을 지원한다.\nHTTP 핸들러 테스트 HTTP 핸들러의 경우 웹 서버를 띄워야 하기 때문에, 메서드보다 테스트가 까다롭다. 아래의 방식으로 테스트 할 수 있다.\n net/http/httptest 패키지를 이용한 테스트. httptest를 이용하면 루프백(127.0.0.1)에 바인드 되는 서버를 띄울 수 있다. 이후 net/http에서 제공하는 클라이언트 메서드들을 이용하면 서버 \u0026amp; 클라이언트모드에서 테스트 할 수 있다. 아예 빌드하고 실행하고, HTTP 클라이언트를 이용해서 테스트 한다. 각각의 장/단점이 있다. 1의 경우 테스트 커버리지를 확인 할 수 있고, 2의 경우에는 통합된 환경에서의 테스트가 가능하다. 나는 1과 2의 방법을 모두 다 사용하고 있다. 여기에서는 httptest를 이용한 테스트를 살펴볼 생각이다.  테스트에 사용한 소스코드 트리다.\n. ├── handler │ ├── handler.go │ └── handler_test.go └── main.go net/http, gorilla, 패키지를 이용해서 개발 했다. GET /ping에 대해서 \u0026ldquo;pong\u0026quot;를 리턴하는 일을 한다.\npackage handler import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;net/http\u0026#34; ) type Handler struct { router *mux.Router } func (h Handler) Init() { h.router = mux.NewRouter() h.router.HandleFunc(\u0026#34;/ping\u0026#34;, h.Ping).Methods(\u0026#34;GET\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, h.router) } func (h Handler) Ping(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \u0026#34;pong\u0026#34;) } func (h Handler) Calc(w http.ResponseWriter, r *http.Request) { } 테스트 코드다.\n// handler_test.go package handler import ( \u0026#34;github.com/gorilla/handlers\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; ) var ( server *httptest.Server testUrl string ) type Response struct { Content string Code int } func Test_Init(t *testing.T) { logfile, err := os.OpenFile(\u0026#34;/tmp/test.log\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0755) assert.Nil(t, err, \u0026#34;\u0026#34;) h := Handler{} h.Init() server = httptest.NewServer(handlers.CombinedLoggingHandler(logfile, http.DefaultServeMux)) testUrl = server.URL } func Test_Ping(t *testing.T) { res, err := DoGet(testUrl + \u0026#34;/ping\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, 200, res.Code, \u0026#34;PING API\u0026#34;) assert.Equal(t, \u0026#34;pong\u0026#34;, res.Content, \u0026#34;PONG Message\u0026#34;) } func DoGet(url string) (*Response, error) { response, err := http.Get(url) if err != nil { return nil, err } defer response.Body.Close() contents, err := ioutil.ReadAll(response.Body) if err != nil { return nil, err } return \u0026amp;Response{Content: string(contents), Code: response.StatusCode}, nil } httptest패키지는 테스트를 위해서 내장된 웹 서버를 실행한다. 따라서 핸들러 등록, 데이터베이스 연결과 같이 서비스를 위해서 필요한 자원들을 초기화 해야 한다. Test_init메서드를 이용해서 서비스를 초기화 하고 있다. 테스트 코드에 대한 디버깅은 testing.T.Log 계열의 메서드를 이용해서 모니터에 표준출력하는 방식으로 진행하는데, 웹 서버가 실행되는 방식이라서 로그를 표준출력 할 수 없다. 그래서 /tmp/test.log에 access log를 남기기로 했다.\nhttptest.NewServer 메서드를 실행하면, 웹 서버가 실행된다. 웹 서버의 접근 URL은 server.URL에 저장돼 있다.\nTest_Ping에서 ping API를 테스트한다. 테스트는 http client를 이용한다. 200 OK와 \u0026ldquo;pong\u0026rdquo; 메시지를 검사하고 있다. 테스트결과다.\n# go test -v === RUN Test_Init --- PASS: Test_Init (0.00s) === RUN Test_Ping --- PASS: Test_Ping (0.00s) PASS ok bitbucket.org/dream_yun/handlertest/handler\t0.003s 존재하지 않는 페이지를 요청 할 경우 404 Page Not Found를 반환해야 할테다. 이를 테스트하기 위한 코드를 만들었다.\nfunc Test_APINotFound(t *testing.T) { res, err := DoGet(testUrl + \u0026#34;/myfunc\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, 404, res.Code, \u0026#34;Unknown API\u0026#34;) } 이렇게 테스트 시나리오에 따라서 테스트 코드를 추가하면 된다.\n서비스간 연동 테스트 MSA 모델을 따르는 애플리케이션을 만들다 보면, 다른 (REST)애플리케이션과 통신 해야 할 수도 있다.\nApp02는 서비스에서 발생한 다양한 데이터들을 관리하는 일을 한다. 유저가 업로드한 이미지, 문서 파일은 App-02로 전달된다. App-02는 이 파일들을 유저 설정에 따라서 S3, DropBox, Google Drive 등으로 전송한다.\n나는 App01 서비스도 유저가 입력한 연산과 그 결과를 App02를 이용해서 저장하기로 했다. \u0026ndash; 이게 어떤 쓸모가 있는 기능인지는 묻지도 말고 따지지도 말자 \u0026ndash; 코드의 추가와 추가된 코드에 대한 테스트가 필요하다.\nApp02를 직접 띄운다음 테스트 하는 방법도 있다. 이 방법에 따라 테스트 하려면 App02를 단순 실행하는 것이 아닌, App02가 제대로 실행 할 수 있는 환경을 만들어야 한다. 그러니까 S3, DropBox, Google Drive 등과 연동할 수 있는 환경을 개발 서버에 만들어야 한다. 애로 사항이 꽃필 것이다. 최종 연동 테스트에서는 이렇게 해야겠지만, 개발단계에서 이렇게 하기는 쉽지 않다.\n나는 입력과 출력만 검사하는 블랙 박스 테스트를 실행하기로 했다. httptest 패키지를 이용해서 App02 테스트 서버를 만들었다. 물론 App02 테스트 서버를 만들기 위해서는 App02의 API 명세서와 App02 패키지가 필요하다. 아래는 테스트 서버 코드다. handler 디렉토리 밑에 만들었다.\n// handler/app02_test_server.go package handler import ( \u0026#34;bitbucket.org/dream_yun/app02\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/gorilla/handlers\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;os\u0026#34; ) type TestApiServer struct { router *mux.Router } // 실행 후 테스트 서버의 URL을 반환한다. func (api *TestApiServer) Run() string { api.router = mux.NewRouter() api.router.HandleFunc(\u0026#34;/save/{serviceName}\u0026#34;, api.Save).Methods(\u0026#34;POST\u0026#34;) api.router.HandleFunc(\u0026#34;/save/{serviceName}/{fileName}\u0026#34;, api.ReadFile).Methods(\u0026#34;GET\u0026#34;) logfile, _ := os.OpenFile(\u0026#34;/tmp/app02_test.log\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) server := httptest.NewServer(handlers.CombinedLoggingHandler(logfile, api.router)) return server.URL } // Save API다. 여기에 여러가지 테스트 조건들을 코딩하면 된다. func (api TestApiServer) Save(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) serviceName := vars[\u0026#34;serviceName\u0026#34;] if serviceName != \u0026#34;calc\u0026#34; { w.WriteHeader(http.StatusBadRequest) return } fmt.Fprintf(w, app02.ServiceOK) } // 저장된 파일을 가져온다. func (api TestApiServer) ReadFile(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) serviceName := vars[\u0026#34;serviceName\u0026#34;] fileName := vars[\u0026#34;fileName\u0026#34;] if serviceName != \u0026#34;calc\u0026#34; { w.WriteHeader(http.StatusBadRequest) return } if fileName == \u0026#34;my.jpg\u0026#34; { fmt.Fprintf(w, app02.ServiceOK) return } } 연산을 끝낸 후에 Save API를 호출하도록 Div 메서드를 수정했다.\ntype Handler struct { router *mux.Router fileServer string } func (h Handler) Init(fileServer string) { h.router = mux.NewRouter() h.fileServer = fileServer h.router.HandleFunc(\u0026#34;/ping\u0026#34;, h.Ping).Methods(\u0026#34;GET\u0026#34;) h.router.HandleFunc(\u0026#34;/div/{a}/{b}\u0026#34;, h.Div).Methods(\u0026#34;GET\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, h.router) } func (h Handler) Div(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) a := vars[\u0026#34;a\u0026#34;] b := vars[\u0026#34;b\u0026#34;] ai, err := strconv.Atoi(a) if err != nil { w.WriteHeader(http.StatusInternalServerError) return } bi, err := strconv.Atoi(b) if err != nil { w.WriteHeader(http.StatusInternalServerError) return } if bi == 0 { w.WriteHeader(http.StatusNotAcceptable) return } if ai == 0 { w.WriteHeader(http.StatusNotAcceptable) return } DoPost(h.fileServer+\u0026#34;/save/calc\u0026#34;, \u0026#34;a/b\u0026#34;) fmt.Fprintf(w, \u0026#34;%d\u0026#34;, ai/bi) }  Handler 구조체에 fileServer 변수를 추가했다. 여기에는 app02 서버의 주소가 저장된다. 매개변수로 app02 서버를 받도록 Handler.Init() 메서드를 수정했다.  Test 코드도 수정했다.\nfunc Test_Init(t *testing.T) { logfile, err := os.OpenFile(\u0026#34;/tmp/test.log\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0755) assert.Nil(t, err, \u0026#34;\u0026#34;) FileServer := TestApiServer{} fileServerAddr := FileServer.Run() h := Handler{} h.Init(fileServerAddr) server = httptest.NewServer(handlers.CombinedLoggingHandler(logfile, http.DefaultServeMux)) testUrl = server.URL } TestApiServer의 바인드 주소를 읽어서 Handler.Init() 메서드에 넘기도록 테스트 코드를 수정했다. 이제 테스트를 실행하면 TestAPIServer가 실행되고, Div 메서드가 TestAPIServer의 save api를 호출하는 것을 볼 수 있을 거다.\n이 테스트는 완전하지 않다. Div의 DoPost 호출 부분을 충분히 테스트하지 않았기 때문이다. 테스트 커버리지를 높이려면, DoPost를 호출하는 별도의 메서드를 만들어서 메서드의 입/출력을 테스트 할 수 있도록 해야 한다.\n여기에서 중요한 점은 테스트를 쉽게 하기 위해서 메서드들을 수정했다는 점이다. TDD에서는 코드에 맞는 테스트를 하는게 아니고, 테스트에 맞는 코드를 만든다.\n목업 vs 직접 구성 예제로 삼았던 ping API 서버는 외부 소프트웨어의 도움 없이 작동한다. 하지만 현실에서 이런 코드를 찾기는 어렵다. 마이에스큐엘(Mysql), 몽고디비(Mongodb), 주키퍼(zookeeper), 레디스(Redis) 등 수많은 다른 애플리케이션들과 통신을 한다. 어떻게 테스트 해야 할까.\n연동 애플리케이션과 서버를 모두 구축해서 테스트 하는 방법이 있다. 마이에스큐엘, 몽고디비, 레디스.. 등등을 모두 설치해서 테스트 하는 거다. 이 방법의 단점은 상당히 귀찮다는 것이다. 혼자 하는 개발하는 하고 있다면 좀 귀찮아도 해볼만 하지만, 여럿이 개발한다면 애로사항이 꽃필 것이다. 이외에도 데이터베이스 오류 상황에서, 소프트웨어가 어떻게 작동할지를 테스트하기가 쉽지 않다는 것도 문제다.\n이 문제는 mocks/stubs으로 모의 객체를 만들어서 테스트하는 것으로 테스트 커버리지는 늘리면서도 테스트 시간을 줄일 수 있다.\n결론부터 말하자면 난 목업을 이용하지 않고 있다. 작동하는 소프트웨어들과 직접 연동해서 테스트 한다. 개발/테스트 환경 구축의 번거로움은.. 글쎄 나는 (데이터베이스를 설치하고 설정하는) 정도의 번거로움은 감수해야 하고, 감수한 만큼 개발자에게 이득이 있다고 생각하는 입장이다. 그리고 세상이 좋아졌다. VM, Container, Vagrant 등을 이용하면 개발환경을 손쉽게 구성하고 배포, 공유 할 수 있다.\n테스트 커버리지 테스트에 대한 품질은 테스트 커버리지로 측정 할 수 있다.\n# go test -cover PASS coverage: 100.0% of statements ok bitbucket.org/dream_yun/handlertest/handler\t0.004s 모든 코드를 완전히 테스트 하고 있다. 이 예제로는 테스트 커버리지를 확인하기가 애매모호해서, API를 추가했다.\n// package handler func (h Handler) Div(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(request) a := vars[\u0026#34;a\u0026#34;] b := vars[\u0026#34;b\u0026#34;] if b == 0 { w.WriteHeader(http.StatusNotAcceptable) return } if a == 0 { w.WriteHeader(http.StatusNotAcceptable) return } ia, err := strconv.Atoi(a) ib, err := strconv.Atoi(b) fmt.Fprint(w) } 지금은 코드를 먼저 만들었지만 TDD의 원칙을 정확히 따르려면, 테스트 코드를 먼저 만들고 나서 코드를 만들어야 할 것이다. 다만 MSA의 경우에는 API단위로 하는 일이 특정되기 때문에, 코드를 먼저 만들고 테스트 코드를 만드는 것도 괜찮은 방법이라고 생각한다. TDD를 위한 TDD가 문제다라는 주장이 나오는 이유를 생각해보자. 완전한 방법, 완전한 툴은 없다. 자신의 역량과 환경에 적절하게 응용해서 사용해야 한다.\n유닛 테스트를 돌려보자. 테스트 커버리지가 떨어진 걸 확인 할 수 있을 것이다.\n# go test -cover PASS coverage: 21.7% of statements ok bitbucket.org/dream_yun/handlertest/handler\t0.004s Div 메서드에 대한 테스트 코드를 만들어서 커버리지를 올리기로 했다.\nfunc Test_Div(t *testing.T) { res, err := DoGet(testUrl + \u0026#34;/div/4/2\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, http.StatusOK, res.Code) assert.Equal(t, \u0026#34;2\u0026#34;, res.Content) res, err = DoGet(testUrl + \u0026#34;/div/4/a\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, http.StatusInternalServerError, res.Code, \u0026#34;Invalide argument\u0026#34;) res, err = DoGet(testUrl + \u0026#34;/div/0/4\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, http.StatusNotAcceptable, res.Code, \u0026#34;Invalide argument\u0026#34;) res, err = DoGet(testUrl + \u0026#34;/div/4/0\u0026#34;) assert.Nil(t, err, \u0026#34;\u0026#34;) assert.Equal(t, http.StatusNotAcceptable, res.Code, \u0026#34;Invalide argument\u0026#34;) } ```go ```sh # go test -cover PASS coverage: 91.3% of statements ok bitbucket.org/dream_yun/handlertest/handler\t0.005s }}} 테스트 커버리지는 \u0026ldquo;이 소프트웨어는 적어도 이 정도의 코드 영역에 대해서 테스트 하고 있다\u0026quot;는 것을 알려준다. 특히 코드에 대한 리펙토링이나 기능 추가시 필요한 품질을 측정하는데 매우 좋은 자료가 된다. 예를 들어 현재 릴리즈된 소프트웨어의 커버리지가 90%일 경우, 수정된 코드의 커버리지를 90%로 맞춘다면 적어도 이전에 테스트했던 내용들은 모두 테스트 했으며, 이전 수준에서의 품질을 유지 하고 있다고 예상 할 수 있을 것 이다.\n스타트업의 경우 서비스의 품질보다 출시 시기가 중요한 경우가 많다. 이 경우 소위 기술부채라는 명목으로 품질을 희생하는 경우가 많은데, 나중에 기술부채를 제거하기 위해서 엄청난 시간과 노력을 투입해야 할 수 있다. 개발 환경을 갖추지 못한 상태에서 급하게 기술부채를 제거 할 경우 곤욕을 치를 수 있고, 서비스의 발목을 잡을 수도 있다.\n테스트 코드는 리펙토링과 설계변경을 쉽게 할 수 있도록 도와준다. 테스트 커버리지를 관리하는 것으로 일관성 있는 품질을 달성 할 수 있다. 유닛 테스트를 이용해서 기술 부채를 관리 할 수 있다.\n테스트 커버리지의 목표를 90%로 잡았다고 가정해 보자. 91.3 % 이니 이 정도면 충분하다고 생각 할 수 있겠으나 그렇지 않다. 서비스의 보안수준은 가장 약한 보안 고리에 의해서 결정된다. 서비스 품질 역시 마찬가지로 가장 약한 고리가 서비스의 전체 품질을 결정 한다. 따라서 테스트 하지 않은 부분이 서비스에 중요한 영향을 미칠 수 있는 지 점검 해야 한다. 위의 정보로는 어느 부분이 테스트가 안됐는지를 확인 할 수 없다.\n테스트 커버리지 레포트를 만들어 보자.\n# go test -coverprofile=coverage.out # go tool cover -html=coverage.out -coverprofile 옵션을 이용하면 테스트한 코드 영역에 대한 레포트가 만들어진다. 일반 텍스트 파일인데, tool cover 명령을 이용해서 html 파일로 변환 할 수 있다.\nstrconv.Atoi() 메서드에 대한 테스트가 빠져있음을 알 수 있다. 이에 대해서 \u0026ldquo;Div API는 클라이언트가 숫자(0-9)가 아닌 다른 값을 보낼 수도 있으므로, 에러 체크가 필요하다. 그리고 변수 a, b에 대한 타당성(숫자인지, int64 범위의 값인지 등)을 검사하는 코드도 추가해야 한다\u0026quot;라는 평가를 할 수 있을 것이다.\ngocov go에서 제공하는 기본 툴도 쓸만하긴 하지만, 레포팅 기능이 썩 맘에 들지 않는다. 그래서 gocov라는 툴을 이용해서 레포트를 만들기로 했다.\n# go get github.com/axw/gocov/gocov # go get github.com/matm/gocov-html gocov test를 이용해서 커버리지 데이터파일을 만든다.\n# gocov test ./ \u0026gt; handler.json ok bitbucket.org/dream_yun/handlertest/handler\t0.005s\tcoverage: 91.3% of statements handler.json을 html 파일로 변환한다.\n# gocov-html handler.json \u0026gt; handler.html 브라우저로 읽어보자.\n훨씬 보기 좋아졌다.\n젠킨스와의 통합 이미 젠킨스를 통해서 테스트를 자동화 하고 있다. 여기에 레포트만 추가하면 된다.\n젠킨스에 웹 서버를 설치하고 gocov test, gocov-html 과정에서 나온 html 결과물을 웹 서버 디렉토리에 저장해서 레포팅 하는 방법도 있다. 하지만 레포팅 결과물이 젠킨스 대시보드와 분리된다는 점이 썩 맘에 들지 않는다. 그리고 gocov-html은 현재 상태만 보여준다는 문제가 있다. 테스트 결과를 평가 하기 위해서는 이전 테스트 결과도 함께 볼 수 있어야 한다. 그래서 젠킨스의 코드 테스트 커버리지 레포팅 플러그인인 Cobertura를 사용하기로 했다. Cobertura는 자바코드의 커버리지를 측정하기 위해서 만들어진 툴이지만 XML 포멧만 맞춘다면 다른 언어에도 문제없이 사용 할 수 있다.\ngocov의 결과를 xml로 출력하기 위해서 gocov-xml을 설치했다.\n# go get github.com/AlekSi/gocov-xml 아래와 같이 테스트커버리지 결과를 xml 문서로 출력할 수 있다.\n# gocov test ./ | gocov-xml \u0026gt; coverage.xml 젠킨스에 cobertura 플러그인을 설치하는 과정은 Go언어와 Jenkins문서를 참고하자. 아래는 적용 결과다.\nTDD 통합 프로세스 MSA 모델을 따르는 소프트웨어의 개발에서 배포 단계까지의 테스트 방식을 정리해 보자.\n개발 단계에서는 화이트 박스 테스트와 블랙 박스 테스트를 함께 사용한다. 직접 제어하고 테스트 할 수 있는 코드들은 화이트 박스 테스트의 대상이다. 애플리케이션을 구성하고 있는 핸들러와 핸들러에서 호출하는 메서드들이다.\n다른 애플리케이션과 (REST API로) 연결된 코드의 경우에는 블랙 박스 테스트를 진행한다. 해당 애플리케이션 개발자로 부터 API 규격을 받아서, 입력과 출력을 테스트 하는 방식이다. httptesting을 이용해서 블랙 박스 테스트를 위한 웹 서버를 띄우면 된다. 입력과 출력의 사양은 연동 애플리케이션의 패키지를 그대로 사용할테니, 문서의 내용과 코드가 맞지 않는다고 해도 문제될게 없다. 그냥 패키지를 참고해서 개발해도 된다. 연동 애플리케이션의 규격이 변경될 경우 테스트에러가 떨어질테니 개발단계에서 문제를 해결 할 수 있게 된다.\n통합 단계에서는 연동 테스트까지 진행한다. 최신 버전의 애플리케이션을 실행 하고, 직접 API를 전송해서 테스트 하는 방식이다.\n"
},
{
	"uri": "https://devbj.com/tags/tdd/",
	"title": "TDD",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/tdd/",
	"title": "TDD",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/categories/unittest/",
	"title": "UnitTest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/unittest/",
	"title": "UnitTest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/english/",
	"title": "english",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/%EC%98%81%EC%96%B4/",
	"title": "영어",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2016-08-01-english/",
	"title": "영어 공부",
	"tags": ["blog", "english", "영어"],
	"description": "",
	"content": "(수정시간) 2016-09-21\n 영어학원 온라인영어 화상영어  블로그 만들면서 참고한 글을 정리해 본다.\n영어학원  @수내역 랩스어학원  시간당 6만원 정도 물론 20시간씩 하면 15~20% 할일 한 45,000 원 정도로 가능   @서현역  마찬가지 그룹과외 주 3회 30만원 정도   @서현역 월스트리트  드라마, 영화 교육위주 혼자 공부하는 시간이 많음. 책장사. 무튼 가격은 6개월에 200만원 정도   @역삼역 fastcampus  2달과정. 비즈니스 괜춘한듯 빨리하면 2달 70만원. 투자해~~    온라인영어   하우위잉글리쉬\n 여기 실생활 회화가 늘 것 같은 느낌이 팍팍 트레이닝 형태를 잘 따라가면..매력적인 강의방법/내용 드라마, 영화에서 필요한 문자을 다 찾아서 강의. 좀 대단한듯~    리카수니 - 입트영 첨삭블로그\n 완전 잘 정리해주심. 매일매일 영어뉴스도 괜찮음 입트영 자체가 좋은 듯 스터디 필요    화상영어  전대건TV  네이버카페 ; 30만원에 10번정도..   샐리앤찰리  가격아직모름, 강남역 커피와 함께 괜찮아 보임.     "
},
{
	"uri": "https://devbj.com/tags/build/",
	"title": "build",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/c/",
	"title": "c",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/c++/",
	"title": "c++",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/compile/",
	"title": "compile",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/jekyll/",
	"title": "jekyll",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/tags/makefile/",
	"title": "makefile",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/2016-07-26-makefile/",
	"title": "Makefile 분석",
	"tags": ["makefile", "c", "c++", "build", "compile", "development"],
	"description": "",
	"content": "(수정시간) 2016-07-26 마크다운 연습도 할 겸 아래글 내용을 가져옵니다. 오래된 글이라 새로 적어두는 것도 의미가 있진 않을까요? 개인용 블로그이니 조금 이해해 주시길..\n 원본소스-Makefile 만들기\n \u0026mdash; 아래 \u0026mdash;\n 환경 간단한 Makefile 만들기 이제부터는 make 로 컴파일 완료 특수문자 확장자 규칙 .c.o 매크로로 치환 gccmakedep 결언  환경 설명을 위해 아래와 같이 6개의 소스 파일이 있다고 하겠습니다.\n main.c와 main.h tcp.c와 tcp.h rs232.c와 rs232.h   여기서 생각해야 될 점은 main.c를 언제 컴파일하느냐 하는 것입니다. main.c 는 rs232.c의 함수와 tcp.c의 함수를 사용하기 때문에 main.c 자체가 변경되는 것 외에도 rs232.h와 tcp.h가 변할 때에도 컴파일하는 것이 안전합니다.\n main.c 자체가 수정되었을 경우 main.h 가 수정되었을 경우 rs232.h 또는 tcp.h 가 변했을 경우   tcp.c와 rs232.c는 자기 자신이 바뀌거나 해당 헤더파일이 변경되면 다시 컴파일이 되도록 합니다. 이제 이를 위한 간단한 Makefile을 보시겠습니다.\n간단한 Makefile 만들기  Makefile 의 구조는 아래와 같습니다.\n 목표: 아래 명령을 실행하게 되는 모든 조건에 해당되는 파일 목록 실행 명령어\n  이와 같은 구조로 필요한 만큼 나열하면 됩니다. 다음은 실제 Makefile 내용입니다.\n명령어 앞에는 반드시 탭 문자로 간격을 띄워야 합니다. 공백으로 띄우시면 make 실행 시 에러가 발생합니다.\n    명령어 설명     sample : main.o tcp.o rs232.o main.o tcp.o, rs232.o 파일 중 변경되는 파일이 있다면 아래의 명령을 실행합니다.   gcc -lm -o sample main.o tcp.o rs232.o main.o, tcp.o, rs232.o로 실행파일 sample 를 만듭니다.   sample : main.o tcp.o rs232.o main.o tcp.o, rs232.o 파일 중 변경되는 파일이 있다면 아래의 명령을 실행합니다.   sample : main.o tcp.o rs232.o main.o tcp.o, rs232.o 파일 중 변경되는 파일이 있다면 아래의 명령을 실행합니다.    sample : main.o tcp.o rs232.o gcc -lm -o sample main.o tcp.o rs232.o \u0026lt;\u0026ndash; 명령어, 즉 gcc 앞에는 tab 키로 들여 쓰기를 해야합니다.\nmain.o : main.c main.h rs232.h tcp.h gcc -c main.c \u0026lt;\u0026ndash; sample 에서 링크할 것이므로 여기에서는 -c를 사용하여 컴파일만 하겠습니다.\ntcp.o : tcp.c tcp.h gcc -c tcp.c\nrs232.o : rs232.c rs232.h gcc -c rs232.c\nmain.c, main.h, rs232.h tcp.h 파일 중 변경되는 파일이 있다면 아래의 명령을 실행합니다.\n  대충 이해가 되시나요? 뭐야 이거? 하시는 분이 계실지 모르겠습니다. 위이 예제는 아주 무식하지만 직관적으로 바로 이해되는 아주 간단한 Makefile 예제가 되겠습니다.\n이제부터는 make 로 컴파일 완료  이제 쉘에서 make 라는 명령으로 간단히 컴파일하고 실행 파일을 만들 수 있습니다.\n make   편하죠? 그런데 Makefile 을 이렇게 만들면 타이핑을 해야할 것이 너무 많지요. 대부분의 프로그래머는 아주 게으릅니다. 타이핑으로 먹고 사는 사람들이 타이핑 많은 거, 좋와하지 않죠.\n 이제, Makefile 만의 매크로를 이용하여 타이핑하는 횟수를 줄여 보겠습니다.\n특수문자    문자 내용     $@ 목표 이름   $* 목표 이름에서 확장자가 없는 이름   $\u0026lt; 조건 파일 중 첫번째 파일   $? 목표 파일 보다 더 최근에 갱신된 파일 이름    자, 소개한 매크로를 이용하여 Makefile의 내용을 좀더 간단하게 만들 수 있습니다. 링크하는 부분을 먼저 보겠습니다.\nsample : main.o tcp.o rs232.o gcc -lm -o \u0026lt;font color=\u0026quot;#000000\u0026quot;\u0026gt;**sample**\u0026lt;/font\u0026gt; main.o tcp.o rs232.o  여기서 $@는 무엇일까요? 네, sample이 되겠습니다. 그러므로 아래와 같이 수정할 수 있습니다.\n sample : main.o tcp.o rs232.o gcc -lm -o **$@**main.o tcp.o rs232.o\n  이해 되시죠. 이 번에는 $*오 $\u0026lt;, $? 에 대해서 말씀드리겠습니다.\n tcp.o : tcp.c tcp.h gcc -c tcp.c  $는 목표 이름에서 확장자를 제거한 이름이니까 .o를 뺀 tcp가 되겠습니다. 그러므로 $를 이용하면 이렇게 수정할 수 있습니다\n tcp.o : tcp.c tcp.h gcc -c $*.c  이해 되시죠? $\u0026lt;는 조건에 열거된 파일 목록 중 첫번재를 의미합니다. 그러므로 $\u0026lt;는 조건 파일인 tcp.c tcp.h 중에서 첫번째 파일의 이름에 해당되므로 tcp.c 가 되겠습니다. 그러므로 아래와 같이 바꿀 수도 있습니다. 저 같은 경우 제일 많이 사용합니다.\n tcp.o : tcp.c tcp.h gcc -c $\u0026lt;  $? 는 \u0026ldquo;현재 목표 파일 파일 보다 더 최근에 갱신된 파일 이름\u0026quot;을 나타내는 매크로입니다. 뜻은 알겠는데, 도대체 어디에 사용하는지 필요성을 잘 모르겠네요. 여하튼 예로 따져 보변 tcp.o 후에 tcp.h 가 수정되었다면 tcp.h가 된다는 것입니다.\n확장자 규칙 .c.o  일반적으로 .o 는 .c 로 만들어 지므로 실은 위의 예를 아래와 같이 명령 실행 없이 작성해도 make가 실행이 됩니다.\n sample : main.o tcp.o rs232.o gcc -lm -o $@ main.o tcp.o rs232.o\n  에이~ 그런데 왜 처음부터 복작하게 썼어? 하시겠지만, 이는 $*, $\u0026lt;, $? 를 설명 드리기 위함도 있지만 위와 같이 처리하면 컴파일은 되지만 컴파일에 대한 상세한 옵션을 처리할 수가 없습니다. 위와 같이 Makefile을 작성하고 make 를 실행하면 아마도 아래와 같이 단순한 모습으로 컴파일 될 것입니다.\n ]$make cc -c -o main.o mainc cc -c -o tcp.o tcp.c cc -c -o rs232.o rs232.c\n  요렇게 말이죠. 그러나 컴파일 할 때에는 인클루드 경로명을 지정하는 것과 같은 옵션을 사용해야 합니다. 이렇게 자동으로 진행되는 것만을 의지할 수 없습니다. 그래서 아래와 같이 .o 를 어떻게 만들어 낼지를 make 에 알려 줍니다.\n sample : main.o tcp.o rs232.o gcc -lm -o $@ main.o tcp.o rs232.o\n**.c.o: gcc -I/home/jwjw/prjs/include -g -c $\u0026lt;**main.o : main.c main.h rs232.h tcp.h tcp.o : tcp.c tcp.h rs232.o : rs232.c rs232.h\n  이제 make를 실행하면 아래와 같이 컴파일되는 모습을 보실 수 있습니다.\n gcc -I/home/jwjw/prjs/include -g -c main.c gcc -I/home/jwjw/prjs/include -g -c tcp.c gcc -I/home/jwjw/prjs/include -g -c rs232.c gcc -lm -o sample main.o tcp.o rs232.o\n  또한 소스 파일이 Makefile과 같은 폴더 안에 있다면 아예 아래와 같이 작성하셔도 컴파일이 됩니다.\n sample : main.o tcp.o rs232.o gcc -lm -o $@ main.o tcp.o rs232.o .c.o: gcc -I/home/jwjw/prjs/include -g -c $\u0026lt;\n  그러나 문제는 각 소스에 대한 컴파일 조건이 매우 단순해 지게 됩니다. 즉, main.c 는 main.c 자신이 수정될 때만 컴파일이 됩니다. 위의 예에서 처럼 rs232.h가 수정되거나 아예 관계가 아주 깊은 main.h 가 수정되더라도 main.c 는 재 컴파일이 안됩니다. 소스끼리 관계가 있다며 하단 부분을 서술해 주셔야 합니다.\n sample : main.o tcp.o rs232.o gcc -lm -o $@ main.o tcp.o rs232.o .c.o: gcc -I/home/jwjw/prjs/include -g -c $\u0026lt;\nmain.o: main.c main.h rs232.h rs232.o: rs232.c rs232.h tcp.o: tcp.c tcp.h\n  그래도 많이 줄어 들었죠? 그러나 이게 다가 아닙니다.\n매크로로 치환  예제의 main.o tcp.o rs232.o 의 파일 이름이 2번 중복되어 있습니다. 두번 타이핑을 해야 하는데, 앞서 말씀드렸듯이 프로그래머는 게으릅니다. 2번~? 귀찮습니다. 아래와 같이 수정해 봅시다.\n OBJS = main.o tcp.o rs232.o\nsample : $(OBJS) gcc -lm -o $@ **$(OBJS)**.c.o: gcc -I/home/jwjw/prjs/include -g -c $\u0026lt;\n  또는 $^ 를 이용하여 아래와 같이 수정할 수 도 있습니다. $^는 조건에 있는 모든 파일 이름을 대신하는 매크로입니다.\n OBJS = main.o tcp.o rs232.o\nsample : $(OBJS) gcc -lm -o $@ $^.c.o: gcc -I/home/jwjw/prjs/include -g -c $\u0026lt;\n  하는 김에 컴파일 옵션과 링크 옵션도 매크로로 치환해 보겠습니다.\n OBJS = main.o tcp.o rs232.o CC = -I/home/jwjw/prjs/include -g -c\nsample : $(OBJS) gcc -lm -o $@ $^.c.o: gcc $(CC) $\u0026lt;\n  이렇게 매크로로 치환하여 Makefile 의 윗 행에 모아 두면, 내용 전체를 볼 필요 없이 매크로 부분만 보거나 수정해도 되기 때문에 편리합니다. 이래서 아래와 같이 수정하여 완성할 수 있습니다.\n TARGET = sample OBJS = main.o tcp.o rs232.o CC = -I/home/jwjw/prjs/include -g -c\n$(TARGET : $(OBJS) gcc -lm -o $@ $^.c.o: gcc $(CC) $\u0026lt;\nmain.o: main.c main.h rs232.h rs232.o: rs232.c rs232.h tcp.o: tcp.c tcp.h\n gccmakedep  다른 것들은 모두 편리하고 좋은 것 같은데, Makefile 하단에 있는 파일 간의 종속에 대한 정보를 모두 타이핑해서 넣어야 할까요? 파일이 많을 경우 어떻게 일일이 입력할 수 있있겠습니까? 당연한 말씀입니다. 게으른 프로그래머에게는 말도 안되죠. 그래서 이와 같은 귀찮은 작업을 make에 떠 넘기겠습니다. 바로 파일간의 의존성을 찾아서 그 내용을 직접 구성해 달라고 요청하는 것이죠.\n 이렇게 파일의 의존성을 검색해서 그 내용을 작성해 주는 것이 gccmakedep 입니다. 아래와 같이 수정해서 make dep를 실행합니다.\n TARGET = sample OBJS = main.o tcp.o rs232.o**SRCS = $(OBJS:.o=.c)**CC = -I/home/jwjw/prjs/include -g -c\n$(TARGET): $(OBJS) gcc -lm -o $@ $^\n.c.o: gcc $(CC) $\u0026lt;\n**dep : gccmakedep $(SRCS)**  이렇게 추가 작성해서 make dep 를 실행하시면 make는 컴파일과 링크 작업 대신에 라벨 dep: 밑의 명령을 실행합니다. 새로 만들어진 SRCS는 OBJS에 열거된 파일 모록에 대해서 확장자를 .o를 .c로 바뀐 목록을 가지게 됩니다. gccmakedep는 소스 파일을 가지고 의존성을 검색할 수 있기 때문이죠.\n ]$ make dep ]$ vi Makefile\nTARGET = sample OBJS = main.o tcp.o rs232.o SRCS = $(OBJS:.o=.c) CC = -I/home/jwjw/prjs/include -g -c $(TARGET): $(OBJS) gcc -lm -o $@ $^ .c.o: gcc $(CC) $\u0026lt; dep : gccmakedep $(SRCS)\n# DO NOT DELETE main.o: main.c /usr/include/stdio.h \u0026hellip;\u0026hellip;\u0026hellip; tcp.o: tcp.c/usr/include/stdio.h \u0026hellip;\u0026hellip;\u0026hellip; rs232.o: rs232.c /usr/include/stdio.h \u0026hellip;\u0026hellip;\u0026hellip;  하단에# DO NOT DELETE 행과 함께 밑으로 각 .o 에 대한 관련 파일 목록이 자동으로 생성되는 것을 보실 수 있습니다. 이제 make를 실행하면 위 정보에 맞추어 컴파일하게 됩니다.\n결언  어떻게 이해가 되십니까? 마지막 부분은 매크로로 되어 있어서 암호같이 보이는데, 지금 보시면 암호 풀이가 되시는지 모르겠습니다. 소개해 드린 것 보다 더 편리한 부분도 있습니다만 내용이 너무 많아 질 것 같아서 여기서 줄입니다. 긴 내용을 읽어 주셔서 감사합니다.\n"
},
{
	"uri": "https://devbj.com/blog/2016-07-21-move-to-jekyll/",
	"title": "지킬 블로그 만들기 - jekyll, github, github pages",
	"tags": ["blog", "jekyll"],
	"description": "",
	"content": "(수정시간) 2016-08-08\n 지킬 기반의 블로그 리소스  블로그 만들면서 참고한 글을 정리해 본다.\n지킬 기반의 블로그  카카오 기술 블로그 - 베껴오고 있음. 개인적으로 css 이런것도 만지기 힘든데. 이렇게 바꿔서 쓰도 되는 것인가???? http://blog.appkr.kr/에서 블로그 플랫폼 이전 1  찬찬히 5개의 단계로 나누어서 설명하고 있다. 찬찬히 배우자.   WordPress 에서 Jekyll 로  자세한설명, 따라하기 좋다.   SCV君\u0026rsquo;s LifeLog : 이글루에 구글 맞춤검색창 달기 - 현재 페이지에 적용된 내용. Jekyll 커스터마이징- 코멘트와 페이지네이션 Jekyll 커스터마이징 2 - 태그  리소스  무료이미지 Pixabay - 커버이미지, 글 이미지 등등 편하게 무료로 morguefile http://unsplash.com/ https://sumall.com/free-marketing-images http://giphy.com/ https://www.iconfinder.com/free_icons  https://www.iconfinder.com/search/?q=trash\u0026amp;price=free   http://picjumbo.com/ http://thisissunriver.blogspot.kr/  "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/attachments/",
	"title": "Attachments",
	"tags": [],
	"description": "The Attachments shortcode displays a list of files attached to a page.",
	"content": "The Attachments shortcode displays a list of files attached to a page.\n  Attachments   BachGavotteShort.mp3  (357 ko)   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   hugo.png  (17 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    Usage The shortcurt lists files found in a specific folder. Currently, it support two implementations for pages\n  If your page is a markdown file, attachements must be place in a folder named like your page and ending with .files.\n  content  _index.md page.files  attachment.pdf   page.md       If your page is a folder, attachements must be place in a nested \u0026lsquo;files\u0026rsquo; folder.\n  content  _index.md page  index.md files  attachment.pdf           Be aware that if you use a multilingual website, you will need to have as many folders as languages.\nThat\u0026rsquo;s all !\nParameters    Parameter Default Description     title \u0026ldquo;Attachments\u0026rdquo; List\u0026rsquo;s title   style \u0026quot;\u0026rdquo; Choose between \u0026ldquo;orange\u0026rdquo;, \u0026ldquo;grey\u0026rdquo;, \u0026ldquo;blue\u0026rdquo; and \u0026ldquo;green\u0026rdquo; for nice style   pattern \u0026ldquo;.*\u0026rdquo; A regular expressions, used to filter the attachments by file name. The pattern parameter value must be regular expressions.    For example:\n To match a file suffix of \u0026lsquo;jpg\u0026rsquo;, use *.jpg (not *.jpg). To match file names ending in \u0026lsquo;jpg\u0026rsquo; or \u0026lsquo;png\u0026rsquo;, use .*(jpg|png)  Examples List of attachments ending in pdf or mp4 {{%attachments title=\u0026quot;Related files\u0026quot; pattern=\u0026quot;.*(pdf|mp4)\u0026quot;/%}}  renders as\n  Related files   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    Colored styled box {{%attachments style=\u0026quot;orange\u0026quot; /%}}  renders as\n  Attachments   BachGavotteShort.mp3  (357 ko)   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   hugo.png  (17 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    {{%attachments style=\u0026quot;grey\u0026quot; /%}}  renders as\n  Attachments   BachGavotteShort.mp3  (357 ko)   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   hugo.png  (17 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    {{%attachments style=\u0026quot;blue\u0026quot; /%}}  renders as\n  Attachments   BachGavotteShort.mp3  (357 ko)   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   hugo.png  (17 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    {{%attachments style=\u0026quot;green\u0026quot; /%}}  renders as\n  Attachments   BachGavotteShort.mp3  (357 ko)   Carroll_AliceAuPaysDesMerveilles.pdf  (175 ko)   adivorciarsetoca00cape.pdf  (361 ko)   hugo.png  (17 ko)   movieselectricsheep-flock-244-32500-2.mp4  (340 ko)    "
},
{
	"uri": "https://devbj.com/blog/button/",
	"title": "Button",
	"tags": [],
	"description": "Nice buttons on your page.",
	"content": "A button is a just a clickable button with optional icon.\n{{% button href=\u0026quot;https://getgrav.org/\u0026quot; %}}Get Grav{{% /button %}} {{% button href=\u0026quot;https://getgrav.org/\u0026quot; icon=\u0026quot;fas fa-download\u0026quot; %}}Get Grav with icon{{% /button %}} {{% button href=\u0026quot;https://getgrav.org/\u0026quot; icon=\u0026quot;fas fa-download\u0026quot; icon-position=\u0026quot;right\u0026quot; %}}Get Grav with icon right{{% /button %}}  Get Grav   Get Grav with icon  Get Grav with icon right   "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/button/",
	"title": "Button",
	"tags": [],
	"description": "Nice buttons on your page.",
	"content": "A button is a just a clickable button with optional icon.\n{{% button href=\u0026quot;https://getgrav.org/\u0026quot; %}}Get Grav{{% /button %}} {{% button href=\u0026quot;https://getgrav.org/\u0026quot; icon=\u0026quot;fas fa-download\u0026quot; %}}Get Grav with icon{{% /button %}} {{% button href=\u0026quot;https://getgrav.org/\u0026quot; icon=\u0026quot;fas fa-download\u0026quot; icon-position=\u0026quot;right\u0026quot; %}}Get Grav with icon right{{% /button %}}  Get Grav   Get Grav with icon  Get Grav with icon right   "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/",
	"title": "Children",
	"tags": [],
	"description": "List the child pages of a page",
	"content": "Use the children shortcode to list the child pages of a page and the further descendants (children\u0026rsquo;s children). By default, the shortcode displays links to the child pages.\nUsage    Parameter Default Description     page current Specify the page name (section name) to display children for   style \u0026ldquo;li\u0026rdquo; Choose the style used to display descendants. It could be any HTML tag name   showhidden \u0026ldquo;false\u0026rdquo; When true, child pages hidden from the menu will be displayed   description \u0026ldquo;false\u0026rdquo; Allows you to include a short text under each page in the list.when no description exists for the page, children shortcode takes the first 70 words of your content. read more info about summaries on gohugo.io   depth 1 Enter a number to specify the depth of descendants to display. For example, if the value is 2, the shortcode will display 2 levels of child pages. Tips: set 999 to get all descendants   sort none Sort Children ByWeight- to sort on menu orderName- to sort alphabetically on menu labelIdentifier- to sort alphabetically on identifier set in frontmatterURL- URL    Demo {{% children %}}   page 1   page 2   page 3   page test   page test   {{% children description=\u0026quot;true\u0026quot; %}}  "
},
{
	"uri": "https://devbj.com/blog/expand/",
	"title": "Expand",
	"tags": [],
	"description": "Displays an expandable/collapsible section of text on your page",
	"content": "The Expand shortcode displays an expandable/collapsible section of text on your page. Here is an example\n  Expand me...   Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  Usage this shortcode takes exactly one optional parameter to define the text that appears next to the expand/collapse icon. (default is \u0026ldquo;Expand me\u0026hellip;\u0026quot;)\n{{%expand \u0026quot;Is this learn theme rocks ?\u0026quot; %}}Yes !.{{% /expand%}}    Is this learn theme rocks ?   Yes !   Demo {{%expand%}} Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. {{% /expand%}}    Expand me...   Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/expand/",
	"title": "Expand",
	"tags": [],
	"description": "Displays an expandable/collapsible section of text on your page",
	"content": "The Expand shortcode displays an expandable/collapsible section of text on your page. Here is an example\n  Expand me...   Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  Usage this shortcode takes exactly one optional parameter to define the text that appears next to the expand/collapse icon. (default is \u0026ldquo;Expand me\u0026hellip;\u0026quot;)\n{{%expand \u0026quot;Is this learn theme rocks ?\u0026quot; %}}Yes !.{{% /expand%}}    Is this learn theme rocks ?   Yes !   Demo {{%expand%}} Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. {{% /expand%}}    Expand me...   Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  "
},
{
	"uri": "https://devbj.com/blog/mermaid/",
	"title": "Mermaid",
	"tags": [],
	"description": "Generation of diagram and flowchart from text in a similar manner as markdown",
	"content": "Mermaid is a library helping you to generate diagram and flowcharts from text, in a similar manner as Markdown.\nJust insert your mermaid code in the mermaid shortcode and that\u0026rsquo;s it.\nFlowchart example {{\u0026lt;mermaid align=\u0026quot;left\u0026quot;\u0026gt;}} graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {{\u0026lt; /mermaid \u0026gt;}}  renders as\ngraph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two]  or you can use this alternative syntax:\nrenders as\ngraph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] Sequence example {{\u0026lt;mermaid\u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {{\u0026lt; /mermaid \u0026gt;}}  renders as\nsequenceDiagram participant Alice participant Bob Alice-John: Hello John, how are you? loop Healthcheck John-John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--Alice: Great! John-Bob: How about you? Bob--John: Jolly good!  or you can use this alternative syntax:\nrenders as\nsequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! GANTT Example {{\u0026lt;mermaid\u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u0026lt; /mermaid \u0026gt;}}  renders as\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d  or you can use this alternative syntax:\nrenders as\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Class example renders as\nclassDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label Git example renders as\ngitGraph: options { \u0026quot;nodeSpacing\u0026quot;: 150, \u0026quot;nodeRadius\u0026quot;: 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/mermaid/",
	"title": "Mermaid",
	"tags": [],
	"description": "Generation of diagram and flowchart from text in a similar manner as markdown",
	"content": "Mermaid is a library helping you to generate diagram and flowcharts from text, in a similar manner as Markdown.\nJust insert your mermaid code in the mermaid shortcode and that\u0026rsquo;s it.\nFlowchart example {{\u0026lt;mermaid align=\u0026quot;left\u0026quot;\u0026gt;}} graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {{\u0026lt; /mermaid \u0026gt;}}  renders as\ngraph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two]  or you can use this alternative syntax:\nrenders as\ngraph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] Sequence example {{\u0026lt;mermaid\u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {{\u0026lt; /mermaid \u0026gt;}}  renders as\nsequenceDiagram participant Alice participant Bob Alice-John: Hello John, how are you? loop Healthcheck John-John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--Alice: Great! John-Bob: How about you? Bob--John: Jolly good!  or you can use this alternative syntax:\nrenders as\nsequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! GANTT Example {{\u0026lt;mermaid\u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u0026lt; /mermaid \u0026gt;}}  renders as\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d  or you can use this alternative syntax:\nrenders as\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d Class example renders as\nclassDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label Git example renders as\ngitGraph: options { \u0026quot;nodeSpacing\u0026quot;: 150, \u0026quot;nodeRadius\u0026quot;: 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/notice/",
	"title": "Notice",
	"tags": [],
	"description": "Disclaimers to help you structure your page",
	"content": "The notice shortcode shows 4 types of disclaimers to help you structure your page.\nNote {{% notice note %}} A notice disclaimer {{% /notice %}} renders as\nA notice disclaimer\n Info {{% notice info %}} An information disclaimer {{% /notice %}} renders as\nAn information disclaimer\n Tip {{% notice tip %}} A tip disclaimer {{% /notice %}} renders as\nA tip disclaimer\n Warning {{% notice warning %}} A warning disclaimer {{% /notice %}} renders as\nA warning disclaimer\n "
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-1/",
	"title": "page 1",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-1/children-1-1/",
	"title": "page 1-1",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-1/children-1-1/children-1-1-1/",
	"title": "page 1-1-1",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-1/children-1-1/children-1-1-1/children-1-1-1-1/",
	"title": "page 1-1-1-1",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-1/children-1-1/children-1-1-1/children-1-1-1-1/children-1-1-1-1-1/",
	"title": "page 1-1-1-1-1",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-2/",
	"title": "page 2",
	"tags": [],
	"description": "",
	"content": "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-3/",
	"title": "page 3",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page, not displayed in the menu\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-4/",
	"title": "page 4",
	"tags": [],
	"description": "This is a demo child page",
	"content": "This is a demo child page, not displayed in the menu\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/test/",
	"title": "page test",
	"tags": [],
	"description": "This is a page test",
	"content": "This is a test demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/test.fr/",
	"title": "page test",
	"tags": [],
	"description": "Ceci est une page test",
	"content": "Ceci est une page de demo\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-2/test3/",
	"title": "page test 3",
	"tags": [],
	"description": "This is a page test",
	"content": "This is a test 3 demo child page\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/children/children-2/test3.fr/",
	"title": "page test 3",
	"tags": [],
	"description": "Ceci est une page test",
	"content": "Ceci est une page de demo test 3\n"
},
{
	"uri": "https://devbj.com/hugolearntheme/shortcodes/siteparam/",
	"title": "Site param",
	"tags": [],
	"description": "Get value of site params variables in your page.",
	"content": "siteparam shortcode is used to help you print values of site params.\nFor instance, in this current site, the editURL variable is used in config.toml\n[params] editURL = \u0026#34;https://github.com/matcornic/hugo-theme-learn/edit/master/exampleSite/content/\u0026#34; Use the siteparam shortcode to display its value.\n`editURL` Value : {{% siteparam \u0026quot;editURL\u0026quot; %}} is displayed as\neditURL Value : https://github.com/bjnhur/mydocs/edit/master/content/\n"
},
{
	"uri": "https://devbj.com/subcategories/",
	"title": "Subcategories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://devbj.com/blog/notionpagecopy/",
	"title": "노션 페이지 복사하기",
	"tags": [],
	"description": "노션 페이지 복사하기",
	"content": "노션 페이지 복사하기\n노션 페이지 복사하기 생각보다 까다로움, 아예 저자가 공용으로 사용해라고 공유해둔 노션페이지는 그냥 Duplicate 메뉴가 있어서 누르면 끝!!\n아래 예제 페이지 처럼 복제할 수 있는 메뉴가 뜨지 않는다. 이때는 어떻게?\n예제 사이트 : https://www.notion.so/3-99-e9730dcfd84f4639a796ed202304b6c2\n이런 경우에는 그냥 자신의 Notion 페이지에서 빈페이지를 하나 만들고,\n그 곳에 링크 주소를 복사해두고, Link to page 메뉴를 눌러 링크를 페이지에 추가한다.\n그럼 아래와 같은 링크 페이지가 생긴다.\n제3회 99콘 \u0026lt;이력서\u0026gt;\n커서를 갖다 대거나 그 라인을 선택해 두고 메뉴 보기 ::: 눌러 Duplicate 메뉴를 클릭하거나 혹은 Ctrl+D 로 복제한다.\n그럼 복사를 원하는 페이지를 나의 Notion 페이지에 복사하는 것을 성공했다.\nCopy of 제3회 99콘 \u0026lt;이력서\u0026gt;\n끝.\n"
}]